## 6.1 泛型

泛型程序设计是实现可重用组件的一种手段。

### 6.1.1 泛型简介

在大部分情况下，程序中不需要显示地指定类型参数的实际类型。TypeScript编译器能够根据函数调用的实际参数自动第推断类型参数的实际类型。

### 6.1.2 形式类型参数

#### 6.1.2.1 形式类型参数声明

泛型类型参数能够表示绑定到泛型类型或泛型函数调用的某个实际类型。在类声明、接口声明、类型别名声明以及函数声明中都支持定义类型参数。

形式类型参数名通常以大写字母开头。

建议形式类型参数名以大写字母T(Type的首字母)作为前缀。

T U V W X Y Z

#### 6.1.2.2 类型参数默认类型

在声明形式类型参数时，可以为类型参数设置一个默认类型。

`<T = DefaultType>`

类型参数的默认类型也可以应用形式类型参数列表中的其他类型参数，但是只能引用在当前类型参数左侧（前面）定义的类型参数。

#### 6.1.2.3 可选的类型参数

在形式类型参数列表中，必选类型参数不允许出现在可选类型参数之后。

### 6.1.3 实际类型参数

### 6.1.4 泛型约束

#### 6.1.4.1 泛型约束声明

在泛型的形式类型参数上运行定义一个约束条件，它能够限定类型参数的实际类型的最单范围。

对于一个形式类型参数，可以同时定义泛型约束和默认类型，但默认类型必须满足泛型约束。

#### 6.1.4.2 泛型约束引用类型参数

在泛型参数约束中，约束类型运行引用当前形式类型参数列表中的其他类型参数。

#### 6.1.4.3 基约束

本质上，每个烈性参数都有一个基约束（Base Constraint）

- 规则一，如果类型参数T声明了泛型约束，且泛型约束为另一个类型参数U，那么类型参数T的基约束为类型参数U.
- 规则二，如果类型参数T声明了泛型约束，且泛型约束为某一具体类型Type，那么类型参数T的基约束为类型Type。
- 规则三：如果类型参数T没有声明泛型约束，那么类型参数T的基约束为空对象类型字面量“{}”。

#### 6.1.4.4 常见错误

### 6.1.5 泛型函数

泛型函数中的类型参数用来描述不同参数之间以及参数和函数返回值之间的关系。

#### 6.1.5.1 泛型函数定义

#### 6.1.5.2 泛型函数示例

#### 6.1.5.3 泛型函数类型推断

在大部分情况下，TypeScript编译器能够自动推断出泛型类型的实际类型参数。

TypeScript有一个原则，始终将字面量视为字面量类型，只要在必要的时候才会将字面量类型放宽为某种基础类型。

#### 6.1.5.4 泛型函数注意事项

如果一个函数既可以定义为非泛型函数，又可以定义为泛型函数，那么推荐使用非泛型函数的形式。

当泛型函数的类型参数只在函数签名中出现了一次时，该泛型函数是非必要的。

该问题的本质是，泛型函数的类型参数是用来关联对各不同值的类型的。

### 6.1.6 泛型接口

在引用泛型接口时，必须指定实际类型参数，除非类型参数定义了默认类型。

`Array<T>`是TypeScript内置的泛型数组类型。

### 6.1.7 泛型类型别名

若类型列名的定义中带有类型参数，那么它是泛型类型列名。

#### 6.1.7.1 泛型类型别名定义

#### 6.1.7.2 泛型类型别名示例

在引用泛型类型别名表示的类型时，必须指定实际类型参数。

### 6.1.8 泛型类

若类的定义中带有类型参数，那么它是泛型类。

每个声明都会创建两种类型，即类的实例类型和类的构造函数类型。泛型类描述的是类的实例类型。因为类的静态成员是类构造函数类型的一部分，所以泛型类型参数不能用于类的静态成员。

## 6.2 局部类型

- 局部枚举类型
- 局部类类型
- 局部接口类型
- 局部类型别名

## 6.3 联合类型

联合类型有一组有序的成员类型构成。联合类型表示一个值的类型可以为若干中类型之一。

联合类型通过联合类型字面量来定义。

### 6.3.1 联合类型字面量

`type NumericType = number | bigint`

联合成员类型可以为任意类型。

如果联合类型中存在相同的成员类型，那么相同的成员类型将合并为单一成员类型。

联合类型的成员类型可以进行简化。假设有联合类型“U = T0 | T1”，如果T1是T0的子类型，那么可以将类型成员T1从联合类型U中消去。

### 6.3.2 联合类型的类型成员

像接口类型一样，联合类型作为一个整体也可以由类型成员，只不过联合类型的类型成员是由其他成员类型决定的。

#### 6.3.2.1 属性签名

若联合类型U中的每个成员类型都包含一个同名的属性签名M，那么联合类型U也包含属性签名M.

对于联合类型的属性签名，其类型为所有成员类型中该属性类型的联合类型。

如果联合类型的属性签名在某个成员类型中是可选属性签名，那么该属性签名在联合类型中也是可选属性签名；否则该属性签名在联合类型中是必选属性。

#### 6.3.2.2 索引签名

如果联合类型中每个成员都包含字符串索引签名，那么该联合类型也拥有了字符串索引签名，字符串索引签名的索引值类型为每个成员属性中索引值类型的联合类型；否则，该联合类型没有字符串索引签名。

如果联合类型中每个成员都包含数值索引签名，那么该联合类型也拥有了数值索引签名，数值索引签名中的索引值类型为每个成员类型中索引值类型的联合类型；否则，该联合类型没有数值索引签名。

#### 6.3.2.3 调用签名与构造签名

如果联合类型中每个成员类型都包含相同参数列表的调用签名，那么联合类型也拥有了该调用签名，其返回值类型为每个成员类型中调用签名返回值类型的联合类型；否则，该联合类型没有调用签名。

同理，如果联合类型中每个成员都包含相同参数列表的构造签名，那么该联合类型也拥有了构造签名，其返回值类型为每个成员类型中构造签名返回值类型的联合类型；否则，该联合类型没有构造签名。

## 6.4 交叉类型

交叉类型在逻辑上与联合类型是互补的。联合类型表示一个值的类型为多种类型之一，而交叉类型表示一个值同时属性多种类型。

### 6.4.1 交叉类型字面量

交叉类型由两个或多个成员类型构成，各成员类型之间使用“&”符号分隔。

#### 6.4.1.1 成员类型的运算

相同的成员类型将被合并为单一成员类型。

需要注意的是，当交叉类型涉及调用签名重载或构造签名重载时便失去了“加法交换律”的性质。调用签名重载的顺序与交叉类型中成员类型的定义顺序是一致的。

#### 6.4.1.2 原始类型

交叉类型通常与对象类型一起使用。虽然在交叉类型中运行使用原始类型，但结果类型将成为never类型，因此在实际代码中并不常见。

### 6.4.2 交叉类型的类型成员

#### 6.4.2.1 属性签名

对于交叉类型的属性签名，其类型为所有成员类型中该属性类型的交叉类型。

若交叉类型的属性签名M在所有成员类型中都是可选属性，那么该属性签名在交叉类型中也是可选属性。否则，属性签名M是一个必选属性。

#### 6.4.2.2 索引签名

如果交叉类型中任何一个成员类型包含了索引签名，那么该交叉类型也拥有了索引签名，否则，该交叉类型中没有索引签名。

交叉类型索引签名中的索引值类型为每个成员类型中索引值类型的交叉类型。

#### 6.4.2.3 调用签名与构造签名

若交叉类型的成员类型中好友调用签名或构造签名，那么这些调用签名和构造签名将以成员类型的先后顺序合并到交叉类型中。

当交叉类型中存在重载签名时，需要特别留意类型成员的定义顺序。

### 6.4.3 交叉类型与联合类型

#### 6.4.3.1 优先级

当表示交叉类型的“&”符号与表示联合类型的“|”符号同时使用时，“&”符号具有更高的优先级。

还要注意，当表示交叉类型的“&”符号与表示联合类型的“|”符号的函数类型字面量同时使用时，"&"符号和“|”符号拥有更高的优先级。

#### 6.4.3.2 分配律性质

由交叉类型和联合类型组成的类型满足类似于数据中乘法分配律的规则。

& ->*

| -> +

## 6.5 索引类型

对于一个对象而言，我们可以使用属性名作为索引来访问属性值。相似地，对于一个对象类型而言，我们可以使用属性名作为索引来访问属性类型成员的类型。TypeScript引入了两个新的类型结构来实现索引类型：

- 索引类型查询
- 索引访问类型

### 6.5.1 索引类型查询

通过索引类型查询能够获取给定类型中的**属性名类型**。索引类型查询的结果是由字符串字面量类型构成的联合类型，该联合类型中的每个字符串字面量类型都表示一个属性名类型：

`keyof Type`

#### 6.5.1.1 索引类型查询解析

索引类型查询获取的是对象的键的类型，因此索引类型查询的结果类型是联合类型“string | symbol”的子类型。

但由于数组类型是非常用且其索引值的类型为number类型，因此编译器额外将number类型纳入了索引类型查询的结果类型范围。于是，索引类型查询的结果类型是联合类型“string |number | symbol”的子类型，这是编译器内置的类型约束。

注意，如果想要在对象类型中声明属性名为symbol类型的属性，那么属性名的类型必须为“unique symbol”类型，而不允许为symbol类型。

虽然在对象类型上使用索引类型查询更有意义，但是索引类型查询也允许在非对象类型上使用，例如原始类型、顶端类型等。



对于原始类型使用索引类型查询，先查找与原始类型对应的内置对象类型，然后再进行索引类型查询。

#### 6.5.1.2 联合类型

在索引类型查询中，如果查询的类型为联合类型，那么先计算联合类型的结果类型，在执行索引类型查询。

#### 6.5.1.3 交叉类型

在索引类型查询中，如果查询的类型为交叉类型，那么会将原索引类型查询展开为子索引类型查询的联合类型，展开的规则类似数学中的“乘法分配律”。

### 6.5.2 索引访问类型

索引访问类型能够获取对象类型中属性成员的类型。

`T[K]`

在该语法中，T和K都表示类型。

如果K是字符串字面量类型、数字字面量类型、枚举字面量类型或“unique symbol”类型，并且类型T中包含名为K的公共属性，那么“T[k]”的类型就是该属性的类型。

若K是联合类型“K1 | K2”，那么“T[K]”等于联合类型“T[K1] | T[K2]”。

若K类型能够赋值给string类型，且类型T中包含字符串索引签名，那么“T[K]”为字符串索引签名的类型。但如果类型T中包含同名的属性，那么同名属性的类型拥有更高的优先级。

若K类型能够赋值给number类型，且类型T中包含数值索引签名，那么“T[K]”为数值索引签名的类型。但如果类型T中包含同名的属性，那么同名属性的类型拥有更高的优先级。

### 6.5.3 索引类型的应用

通过结合使用索引类型查询和索引访问类型就能够实现类型安全的对象属性访问操作。

## 6.6 映射对象类型

映射对象类型是一种独特的对象类型，它能够将已有的对象类型映射为新的对象类型。

### 6.6.1 映射对象类型声明

映射对象类型是一个类型运算符，它能够遍历联合类型并以联合类型的类型成员作为属性名类型来构造一个对象类型。

`{readonly [P in K]? : T}`

在该语法中，readonly是关键字，表示属性是否为只读属性，该关键字是可选的；“?”修饰符表示该属性是否为可选属性，该修饰符是可选的；in是遍历语法的关键字；K表示要遍历的类型，由于遍历的结果类型将作为对象属性名类型，因此类型K必须能够赋值给连个类型“string | number symbol”，因此只有这些类型的值才能作为对象的键；P是类型变量，代表每次遍历出来的成员类型；T是任意类型，表示对象属性的类型，并且在类型T中允许使用类型变量P。

映射对象类型的运算结果是一个对象类型。

### 6.6.2 映射对象类型解析

若当前连理出来的类型成员P为字符串字面量类型，则在结果对象类型中创建一个新的属性成员，属性名类型为该字符串字面量类型且属性值类型为T。

若当前遍历出来的类型成员P为数字字面量类型，则在结果对象类型中创建一个新的属性成员，属性名类型为该数字字面量类型且属性值类型为T

若当前遍历出来的类型成员P为“unique symbol”类型，则在结果对象类型中创建一个新的属性成员，属性名类型为该“unique symbol”类型且属性值类型为T。

若当前遍历出来的类型成员P为string类型，则在结果对象中承建字符串索引签名。

number类型同理。

### 6.6.3 映射对象类型应用

将映射对象类型与索引类型查询结合使用就能够遍历已有对象类型的所有属性成员，并使用相同的属性来创建一个新的对象类型。

将映射对象类型、索引类型查询以及索引访问类型三者结合才能够最大限度地体现映射对象类型的位置。

内置工具类型： `Partial<T> Readonly<T>`

### 6.6.4 同态映射对象类型

映射后的对象对象结构与源对象类型T的结构完全一致，我们将这种映射对象类型称为同态映射对象类型。

如果映射对象类型中存在索引类型查询，那么TypeScript编译器会将该映射对象类型视为同态映射对象类型。

#### 6.6.4.1 修饰符拷贝

同态映射对象类型的一个重要性质是，新的对象类型会默认拷贝源对象类型中所有属性的readonly修饰符和“?”修饰符。

非同态映射对象不会从原对象类型T中拷贝属性修饰符。

#### 6.6.4.2 改进的修饰符拷贝

TypeScript特殊处理了映射对象类型中索引类型为类型参数的情况。

#### 6.6.4.3 添加和移除修饰符

不论是同态映射对象类型的修饰符拷贝规则还是改进的映射对象类型修饰符拷贝规则，他们都无法删除属性已有的修饰符。因此，TypeScript引入了两个新的修饰符用来精确控制天假或引出映射属性的“？”修饰符和readonly修饰符。

需要注意的是“-”"+"修饰符仅作用域带有“?”和readonly修饰符的属性。编译器在移除属性a的“？”修饰符时，同时会移除属性类型中的undefined类型。

#### 6.6.4.4 同态映射对象类型深入

同态映射对象类型是一种能够维持对象结构不变的映射对象类型。

`type HMOT<T, X> = { [P in keyof T]: X }`

若T为原始类型，则不进行任何映射。

若T为联合类型，则对雷和类型的每个成员类型求同态映射对象类型，并使用每个结果类型构造一个联合类型。

若T为数组类型，则同态映射对象类型“HMOT<T, X>”也为数组类型。此时，若映射属性类型X为索引访问类型“T[P]”，则映射属性类型X等于数组T的成员类型。

若T为只读数组类型，则同态映射对象类型“HMOT<T, X>”也为只读数组类型。

若T为元组类型，则同态映射对象类型“HMOT<T, X>”也为元组类型。此时，若映射属性类型X为索引访问类型“T[P]”，则映射属性类型X等于元组T中对应成员的类型。

## 6.7 条件类型

条件类型与条件表达式类似，它表示一种非固定的类型。

### 6.7.1 条件类型定义

`T extend U ? X : Y`

在实际应用中，条件类型通常与类型参数结合。

### 6.7.2 分布式条件类型

#### 6.7.2.1 裸类型参数

如果类型参数不是复合类型的组成部分而是独立出现，那么该类型参数称作裸类型参数。

#### 6.7.2.2 分布式行为

在使用实际类型参数实例化分布式条件类型时，如果实际类型参数T为联合类型，那么会将分布式条件类型展开为由子条件类型构成的联合类型。

#### 6.7.2.3 过滤联合类型

#### 6.7.2.4 避免分布式行为

一种可行的方法是将分布式条件类型中的裸类型参数修改为非裸类型参数，这可以通过将extends两侧的类型包裹在元组类型中来事项。

### 6.7.3 infer关键字

`T extends U ? X : Y`

在extends语句中类型U的位置上运行使用infer关键字来定义可推断的类型变量，可推断的类型变量值运行在条件类型的true分支中引用，即类型X的位置上使用。

“ReturnType<T>”类型接收函数类型的类型参数，并返回函数的返回值类型。

## 6.8 内置工具类型

### 6.8.1 Partial<T>

该工具能构造一个新类型，并将实际类型参数T中的所有属性变为可选属性。

### 6.8.2 Required<T>

将实际类型参数T中的所有属性变为必选属性。

### 6.8.3 Readonly<T>

同上类似，只读属性

### 6.8.4 Record<K, T>

该工具能够使用给定的对象属性名类型和属性属性类型创建一个新的对象类型。

### 6.8.5 Pick<T, K>

该工具类型能够从已有对象类型中选取给定的属性机器类型，然后构建出一个新的对象类型。

### 6.8.6 Omit<T, K>

它能够从已有对象类型中踢出给定的属性，然后构建出一个新的对象类型。

### 6.8.7 Exclude<T, U>

该工具类型能够从类型T中退出所有可以复制给类型U的类型。

### 6.8.8 Extract<T, U>

他能够从类型T中获取所有可以复制给类型U的类型。

### 6.8.9 NonNullable<T>

获取类型T中的非空类型。

### 6.8.10 Parameters<T>

该工具类型能够获取函数类型T的参数类型并使用参数类型构造一个元组类型。

### 6.8.11 ConstructorParameters<T>

该工具类型能够获取构造函数T中的参数类型，并使用参数类型构造一个元组类型。

### 6.8.12 ReturnType<T>

该工具类型能够获取函数类型T的返回值类型。

### 6.8.13 InstanceType<T>

该工具类型能够获取构造函数的返回值类型，即实例类型。

### 6.8.14 ThisParameterType<T>

该工具类型能够获取函数类型T中this参数的类型，若函数类型中没有定义this参数，则返回unknown类型。

### 6.8.15 OmitThisParameter<T>

该工具类型能够从类型T中剔除this参数类型，并构造一个新类型。

### 6.8.16 ThisType<T>

用于定义对象字面量的方法中this的类型。

## 6.9 类型查询

TypeScript对JavaScript中的typeof运算符进行了扩展，使其能够在表示类型的位置上使用。

若想获取特定的“unique symbol”值的类型，则需要使用typeof类型查询，否则将无法引用其类型。

## 6.10 类型断言

TypeScript程序中的每一个表达式都具有某种类型，编译器可以通过类型注解或者类型推断来确定表达式的类型。但有时候，开发者比编译器更加清除某个表撒施的类型。

### 6.10.1 `<T>`类型断言

`<T>expr`

### 6.10.2 as T类型断言

as T类型断言与<T>类型断言的功能完全相同，两者只是在语法上有所区别。

`expr as T`

当在TypeScript中使用JSX时，仅支持as T类型断言语法。

目前主流的编码风格规范推荐使用as T类型断言语法。

### 6.10.3 类型断言的约束

类型断言不允许在两个类型之间随意做转换二是需要满足一定的前提。

在程序红使用类型断言时，就相当于开发者在告诉编译器“我清除我在做什么”。

进行了两次类型断言，先将expr的类型转换为顶端类型unknown，而后再转化为目标类型。

### 6.10.4 const类型断言

它能够将某一类型转换为不可变类型。

expr则要求是以下字面量中的一种：

- boolean字面量
- string字面量
- number字面量
- bigint字面量
- 枚举成员字面量
- 数组字面量
- 对象字面量

如果expr为数组字面量，那么转换后的结果类型为只读元组类型。

如果expr为对象字面量，那么转换后的结果类型会将对象字面量中的属性全部转换成只读属性。

在可变值的位置上，编译器会推断出放宽的类型。

### 6.10.5 !类型断言

它是非空类型断言的一部分。非空类型断言能够从某个类型中踢出undefined类型和null类型。

`expr!`

在代码中使用了非空类型断言时，相当于子告诉编译器expr的值不是undefined值和null值。

当编译器遇到非空类型断言时，就会无条件地相信表达式的类型不是undefined类型和null类型，因此，不应该滥用非空类型断言。

## 6.11 类型细化

