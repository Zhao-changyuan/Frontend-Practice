## 7.1 子类型兼容性

面向对象程序设计中的里氏替换原理描述了程序中任何使用了超类型的点都可以用其子类型今夕替换，并且在替换后程序的行为保持不变。

### 7.1.1 类型系统可靠性

如果一个类型系统能够识别并拒绝程序中所有可能的类型错误，那么我们称该类型系统是可靠的。

### 7.1.2 子类型的基本性质

#### 7.1.2.1 符号约定

#### 7.1.2.2 自反性

即任意类型都是其自身的子类型和超类型。

#### 7.1.2.3 传递性

### 7.1.3 顶端类型

顶端类型与魏雷星的概念来自类型论，他们是独立于编程语言而存在的。

### 7.1.4 原始类型

number

bigint

boolean

string

symbol

void

null 

undefined

枚举类型

字面量类型

#### 7.1.4.1 字面量类型

字面量类型是其对应的基础原始类型的子类型。

#### 7.1.4.2 undefined与null

undefined类型是除尾端类型never外所有类型的子类型，其中也包括null类型。

#### 7.1.4.3 枚举类型

在联合枚举类型中，每个绝句成员都能够表示一种类型，同时联合枚举成员类型是联合枚举类型的子类型。

### 7.1.5 函数类型

函数类型有参数类型和返回值类型构成。在比较两个函数类型间的子类型关系时要同时考虑参数类型和返回值类型。

#### 7.1.5.1 变型

变型描述的是复杂类型的组成类型是如何影响复杂类型间的子类型关系的。

变型关系主要有一下三种：

- 协变
- 逆变
- 双变

假设有两个复杂类型Complex(A)和Complex(B)，如果由A是B的子类型能够得出Complex(A)是Complex(B)的子类型，那么我们将这种变型称作协变。

如果由A是B的子类型能够得出Complex(B)是Complex(A)的子类型，那么我们将这种变型称作逆变。

如果由A是B的子类型或者B是A的子类型能够得出Complex(A)是Complex(B)的子类型，那么我们将这种变型称作双变。

#### 7.1.5.2 函数参数数量

在确定函数类型间的子类型关系时，编译器将检查函数的参数数量。

若函数类型S是函数类型T的子类型，则T中的可选参数会计入参数总数。

若函数类型S是函数类型T的子类型，则S中的可选参数不计入参数总数，即允许S中存在多余的可选参数。S中的剩余参数也不计入参数总数。

#### 7.1.5.3 函数参数类型

- 非严格函数类型检查模式 默认
- 严格函数类型检查模式

非严格模式下，函数参数类型与函数类型是双变关系。

**2. 严格函数类型检查**

TypeScript编译器提供了“--strictFunctionTypes”编译选项来启用严格的函数类型检查。

在该模式下，函数参数类型与函数类型是逆变关系。

若函数类型S是函数类型T的子类型，那么S的参数类型必须是T中对应参数类型的超类型。

#### 7.1.5.4 函数返回值类型

函数返回值类型与函数类型始终是协变关系。

#### 7.1.5.5 函数重载

若函数类型S是函数类型T的子类型，并且T存在函数重载，那么T的每一个函数重载必须能够在S的函数重载中找到预期对应的子类型。

### 7.1.6 对象类型

对象类型有零个或多个类型成员组成，在比较对象类型的子类型关系是要分别考虑每一个类型成员。

#### 7.1.6.1 结构化子类型

在结构化子类型系统中仅通过比较两个对象类型的类型成员列表就能够确定他们的子类型关系。

#### 7.1.6.2 属性成员类型



#### 7.1.6.3 调用签名与构造签名

#### 7.1.6.4 字符串索引签名

#### 7.1.6.5 数值索引签名

#### 7.1.6.6 类实例类型

在确定两个类类型之间的子类型关系时仅金叉类的实例成员类型，类的静态成员类型以及构造函数类型不进行检查。

如果类中存在私有成员或受保护成员，那么在确定类类型间的子类型关系时要求成员和受保护成员来自同一个类型，这意味着这两个类需要存在**继承关系**。

#### 7.1.7 泛型

#### 7.1.7.1 泛型对象类型

对于泛型接口、泛型类和表示对象类型的泛型类型别名而言，实例化泛型类型时使用的实际类型参数不影响子类型关系，真正影响子类型关系的是泛型实例化后的的结果对象类型。

#### 7.1.7.2 泛型函数类型

与检查函数类型相似，编译器在检查泛型函数类型时有两种检查模式可供选择：

- 非严格泛型函数类型检查
- 严格泛型函数类型检查。

--noStrictGenericChecks

### 7.1.8 联合类型

在按联合类型的子类型关系时需要考虑每一个成员类型。

#### 7.1.9 交叉类型

在计算交叉类型的子类型关系时需要考虑每一个成员类型。

## 7.2 赋值兼容性

若类型S是类型T的子类型，那么类型S能够赋值给类型T。

以下几种以外情况：

- any类型。在赋值兼容性中，any类型能够估值给任何其他类型，但any类型不是其他类型的子类型，因为any类型是顶端类型。
- 数值类型枚举与number类型。
- 带有可选属性的对象类型。

## 7.3 类型推断

表达式类型的来源有以下两种：

- 类型注解
- 类型推断

### 7.3.1 常规类型推断

如果声明变量时没有设置初始值，那么编译器将推断出变量的类型为any类型。

如果编译器自动推断出来的类型不是我们想要的类型，那么可以给表达式添加明确的类型注解或者使用类型断言。

### 7.3.2 按上下文归类

编译器还能由变量的类型来推断出变量初始值的类型。

## 7.4 类型放宽

在编译器进行类型推断的过程中，优势会将放宽的源类型作为推断的结果类型。

类型放宽是TypeScript语言的内部行为，它并非是提供给开发者的某种功能特性。

- 常规类型放宽
- 字面量类型放宽

### 7.4.1 常规类型放宽

常规类型放宽相对简单，是指编译器在进行类型推断时会将undefined类型和null类型放宽为any类型。

#### 7.4.1.1 非严格类型检查模式

在非严格类型检查模式下，即没有启用“--strictNullChecks”编译选项时，undefined类型和null类型放宽为any类型。

#### 7.4.1.2 严格类型检查模式

### 7.4.2 字面量类型放宽

字面量类型放宽是指编译器在进行类型推断时会将字面量类型放宽为基础原始类型。

#### 7.4.2.1 细分字面量类型

## 7.5 命名空间

最流行的实现命名空间的方法时使用立即执行的函数表达式。

TypeScript利用了这个经典的命名空间实现方式并提供了声明命名空间的简便语法。

### 7.5.1 命名空间声明

命名空间通过namespace关键字来声明，它相当于一宗语法糖。

在定义命名空间的名字时雨欣使用以点符号“.”分隔的名字，相当于两个嵌套的命名空间声明。

### 7.5.2 导出命名空间内的声明

默认情况下，在命名空间内部的声明只允许在该命名空间内部使用。

如果想要让命名空间内部的某个声明在命名空间外部也能够使用，则需要使用导出声明语句明确地导出该声明语句。

在访问导出的命名空间声明时，需要使用命名空间名和导出声明名并用点符号连接，这类似于对象属性访问的语法。

### 7.5.3 别名导入声明

我们可以使用import语句为命名空间的导出声明起一个别名。

需要注意的是，别名导入也是相当于新声明了一个变量而已，实际上不完全涉这样的，因为别名导入对类型也有效。

### 7.5.4 在多文件中使用命名空间

TypeScript最终会将同名的命名空间声明合并在一起。

#### 7.5.4.1 文件间的依赖

定义文件间依赖两种方式：

- 使用tsconfig.json文件
- 使用三斜线指令

#### 7.5.4.2 tsconfig.json

通过“tsconfig.json”配置文件能够定义文件间的加载顺序。

#### 7.5.4.3 三斜线指令

我们可以通过它来定义文件间的依赖。

### 7.5.5 小结

在新的工程或面向未来的代码中，推荐优先选择某块来代替命名空间。

## 7.6 模块

在新的工程或代码中，应该优先使用模块来组织代码。

### 7.6.1 模块简史

- CommonJS

- AMD

- UMD

#### 7.6.1.1 CommonJS

CommonJS是一个主要用于服务器端JavaScript程序的模块系统。

#### 7.6.1.2 AMD

AMD表示异步模块定义，Asynchronous Module Definition。

#### 7.6.1.3 UMD

Universal Module Definition 通用模块定义。浏览器&Node.js

#### 7.6.1.4 ESM

ECMAScript 模块。

### 7.6.2 ECMAScript模块

### 7.6.3 模块导出

模块导出语句包含以下两类：

- 命名模块导出
- 默认模块导出

#### 7.6.3.1 命名模块导出

#### 7.6.3.2 命名模块导出列表

进行命名模块导出时，一次只能导出一个声明，而命名模块导出列表能够一次性导出多个声明。

命名模块导出语句和命名模块导出列表语句也可以同时使用。

#### 7.6.3.3 模块模块导出

默认模块导出时一种特殊形式的模块导出，它等同于名字为“default”的命名模块导出。因此，一个模块中只允许存在一个默认模块导出。

#### 7.6.3.4 聚合模块

聚合模块是指将其他模块的模块导出作为当前模块的模块导出。

需要注意的是，在聚合模块时不会引入任何本地声明。

### 7.6.4 模块导入

import

#### 7.6.4.1 导入命名模块

#### 7.6.4.2 导入整个模块

#### 7.6.4.3 导入模块模块

#### 7.6.4.4 空导入

空导入语句不会导入任何模块导出，它只是执行模块内的代码。空导入的用途是“导入”模块的副作用。

“副作用”指的是摸个操作会对外部环境产生影响。

应尽量保持模块与外部环境的隔离，将模块的实现封闭在模块内部，并通过导入和导出语句与模块外部进行交互。

### 7.6.5 重命名模块导入和导出

#### 7.6.5.1 重命名模块导出

#### 7.6.5.2 重命名聚合模块

#### 7.6.5.3 重命名模块导入

### 7.6.6 针对类型的模块导入与导出

类和名句既能表示一个值也能表示一种类型。

针对类型的的导入导出语句，不会导出值，只导出类型。

#### 7.6.6.1 背景介绍

如果模块的导入导出语句满足如下条件，那么在编译生成JavaScript时编译器会删除相应的导入导出语句，具体的条件如下：

- 模块导入或导出的标识符仅被用在类型的位置上。
- 模块导入或导出的标识符没有被用在表达式的位置，即没有作为一个值使用。

#### 7.6.6.2 导入与导出类型

针对类型的模块导入导入语法是在前面介绍的模块导入导入语法语句中添加type关键字。

#### 7.6.6.3 --importsNotUsedAsValues

- "remove"（默认值）。该选项是编译器的默认行为，它自动删除之和类型相关的import语句。
- "preserve"。该选项会保留所有import语句。
- "error"。该选项会保留所有import语句，发现可以改写为“import type”的import语句时会报错。

### 7.6.7 动态模块导入

动态模块导入通过调用特殊的“import()”函数来实现。该函数接收一个模块路径作为参数，并返回Promise对象。

### 7.6.8 --module

TypeScript编译器提供了“--module”编译选项来设置编译生成的JavaScript代码使用的模块格式。可选值如下：

- None
- CommonJS
- AMD
- System
- UMD
- ES6
- ES2015
- ES2020
- ESNext



## 7.7 外部声明

TypeScript语言主要有两种类型的源文件：

- 文件扩展名为”.ts“或”.tsx“的文件。
- 文件扩展名为".d.ts"的文件。

“.d.ts”文件是类型声明文件，值提供类型声明，不提供任何值，如字符串和函数实现。

声明文件中的内容是外部声明。外部声明用于为已有代码提供静态类型信息以供TypeScript编译器使用。

外部声明是TypeScript语言规范中使用的术语。

两类：

- 外部类型声明
- 外部模块声明

### 7.7.1 外部类型声明

外部类型声明通过declare关键字来定义，包含外部变量声明、外部函数声明、外部类声明、外部枚举声明和外部命名空间声明。

#### 7.7.1.1 外部变量声明

#### 7.7.1.2 外部声明函数

#### 7.7.1.3 外部类声明

`declare class`

外部类声明中的成员不允许带有具体实现，只允许定义类型。

#### 7.7.1.4 外部枚举声明

外部枚举类型声明与常规的枚举声明的语法是相同的。

- 在挖补枚举声明中，枚举成员的值比为常量枚举表达式。
- 在使用了“declare enum”的外部枚举中，若枚举成员省略了初始值，则会被视为计算枚举成员，一次不会被赋予一个自增长的初始值。

#### 7.7.1.5 外部命名空间声明

`declare namespace`

外部命名空间的成员默认为导出成员，不需要使用export关键字来明确地导出他们。

### 7.7.2 外部模块声明

外部声明模块定义了一个模块类型。外部模块声明只能在文件顶层定义，并且存在于全局命名空间当中。

## 7.8 使用声明文件

TypeScript中的“.d.ts”声明文件主要有以下几种来源：

- TypeScript语言内置的声明文件
- 安装的第三方声明文件
- 自定义的声明文件

### 7.8.1 语言内置的声明文件

统一使用“lib.[description].d.ts”命名方式。

### 7.8.2 第三方声明文件

#### 7.8.2.1 含有内置声明文件

#### 7.8.2.2 DefinitelyTyped

DefinitelyTyped是一个空开的集中式的TypeScript声明文件代码仓库。

#### 7.8.2.3 typings与types

TypeScript扩展了“package.json”文件，增加了typings属性和types属性。他们都用于指定当前npm包提供的声明文件。

#### 7.8.2.4 typesVersions

每个声明文件都有其兼容的TypeScript语言版本。

typesVersions中的声明顺序很关键，编译器将从第一个声明开始尝试匹配，若匹配陈宫，则应用匹配到的值并退出。

### 7.8.3 自定义声明文件

跳过对某个第三方代码库的类型检查。

## 7.9 模块解析

当在程序中导入了一个模块时，编译器会去查找并读取导入模块的定义，我们将该过程叫做模块解析。

### 7.9.1 相对模块导入

在模块导入语句中，若模块名以下列符号开始，那么它就是相对模块导入：

- /
- ./
- ../

### 7.9.2 非相对模块导入

不是以上面符号开始。

### 7.9.3 模块解析策略

两种：

- Classic策略
- Node策略

模块解析策略可以使用“--moduleResolution”编译选项来指定。

若“--module”编译选项的值不为CommonJS，则默认的模块解析策略为Classic。

### 7.9.4 模块解析策略之Classic

它尝试将模块名视为一个文件进行解析。

#### 7.9.4.1 解析相对模块

先查TypeScript文件，再查JavaScript文件。

#### 7.9.4.2 解析非相对模块导入

三个阶段：

1）将导入的模块名视为文件，从当前目录开始向上遍历至系统根目录，并查找Type-Script文件。

2）将导入的模块名视为安装的声明文件，从当前目录开始向上遍历至系统根目录，并在每一级目录下的“node_modules/@types”文件夹中查找安装的声明文件。

3）将导入的模块名视为文件，从当前目录开始向上遍历至系统根目录，并查找Java-Script文件。

### 7.9.5 模块解析策略之Node

模仿Node.js的模块解析策略。

#### 7.9.5.1 解析相对模块导入

1）将导入的模块名视为文件，并在指定目录中查找TypeScript文件。

2）将导入的模块名视为目录，并在该目录中查找“package.json”文件，然后解析“package.json”文件中的typings属性和types属性。

3）将导入的模块名视为文件，并在指定目录中查找JavaScript文件。

4）将导入的模块名视为目录，并在该目录中查找“package.json”文件，然后解析“package.json”文件中的main属性。

### 7.9.6 --baseUrl

该编译选项用来设置非相对模块导入的基准路径。

### 7.9.7 paths

paths编译选项用来设置模块名和模块路径的映射，用于设置非相对模块导入的规则。

### 7.9.8 rootDirs

rootDirs编译选项能够使用不同的目录创建出一个虚拟目录。在解析相对模块导入时，编译器会在rootDirs编译选项构建出俩的虚拟目录中进行搜索。

### 7.9.9 导入外部模块声明

### 7.9.10 --traceResolution

编译器会打印出模块解析的具体步骤。

## 7.10 声明合并

在TypeScript语言中，一个标识符总共可以有一下三种含义：

1. 表示一个值
2. 表示一个类型
3. 表示一个命名空间

对于同一个标识符而言，它可以同时具有上述多种含义。

当编译器发现同一声明空间内存在同名的声明时，会尝试将所有同名的声明合并为一个声明，即声明合并。