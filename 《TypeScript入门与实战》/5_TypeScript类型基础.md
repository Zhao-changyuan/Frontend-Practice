## 5.1 类型注解

`:Type`

TypeScript中的类型注解是可选的。

## 5.2 类型检查

在严格类型检查模式下不允许将undefined值和null值赋给string类型的变量。

## 5.3 原始类型

- boolean
- string
- number
- bigint
- symbol
- undefined
- null
- void
- 枚举类型
- 字面量类型

bigint采用了特殊的对象数据结构来表示和存储一个整数。

为了能够将一个Symbol值视作表示固定值的字面量，TypeScript引入了“unique symbol”类型。

"unique symbol"类型的主要用途是用作接口、类等类型中的可计算属性名。

"unique symbol"类型的值只允许使用“Symbol()”函数或“Symbol.for()”方法的返回值进行初始化。

在设计上，每一个“unique symbol”类型都是一种独立的类型。

“unique symbol”类型是symbol类型的子类型。



TypeScript中的Nullable类型指的是值可以为undefined或null的类型。

当启用了“--strictNullChecks”编译选项时，undefined值和null值不再能够赋值给不相关的类型。在该模式下，undefined值只能够赋值给undefined类型，同理null值也只能复制给null类型。

但undefined值和null值允许赋值给顶端类型。

### 5.3.7 void

void类型表示某个值不存在，该类型用作函数的返回值类型。

除了将void类型作为函数返回值类型外，在其他地方使用void类型是无意义的。

当启用了“--strictNullChecks”编译选项时，只允许将undefined值赋值给void类型。如果没启用，将允许undefined和null.

## 5.4 枚举类型

在TypeScript中，枚举类型是一种原始类型，它通过enum关键字来定义。

- 数值型枚举
- 字符串枚举
- 异构型枚举

### 5.4.1 数值型枚举

数值型枚举时number类型的子类型。

在你定义数值型枚举时，可以为一个或多个枚举成员设置初始值。对于位指定初始值的枚举成员，其值为前一个枚举成员的值加1.

### 5.4.2 字符串枚举

在字符串枚举中，枚举成员的值为字符串。字符串枚举成员必须使用字符串字面量或另一个字符串枚举成员来初始化。

字符串枚举是string类型的子类型。但是反过来，不允许将string类型赋值给字符串枚举类型。

### 5.4.3 异构型枚举

就是可同时定义数值型枚举成员和字符串枚举成员。不推荐使用。

### 5.4.4 枚举成员映射

反过来通过枚举成员值取获取枚举成员名。

### 5.4.5 常量枚举成员与计算枚举成员

若枚举类型的第一个枚举成员没有定义初始值，那么该枚举成员是常量枚举成员并且初始值为0。

若枚举成员没有定义初始值并且与之紧邻的前一个枚举成员值是数值型常量，那么该枚举成员是常量枚举成员并且初始值为紧邻的前一个枚举成员值加1。

若枚举成员的初始值是常量枚举表达式，那么该枚举成员是常量枚举成员。

字面量枚举成员是常量枚举成员的子集。



**程序不依赖枚举成员值时，能够降低代码耦合度，使程序易于扩展。**

### 5.4.6 联合枚举类型

当枚举类型中的所有成员都是**字面量枚举成员**时，该枚举类型成了联合枚举类型。

联合枚举成员类型是联合枚举类型的子类型。



联合枚举类型是由所有联合枚举成员类型构成的联合类型。

### 5.4.7 const枚举类型

在编译时，TypeScript编译器会将枚举类型编译为JavaScript对象。

## 5.5 字面量类型

每一个字面量类型都只有一个可能的值，即字面量本身。

## 5.6 单元类型

单元类型（Unit Type）也叫作单例类型（Singleton Type），指的是仅包含一个可能值的类型。

- undefined类型
- null类型
- unique symbol类型
- void类型
- 字面量类型
- 联合枚举成员类型

## 5.7 顶端类型

顶端类型是一种通用类型。

- any
- unknown

### 5.7.1 any

TypeScript允许将any类型赋值给其他任何类型。

在程序中，我们使用any类型来跳过编译器的类型检查。

从长远来看，我们应该尽量减少在代码中使用any类型。

当启用了“--noImplicitAny”，如果发生了隐式的any类型转换，那么会产生编译错误。

### 5.7.2 unknown

unknown类型是比any类型更安全的顶端类型，因为unknown类型只允许负值给any类型和unknown类型。

在程序中使用unknown类型时，我们必须将其细化为某种具体类型。

如果在编码时确实无法知晓某个值的类型，那么建议优先使用unknown类型来代替any类型。

## 5.8 尾端类型

尾端类型（Bottom Type）是所有其他类型的子类型：never类型。

### 5.8.1 never

### 5.8.2 应用场景

场景一：只有在函数根本无法返回一个值的时候，函数的返回值类型才是never类型。

若函数中的代码不是直接抛出异常而是间接地抛出异常，那么函数的返回值类型也是never类型。

还有一种情况是死循环。



场景二：在“条件类型”种常使用never类型来帮助完成一些类型运算。

## 5.9 数组类型

### 5.9.1 数组类型定义

#### 5.9.1.1 简便数组类型表示法

通过在数组元素类型之后添加一对方括号“[]”来定义数组类型。

`TElement[]`

如果数组中元素的类型为复合类型，则需要在数组元素类型上使用分组运算符，即小括号。

#### 5.9.1.2 泛型数组类型表示法

`Array<TElement>`

### 5.9.2 数组元素类型

TypeScript的类型系统无法推断出是否存在数组访问越界的情况。

### 5.9.3 只读数组

不能通过赋值操作来放宽对只读数组的约束。

## 5.10 元组类型

Tuple，元组类型是数组类型的子类型。元组是长度规定的数组，并且元组中每个元素都有确定的类型。

### 5.10.1 元组的定义

针对元组中每一个位置上的元素都需要定义其数据类型。

### 5.10.2 只读元组

不能通过赋值操作来放宽对只读元组的约束。

### 5.10.3 访问元组的元素

### 5.10.4 元组类型中的可选元素

`[T0?, T1?, ..., Tn?]`

### 5.10.5 元组类型中的剩余元素

`[...T[]]`

### 5.10.6 元组的长度

当元组中包含的可选元素时，元组的长度不再是一个固定值。编译器能够根据元组可选元素的数量识别出元组所有可能的长度，进而构造出一个由数字字面量类型构成的联合类型来表示元组的长度。

### 5.10.7 元组类型与数组类型的兼容性

## 5.11 对象类型

### 5.11.1 Object

这里的Object指的是Object类型。

Object类型是特殊对象“Object.prototype”的类型，该类型的主要作用是描述JavaScript中几乎所有对象都共享（通过原型继承）的属性和方法。

#### 5.11.1.1 类型兼容性

Object类型有一个特点，那就是除了undefined值和null值外，其他任何值都可以赋给Object类型。

#### 5.11.1.2 常见错误

在使用Object类型时容易出现的一个错误是，将Object类型应用与自定义变量、参数或属性等的类型。

在描述自定义对象类型时有很多更好的选择，完全不需要使用Object类型。

### 5.11.2 object

非原始类型

object类型的关注点在于类型的分类，它强调一个类型是非原始类型，即对象类型。**object类型的关注点不是该对象类型具体包含了哪些属性。**

不允许读取和修改object类型上的自定义属性。

**在object类型上仅允许访问对象的公共属性和方法，也就是Object类型中定义的属性和方法。**

#### 5.11.2.1 类型兼容性

只有非原始类型，也就是对象类型能够赋给object类型。

object类型仅能够赋值给一下三种类型：

- 顶端类型any和unknown
- Object类型
- 空对象类型字面量“{}”

#### 5.11.2.2 实例应用

Object.create()方法签名的类型

### 5.11.3 对象类型字面量

对象类型字面量是定义对象类型的方法之一。

#### 5.11.3.1 基础语法

对象类型字面量的类型成员可分为以下五类：

- 属性签名
- 调用签名
- 构造签名
- 方法签名
- 索引签名

#### 5.11.3.2 属性签名

属性签名中的属性名可以为可计算属性名。但需要该可计算属性名满足一下条件之一：

- 可计算属性名的类型为string字面量类型或number字面量类型。
- 可计算属性名的类型为“unique symbol”类型
- 可计算属性名符合“Symbol.xxx”的形式。

在属性签名的语法中，表示类型Type部分是可以省略的，默认为any类型。

在程序中，不推荐省略前面中的类型。

#### 5.11.3.3 可选属性

在属性签名中的属性名之后添加一个问号“?”

在“--strickNullChecks”模式下，TypeScript会自动在可选属性的类型定义中添加undefined类型。

#### 5.11.3.4 只读属性

```TypeScript
{
	readonly PropertyName: Type
}
```

#### 5.11.3.5 空对象类型字面量

如果对象类型字面量没有定义任何类型成员，那么他就成了一种特殊性的类型。即空对象类型字面量“{}”。空对象类型字面量表示不带有任何属性的对象类型，因此不允许在“{}”类型上访问任何自定义属性。

### 5.11.4 弱类型

满足条件：

- 对象类型中至少包含一个属性。
- 对象类型中所有属性都是可选属性。
- 对象类型中不包含字符串索引签名、数值索引签名、调用签名和构造签名。

### 5.11.5 多余属性

#### 5.11.5.1 对于属性检查

多余属性会影响类型间的子类型兼容性以及赋值兼容性，也就是说编译器不允许在一些操作中存在多余属性。

**多余属性检查能够带来的最直接的帮助是发现属性名的拼写错误。**

#### 5.11.5.2 允许多余属性

- 使用类型断言，这是推荐的方法。类型断言能够对类型进行强制转换。
- 启用“--suppressExcessPropertyErrors”编译选项。
- 使用“// @ts-ignore”注释指令
- 为目标对象类型添加索引签名

## 5.12 函数类型

### 5.12.1 常规参数类型

### 5.12.2 可选参数类型

函数的可选参数必须位于函数参数列表的末尾位置。

在“--strictNullChecks”模式下，TypeScript会自动为可选参数添加undefined类型。

### 5.12.3 默认参数类型

默认参数值自动第推断类型。

在语法上，同一个函数参数不允许同时声明为可选参数和默认参数。

如果默认参数之后存在必选参数，那么该默认参数不是可选的参数。

### 5.12.4 剩余参数类型

剩余参数的类型应该为数组类型或元组类型。

#### 5.12.4.1 数组类型的剩余参数

#### 5.12.4.2 元组类型的剩余参数

如果剩余参数的类型为元组类型，那么编译器会将剩余参数展开为独立的形式参数声明。

### 5.12.5 解构参数类型

### 5.12.6 返回值类型

在绝大多数情况下，TypeScript能够根据函数体内的return语句等自动推断出返回值类型。

### 5.12.7 函数类型字面量

函数类型字面量是定义函数类型的方法之一。

`(ParameterList) => Type`

函数类型字面量中的形式参数名与实际函数值中的形式参数名不必相同。

函数类型字面量中的返回值类型必须明确指定，不允许省略。

### 5.12.8 调用签名

若在对象类型中定义了调用签名类型成员，那么我们称该对象类型为函数类型。

函数类型字面量的优点是简洁，而对象类型字面量的优点是具有更强的类型表达能力。

### 5.12.9 构造函数类型字面量

构造函数类型字面量是定义构造函数类型的方法之一。

`new (ParameterList) => Type`

### 5.12.10 构造签名

### 5.12.11 调用签名与构造签名

若在对象类型中同时定义调用签名和构造签名，则能够表示既可以被直接调用，又可以作为构造函数使用的函数类型。

### 5.12.12 重载函数

重载函数的定义由以下两部分组成：

- 一条或多条函数重载语句。
- 一条函数实现语句。

#### 5.12.12.1 函数重载

不带有函数体的函数声明语句叫作函数重载。

在各个函数重载语句之间以及函数重载语句与函数实现语句之间不允许出现任何其他语句。

#### 5.12.12.2 函数实现

函数实现中的函数签名不属于重载函数的调用签名之一，只有函数重载中的函数签名能够作为重载函数的调用签名。

函数实现需要兼容每个函数重载的函数签名，函数实现的函数签名类型必须能够赋值给函数重载的函数签名类型。

在TypeScript中，重载函数只存在一个函数实现，开发者需要在这个唯一的函数实现中实现所有函数重载的功能。

#### 5.12.12.3 函数重载解析顺序

候选函数重载列表中的成员将以函数重载的声明顺序作为初始顺序，然后进行简单的排序，将参数类型中包含字面量类型的函数重载排名提前。

要求开发者在编写函数重载代码时一定要将最精确的函数重载定义放在最前面。

#### 5.12.12.4 重载函数的类型

重载函数的类型可以通过包含多个调用前面的对象类型来表示。

在定义重载函数的类型时，有一下两点需要注意：

1. 函数实现的函数签名不属于重载函数的调用前面之一
2. 调用前面的书写顺序是有意义的，它决定了函数从在的解析顺序，一定要确保更精确的调用签名位于更靠前的位置。

### 5.12.13 函数中this值的类型

在默认情况下，编译器会将函数中的this值设置为any类型。

#### 5.12.13.1 --noImplicitThis

启用了该编译选线时，如果this值默认获得了any类型，那么将产生表一错误。

#### 5.12.13.2 函数的this参数

TypeScript支持在函数形式参数列表中定义一个特殊的this参数来描述该函数中this值的类型。

this参数固定使用this作为参数名。this参数是一个可选的参数，若存在，则必须作为函数形式参数列表中的第一个参数。

如果我们想要定义一个纯函数或者是不想让函数代码依赖于this的值，那么在这种情况下可以明确地将this参数定义为void类型。

## 5.13 接口

接口类型也能够表示任意的对象类型。

接口类型能够给对象类型命名以及定义类型参数。

接口声明值存在于编译阶段。

### 5.13.1 接口声明

按照惯例，接口名的首字母需要大写。

从语法的角度来看，接口声明就是在对象类型字面量之前添加了interface关键字和接口名。

接口类型的类型成员也分为以下五类：

- 属性签名
- 调用签名
- 构造签名
- 方法签名
- 索引签名

### 5.13.2 属性签名

`PropertyName: Type;`

### 5.13.3 调用签名

调用签名定义了该对象类型表示的函数在调用时的类型参数、参数列表以及返回值类型。

`(ParameterList): Type`

### 5.13.4 构造签名

`new (ParameterList): Type`

### 5.13.5 方法签名

方法签名是声明函数类型的属性成员的简写。

`PropertyName(ParameterList): Type`

从语法的角度来看，方法签名是在调用签名之前添加一个属性名作为方法名。

方法签名可以改写为具有同等效果但语法稍显复杂的属性签名。

方法签名中的属性名可以为可计算属性名。

在接口中包含多个名字相同但参数列表不同的方法签名成员，则表示该方法是重载方法。

### 5.13.6 索引签名

接口中的索引签名能够描述使用索引访问的对象属性的类型。

- 字符串索引签名
- 数值索引签名

#### 5.13.6.1 字符串索引签名

`[IndexName: string]: Type`

索引名值起到占位的作用，它不代表真实的对象属性名。

一个接口总最多只能定义一个字符串索引签名。字符串索引签名会约束该对象类型中所有属性的类型。

#### 5.13.6.2 数值索引签名

`[IndexName: number]: Type`

索引名值起到占位的作用，它不代表真实的对象属性名。

一个接口总最多只能定义一个数值索引签名。

若接口中同时存在字符串索引签名和数值索引签名，那么数值索引签名的类型必须能够赋值个字符串索引签名的类型。

虽然JavaScript也允许使用数字等其他值作为对象的索引，但最终他们都会别转换为字符串类型。

### 5.13.7 可选属性与方法

我们可以在属性名或方法名后添加一个问号“？”，从而将该属性或方法定义为可选的。

如果接口中定义了重载方法，那么所有重载方法签名必须同时为必选的或者可选的。

### 5.13.8 只读属性与方法

readonly修饰符只允许在属性签名和索引签名中使用。

### 5.13.9 接口的继承

接口可以继承其他的对象类型，这相当于将继承的对象类型中的类型成员赋值到当前接口中。接口可以继承的对象类型如下：

- 接口
- 对象类型的类型别名
- 类
- 对象类型的交叉类型

子接口中同名类型成员的类型需要能够赋值给父接口中同名类型成员的类型。

如果仅是多个父接口之间存在同名的类型成员，而子接口本身没有该同名类型成员，那么父接口中同名类型成员的类型必须是完全相同的。

## 5.14 类型别名

### 5.14.1 类型别名声明

类型别名声明能够为TypeScript中的任意类型命名。

`type AliasName = Type`

类型别名的首字母通常需要大写。

类型别名引用的类型可以为任意类型。

在类型别名中，也可以引用其他类型别名。

类型别名不会创建一种新的类型，它只是给已有类型命名并直接引用该类型。

在程序中，可能会有一些比较复杂的或者书写起来比较长的类型，这时我们就可以声明一个类型别名来引用该类型。

### 5.14.2 递归的类型别名

目前允许以下场景中使用递归的类型别名：

1. 若类型别名引用的类型为接口类型、对象类型字面量、函数类型字面量和构造函数类型字面量，则运行递归引用类型别名。

