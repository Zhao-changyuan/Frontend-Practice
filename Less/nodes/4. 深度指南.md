## 1. 概述



## 2. 变量

变量为您提供了一种从单个位置控制这些值的方法，从而使您的代码更易于维护。

### 2.1 变量插值

变量除了可以控制CSS规则中的值，也可以用于其他定法，例如选择器名称、属性名称、URL和`@import`语句。

### 2.2 使用变量值引用另一个变量

```less
@primary: green;
@secondary: blue;

.section {
  @color: primary;

  .element {
    color: @@color;
  }
}
```

编译输出为：

```css
.section .element {
  color: green;
}
```

### 2.3 懒加载

变量在使用前不必声明。（也就是说可以在声明前使用，同一作用域范围内以最后一个为准）

本质上，一个变量在每个范围都有一个”最终“值。

Less变量的行为与CSS非常相似。

### 2.4 属性作为变量

您可以使用`$prop`语法轻松将属性视为变量。有时这可以使您的代码更轻一些。

```less
.widget {
  padding: 20px;
  color: #efefef;
  border: 5px solid $color;
}
```

请注意，与变量一样，Less 会选择当前/父范围内的最后一个属性作为”最终“值。

### 2.5 默认变量

我们有时会收到对默认变量的请求——只有在变量尚未设置时才设置变量的能力。

## 3. 父选择器

使用`&` 引用父选择器

父选择器 有多种用途。一个典型的用法时使用`&`生成重复的类名。

```less
.button {
  &-ok {
    background-color: green;
  }

  &-cancel {
    background-color: grey;
  }

  &-custom {
    background-color: skyblue;
  }
}
```

### 3.1 多个`&`

`&`可能在一个选择器中出现多次。这使得重复引用父选择器而不重复其名称成为可能。

请注意，`&`代表所有的父选择器（不仅仅时最近的祖先）.

### 3.2 更改选择器属性

在继承的（父）选择器之前添加一个选择器会很有用。可以将`&`放置在当前选择器之后来完成。

### 3.3 组合爆炸

`&` 也可以用于在逗号分隔列表中生成选择器的所有可能排列。

## 4. 继承

:extend时一个less伪类，

`:extend`选择器将所述”延伸选择器“（申请`nav ul`）到`.inline`类的任何出现的地方。生命块将保持原样，但没有对扩展的任何引用。

```less
nav ul {
  &:extend(.inline);
  background-color: blue;
}

.inline {
  color: red;
}
```

输出为：

```css
nav ul {
  background-color: blue;
}
.inline,
nav ul {
  color: red;
}
```

### 4.1 扩展语法

后面可选跟关键字`all`

```less
.a:extend(.b all) {}

.b {
  color: red;
}

.b.c {
  margin: 0 auto;
}

.x.b {
  padding: 10px;
}
```

输出为：

```css
.b,
.a {
  color: red;
}
.b.c,
.a.c {
  margin: 0 auto;
}
.x.b,
.x.a {
  padding: 10px;
}
```

它可以包含一个或多个要扩展的类，用逗号分隔。

### 4.2 扩展附加到选择器

附加到选择器的扩展看起来像一个普通的伪类，以选择器作为参数。一个选择器可以包含多个扩展子句，但所有扩展都必须位于选择器的末尾。

- 在选择器之后扩展：`.pre:hover:extend(div pre)`
- 选择器和扩展之间运行由空格：`pre:hover :extend(div pre)`
- 允许多个扩展：`pre:hover:extend(div pre):extend(.bucket tr)`，注意这和`pre:hover:extend(div pre, .bucket tr)`相同

如果一个规则其包含多个选择器，它们中的任何一个都可以有extend关键字。

### 4.3 扩展内部规则集

可以使用`&:extend(selector)`语法将扩展放入规则集的主题中。将扩展放入主体是将其放入该规则集的每个选择器的快捷方式。

```less
pre:hover,
.some-class {
  &:extend(div pre);
  background-color: #fff;
}

div pre {
  color: red;
}
```

输出为：

```css
pre:hover,
.some-class {
  background-color: #fff;
}
div pre,
pre:hover,
.some-class {
  color: red;
}
```



### 4.4 扩展嵌套选择器

extend能够匹配嵌套的选择器.

```less
.bucket {
  tr {
    color: blue;
  }
}

.some-class:extend(.bucket tr) {}
```

输出为：

```CSS
.bucket tr,
.some-class {
  color: blue;
}
```

本质上，extend扩展内的选择器查看的是编译后的css，而不是原始的less。

例如：

```less
.bucket {
  tr & {
    color: blue;
  }
}
.some-class:extend(tr .bucket) {}
```

输出为：

```CSS
tr .bucket,
.some-class {
  color: blue;
}
```

### 4.5 与扩展精确匹配

默认情况下扩展查找选择器之间的完全匹配。选择器是否使用前导星并不重要。两个第n个表达式具有相同的含义并不重要，它们需要具有相同的形式才能匹配。

主角很重要。选择器`*.class`和`.class`是等价的，但扩展不会匹配它们。

伪类的顺序很重要。选择器`link:hover:visited`和`link:visited:hover`匹配相同的元素集，但扩展将他们视为不同。

```less
:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}
```

输出为：

```css
:nth-child(1n+3) {
  color: blue;
}
```

属性选择器中的单引号双引号无关紧要。

### 4.6 扩展全部

当您在扩展参数中最后指定all关键字时，它会告诉less将该选择器作为另一个选择器的一部分进行匹配。选择器将被复制，然后选择器的匹配部分将被扩展替换，从而形成一个新的选择器。

```less
.a.b.test,
.test.c {
  color: orange;
}
.test {
  &:hover {
    color: green;
  }
}
.replacement:extend(.test all) {}
```

输出为：

```css
.a.b.test,
.test.c,
.a.b.replacement,
.replacement.c {
  color: orange;
}
.test:hover,
.replacement:hover {
  color: green;
}

```

您可以将这种操作模式视为本质上进行非破坏性搜索和替换。

### 4.7 带有扩展的选择器插值【此处官网有错误】

扩展时不能够与变量匹配的。如果选择器包含变量，扩展将忽略它。

### 4.8 范围/扩展内部@media

目前，`@media`内部声明的`:extend`只会匹配同一媒体声明中的选择器。

注意：扩展不匹配嵌套`@media`声明中的选择器。

顶级扩展匹配包括嵌套媒体内的选择器在内的所有内容。

```less
@media screen {
  .selector {
    color: blue;
  }

  @media (min-width: 1023px) {
    .selector {
      color: blue;
    }
  }
}
.topLevel:extend(.selector) {}
```

输出为：

```css
@media screen {
  .selector,
  .topLevel {
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel {
    color: blue;
  }
}
```

### 4.9 没有重复检测

目前没有重复检测

### 4.10 扩展用例

#### 4.10.1 经典用例

避免添加基类，覆盖某一CSS样式。

```less
.animal {
  background-color: black;
  color: white;
}

.bear {
  &:extend(.animal);
  background-color: brown;
}
```

HTML为：

```HTML
<a class="bear">Bear</a>
```

输入为：

```CSS
.animal,
.bear {
  background-color: black;
  color: white;
}
.bear {
  background-color: brown;
}
```

#### 4.10.2 减少CSS大小

Mixins将所有属性赋值到选择器中，这可能会导致不必要的重复。因此，您可以使用extends而不是mixins将选择器向上移动到您希望使用的属性，从而减少生成的CSS。

#### 4.10.3 组合样式/更高级的Mixin

mixin 只能与简单的选择器一起使用，如果您由两个不同html块，但需要对两者应用相同的样式，您可以使用扩展来关联两个区域。

```less
li.list > a {
  color: red;
}
button.list-style {
  &:extend(li.list > a);
}
```

输出为：

```css
li.list > a,
button.list-style {
  color: red;
}
```

## 5. 合并 (Merge)

该功能运行将多个属性的值聚合到单个属性下的都好或空格分隔列表中。merge对背景和变化等属性很有用。

### 5.1 逗号

```less
.mixin() {
  box-shadow+: insert 0 0 10px #555;
}
.myclass {
  .mixin();
  box-shadow+: 0 0 20px black;
}
```

输出为：

```CSS
.myclass {
  box-shadow: insert 0 0 10px #555, 0 0 20px black;
}
```

### 5.2 空格

```less
.mixin {
  transform+_: scale(2);
}
.myclass {
  .mixin();
  transform+_: rotate(15deg);
}
```

输出为：

```css
.mixin {
  transform: scale(2);
}
.myclass {
  transform: scale(2) rotate(15deg);
}
```

为避免任何无意义的链接`merge`需要在每个链接改期声明上显式`+`或 `+_`标志。

## 6. 混合

您可以使用类选择器和id选择器混合。

```less
.a, #b {
  color: red;
}

.mixin-class {
  .a();
}

.mixin-id {
  #b();
}
```

输出为：

```css
.a,
#b {
  color: red;
}
.mixin-class {
  color: red;
}
.mixin-id {
  color: red;
}
```

虽然括号是可选的，但推荐使用括号。

### 6.1 带括号的混合

如果您向创建一个mixin但不希望该mixin出现在您的CSS输入出中，请在mixin定义之后加上括号。

### 6.2 Mixin中的选择器

Mixin不仅可以包含属性，还可以包含选择器。

### 6.3 命名空间

如果你向在更复杂的选择器中混合属性，你可以堆叠多个id或类。

```less
#outer() {
  .inner {
    color: red;
  }
}

.c {
  #outer.inner();
}
```

输出为：

```css
.c {
  color: red;
}
```

向这样命名你的mixin可以减少与卡库mixin或用户mixin的冲突，但也可以作为一种”组织“mixin组的方式。

### 6.4 受保护的命名空间

如果命名空间具有保护，则仅当保护条件返回true时才使用由它定义的mixin。

`default`假定该函数对于所有嵌套的命名空间和mixin具有相同的值。

### 6.5 `!important`关键字

`!important`在mixin调用之后使用关键字将其继承的所有属性标记为`!important`

```less
.foo (@bg: #f5f5f5; @color: #900) {
  background-color: @bg;
  color: @color;
}

.unimportant {
  .foo();
}

.important {
  .foo() !important;
}
```

输出为：

```css
.unimportant {
  background-color: #f5f5f5;
  color: #900;
}
.important {
  background-color: #f5f5f5 !important;
  color: #900 !important;
}
```

### 6.6 参数化混合

Mixins也可以接受参数，这些参数实在混合时传递给选择器块的变量。

参数混合也可以为其参数设置默认值。

您还可以使用不带参数的参数混合。

#### 6.6.1 参数分隔符

参数当前以分号或逗号分隔，最初，参数仅用逗号分隔，但后台添加了分号支持将逗号分隔的列表值传递给单个参数。从less 4.0开始，您可以使用括号转义符[`~()`]来包装列表值，例如`.name(@param1: ~(red, blue))`。

#### 6.6.2 重载mixin

定义多个具有相同名称和参数数量的mixin时合法的。Less将使用所有可以应用的属性。如果你使用带有一个参数的mixin，例如`.mixin(green)`，那么所有带有一个强制参数的mixin的属性都将被使用。

#### 6.6.3 命名参数

mixin引用可以按名称提供参数值，而不仅仅是位置。任何参数都可以通过其名称引用。并且它们不必按任何特殊顺序排列。

#### 6.6.4 `@arguments`变量

`@arguments`在mixin中具有特殊含义，它包含调用mixin时传递的所有参数。如果您不要处理单个参数，这很有用。

```less
.box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {
  -webkit-box-shadow: @arguments;
  -moz-box-shadow: @arguments;
  box-shadow: @arguments;
}

.big-block {
  .box-shadow(2px, 4px)
}
```

输出为：

```css
.big-block {
  -webkit-box-shadow: 2px 4px 1px #000;
  -moz-box-shadow: 2px 4px 1px #000;
  box-shadow: 2px 4px 1px #000;
}
```

#### 6.4.5 高级参数和@rest变量

果果你希望mixin采用可变数量的参数，则可以使用`...`

### 6.5 模式匹配

有时，您可能希望根据传递给它的参数来更改mixin的行为。

只使用匹配的mixin定义。变量匹配并绑定到任何值。出列变量之外的任何东西都值等于它自己的值匹配。

### 6.6 使用Mixin作为函数

从Mixin调用中选择属性和变量。

#### 6.6.1 属性/值访问器

从less3.5开始，您可以使用属性/变量访问其从mixin规则中选择一个值。

```less
.average(@x, @y) {
  @result: ((@x + @y) / 2);
}

div {
  padding: .average(16px, 50px)[@result];
}
```

输出为：

```css
div {
  padding: 33px;
}
```

#### 6.6.2 覆盖混合值

如果您由多个匹配的mixin，则会合并所有规则，并返回具有该标识符的最后一个匹配值。

#### 6.6.3 未命名查找

如果您没有在`[@lookup]`中指定查找值，则所有值都将级联并选择最后一个声明的值。

### 6.7 递归混合

在 less中，mixin可以调用自身。

### 6.8 混合守卫

当您想匹配表达式而不是简单的值或元数时，首位很有用。

为了尽可能接近CSS的声明性，Less选择通过受保护的mixin而不是`if/else`语句来实现条件执行，以符合`@media`查询功能规范。

#### 6.8.1 保护比较运算符

守卫中可用的比较运算符的完整泪飙时`>`  `>=`  `=`  `=<` `<`，关键字`true`是唯一的真值。一下两个mixin等效：

```less
.truth(@a) when (@a) {}
.truth(@a) when (@a = true) {}
```

除了关键字true之外的任何值都是假的。

请注意，你还可以相互比较参数，或与非参数进行比较

#### 6.8.2 保护逻辑运算符

使用`and`关键字来组合守卫

您还可以逗号分隔首位来模拟or运算符。

使用`not`关键字否定条件

#### 6.8.3 类型检查功能

如果要根据值类型匹配mixin，可以使用以下`is`函数：

- iscolor
- isnumber
- isstring
- iskeyword
- isurl

检查单位：

- ispixel
- ispercentage
- isem
- isunit

### 6.9 别名混入

#### 6.9.1 将mixin 调用分配给变量

Mixin可以分配给一个变量作为变量来调用，可以用于映射查找。

#### 6.9.2 变量调用

整个mixin调用都可以别名并称为变量调用。

与root中使用的Mixin不同，分配给变量的mixin调用和不带参数的调用总是需要括号。

