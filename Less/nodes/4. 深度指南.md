## 1. 概述



## 2. 变量

变量为您提供了一种从单个位置控制这些值的方法，从而使您的代码更易于维护。

### 2.1 变量插值

变量除了可以控制CSS规则中的值，也可以用于其他定法，例如选择器名称、属性名称、URL和`@import`语句。

### 2.2 使用变量值引用另一个变量

一个变量的值可以作为另一个变量变量名再次引用。

```less
@primary: green;
@secondary: blue;

.section {
  @color: primary;

  .element {
    color: @@color;
  }
}
```

编译输出为：

```css
.section .element {
  color: green;
}
```

### 2.3 懒加载

变量在使用前不必声明。（也就是说可以在声明前使用，同一作用域范围内以最后一个为准）

本质上，一个变量在每个范围都有一个”最终“值。

Less变量的行为与CSS非常相似。

### 2.4 属性作为变量

您可以使用`$prop`语法轻松将属性视为变量。有时这可以使您的代码更轻一些。

```less
.widget {
  padding: 20px;
  color: #efefef;
  border: 5px solid $color;
}
```

请注意，与变量一样，Less 会选择当前/父范围内的最后一个属性作为”最终“值。

### 2.5 默认变量

我们有时会收到对默认变量的请求——只有在变量尚未设置时才设置变量的能力。

## 3. 父选择器

使用`&` 引用父选择器

父选择器 有多种用途。一个典型的用法时使用`&`生成重复的类名。

```less
.button {
  &-ok {
    background-color: green;
  }

  &-cancel {
    background-color: grey;
  }

  &-custom {
    background-color: skyblue;
  }
}
```

### 3.1 多个`&`

`&`可能在一个选择器中出现多次。这使得重复引用父选择器而不重复其名称成为可能。

请注意，`&`代表所有的父选择器（不仅仅时最近的祖先）.

### 3.2 更改选择器属性

在继承的（父）选择器之前添加一个选择器会很有用。可以将`&`放置在当前选择器之后来完成。

### 3.3 组合爆炸

`&` 也可以用于在逗号分隔列表中生成选择器的所有可能排列。

## 4. 继承

:extend时一个less伪类，

`:extend`选择器将所述”延伸选择器“（申请`nav ul`）到`.inline`类的任何出现的地方。生命块将保持原样，但没有对扩展的任何引用。

```less
nav ul {
  &:extend(.inline);
  background-color: blue;
}

.inline {
  color: red;
}
```

输出为：

```css
nav ul {
  background-color: blue;
}
.inline,
nav ul {
  color: red;
}
```

### 4.1 扩展语法

后面可选跟关键字`all`

```less
.a:extend(.b all) {}

.b {
  color: red;
}

.b.c {
  margin: 0 auto;
}

.x.b {
  padding: 10px;
}
```

输出为：

```css
.b,
.a {
  color: red;
}
.b.c,
.a.c {
  margin: 0 auto;
}
.x.b,
.x.a {
  padding: 10px;
}
```

它可以包含一个或多个要扩展的类，用逗号分隔。

### 4.2 扩展附加到选择器

附加到选择器的扩展看起来像一个普通的伪类，以选择器作为参数。一个选择器可以包含多个扩展子句，但所有扩展都必须位于选择器的末尾。

- 在选择器之后扩展：`.pre:hover:extend(div pre)`
- 选择器和扩展之间运行由空格：`pre:hover :extend(div pre)`
- 允许多个扩展：`pre:hover:extend(div pre):extend(.bucket tr)`，注意这和`pre:hover:extend(div pre, .bucket tr)`相同

如果一个规则其包含多个选择器，它们中的任何一个都可以有extend关键字。

### 4.3 扩展内部规则集

可以使用`&:extend(selector)`语法将扩展放入规则集的主题中。将扩展放入主体是将其放入该规则集的每个选择器的快捷方式。

```less
pre:hover,
.some-class {
  &:extend(div pre);
  background-color: #fff;
}

div pre {
  color: red;
}
```

输出为：

```css
pre:hover,
.some-class {
  background-color: #fff;
}
div pre,
pre:hover,
.some-class {
  color: red;
}
```



### 4.4 扩展嵌套选择器

extend能够匹配嵌套的选择器.

```less
.bucket {
  tr {
    color: blue;
  }
}

.some-class:extend(.bucket tr) {}
```

输出为：

```CSS
.bucket tr,
.some-class {
  color: blue;
}
```

本质上，extend扩展内的选择器查看的是编译后的css，而不是原始的less。

例如：

```less
.bucket {
  tr & {
    color: blue;
  }
}
.some-class:extend(tr .bucket) {}
```

输出为：

```CSS
tr .bucket,
.some-class {
  color: blue;
}
```

### 4.5 与扩展精确匹配

默认情况下扩展查找选择器之间的完全匹配。选择器是否使用前导星并不重要。两个第n个表达式具有相同的含义并不重要，它们需要具有相同的形式才能匹配。

主角很重要。选择器`*.class`和`.class`是等价的，但扩展不会匹配它们。

伪类的顺序很重要。选择器`link:hover:visited`和`link:visited:hover`匹配相同的元素集，但扩展将他们视为不同。

```less
:nth-child(1n+3) {
  color: blue;
}
.child:extend(:nth-child(n+3)) {}
```

输出为：

```css
:nth-child(1n+3) {
  color: blue;
}
```

属性选择器中的单引号双引号无关紧要。

### 4.6 扩展全部

当您在扩展参数中最后指定all关键字时，它会告诉less将该选择器作为另一个选择器的一部分进行匹配。选择器将被复制，然后选择器的匹配部分将被扩展替换，从而形成一个新的选择器。

```less
.a.b.test,
.test.c {
  color: orange;
}
.test {
  &:hover {
    color: green;
  }
}
.replacement:extend(.test all) {}
```

输出为：

```css
.a.b.test,
.test.c,
.a.b.replacement,
.replacement.c {
  color: orange;
}
.test:hover,
.replacement:hover {
  color: green;
}

```

您可以将这种操作模式视为本质上进行非破坏性搜索和替换。

### 4.7 带有扩展的选择器插值【此处官网有错误】

扩展时不能够与变量匹配的。如果选择器包含变量，扩展将忽略它。

### 4.8 范围/扩展内部@media

目前，`@media`内部声明的`:extend`只会匹配同一媒体声明中的选择器。

注意：扩展不匹配嵌套`@media`声明中的选择器。

顶级扩展匹配包括嵌套媒体内的选择器在内的所有内容。

```less
@media screen {
  .selector {
    color: blue;
  }

  @media (min-width: 1023px) {
    .selector {
      color: blue;
    }
  }
}
.topLevel:extend(.selector) {}
```

输出为：

```css
@media screen {
  .selector,
  .topLevel {
    color: blue;
  }
}
@media screen and (min-width: 1023px) {
  .selector,
  .topLevel {
    color: blue;
  }
}
```

### 4.9 没有重复检测

目前没有重复检测

### 4.10 扩展用例

#### 4.10.1 经典用例

避免添加基类，覆盖某一CSS样式。

```less
.animal {
  background-color: black;
  color: white;
}

.bear {
  &:extend(.animal);
  background-color: brown;
}
```

HTML为：

```HTML
<a class="bear">Bear</a>
```

输入为：

```CSS
.animal,
.bear {
  background-color: black;
  color: white;
}
.bear {
  background-color: brown;
}
```

#### 4.10.2 减少CSS大小

Mixins将所有属性复制到选择器中，这可能会导致不必要的重复。因此，您可以使用extends而不是mixins将选择器向上移动到您希望使用的属性，从而减少生成的CSS。

#### 4.10.3 组合样式/更高级的Mixin

mixin 只能与简单的选择器一起使用，如果您由两个不同html块，但需要对两者应用相同的样式，您可以使用扩展来关联两个区域。

```less
li.list > a {
  color: red;
}
button.list-style {
  &:extend(li.list > a);
}
```

输出为：

```css
li.list > a,
button.list-style {
  color: red;
}
```

## 5. 合并 (Merge)

该功能运行将多个属性的值聚合到单个属性下的都好或空格分隔列表中。merge对背景和变化等属性很有用。

### 5.1 逗号

```less
.mixin() {
  box-shadow+: insert 0 0 10px #555;
}
.myclass {
  .mixin();
  box-shadow+: 0 0 20px black;
}
```

输出为：

```CSS
.myclass {
  box-shadow: insert 0 0 10px #555, 0 0 20px black;
}
```

### 5.2 空格

```less
.mixin {
  transform+_: scale(2);
}
.myclass {
  .mixin();
  transform+_: rotate(15deg);
}
```

输出为：

```css
.mixin {
  transform: scale(2);
}
.myclass {
  transform: scale(2) rotate(15deg);
}
```

为避免任何无意义的链接`merge`需要在每个链接改期声明上显式`+`或 `+_`标志。

## 6. 混合

您可以使用类选择器和id选择器混合。

```less
.a, #b {
  color: red;
}

.mixin-class {
  .a();
}

.mixin-id {
  #b();
}
```

输出为：

```css
.a,
#b {
  color: red;
}
.mixin-class {
  color: red;
}
.mixin-id {
  color: red;
}
```

虽然括号是可选的，但推荐使用括号。

### 6.1 带括号的混合

如果您向创建一个mixin但不希望该mixin出现在您的CSS输入出中，请在mixin定义之后加上括号。

### 6.2 Mixin中的选择器

Mixin不仅可以包含属性，还可以包含选择器。

### 6.3 命名空间

如果你向在更复杂的选择器中混合属性，你可以堆叠多个id或类。

```less
#outer() {
  .inner {
    color: red;
  }
}

.c {
  #outer.inner();
}
```

输出为：

```css
.c {
  color: red;
}
```

向这样命名你的mixin可以减少与卡库mixin或用户mixin的冲突，但也可以作为一种”组织“mixin组的方式。

### 6.4 受保护的命名空间

如果命名空间具有保护，则仅当保护条件返回true时才使用由它定义的mixin。

`default`假定该函数对于所有嵌套的命名空间和mixin具有相同的值。

### 6.5 `!important`关键字

`!important`在mixin调用之后使用关键字将其继承的所有属性标记为`!important`

```less
.foo (@bg: #f5f5f5; @color: #900) {
  background-color: @bg;
  color: @color;
}

.unimportant {
  .foo();
}

.important {
  .foo() !important;
}
```

输出为：

```css
.unimportant {
  background-color: #f5f5f5;
  color: #900;
}
.important {
  background-color: #f5f5f5 !important;
  color: #900 !important;
}
```

### 6.6 参数化混合

Mixins也可以接受参数，这些参数实在混合时传递给选择器块的变量。

参数混合也可以为其参数设置默认值。

您还可以使用不带参数的参数混合。

#### 6.6.1 参数分隔符

参数当前以分号或逗号分隔，最初，参数仅用逗号分隔，但后台添加了分号支持将逗号分隔的列表值传递给单个参数。从less 4.0开始，您可以使用括号转义符[`~()`]来包装列表值，例如`.name(@param1: ~(red, blue))`。

#### 6.6.2 重载mixin

定义多个具有相同名称和参数数量的mixin时合法的。Less将使用所有可以应用的属性。如果你使用带有一个参数的mixin，例如`.mixin(green)`，那么所有带有一个强制参数的mixin的属性都将被使用。

#### 6.6.3 命名参数

mixin引用可以按名称提供参数值，而不仅仅是位置。任何参数都可以通过其名称引用。并且它们不必按任何特殊顺序排列。

#### 6.6.4 `@arguments`变量

`@arguments`在mixin中具有特殊含义，它包含调用mixin时传递的所有参数。如果您不要处理单个参数，这很有用。

```less
.box-shadow(@x: 0, @y: 0, @blur: 1px, @color: #000) {
  -webkit-box-shadow: @arguments;
  -moz-box-shadow: @arguments;
  box-shadow: @arguments;
}

.big-block {
  .box-shadow(2px, 4px)
}
```

输出为：

```css
.big-block {
  -webkit-box-shadow: 2px 4px 1px #000;
  -moz-box-shadow: 2px 4px 1px #000;
  box-shadow: 2px 4px 1px #000;
}
```

#### 6.4.5 高级参数和@rest变量

果果你希望mixin采用可变数量的参数，则可以使用`...`

### 6.5 模式匹配

有时，您可能希望根据传递给它的参数来更改mixin的行为。

只使用匹配的mixin定义。变量匹配并绑定到任何值。出列变量之外的任何东西都值等于它自己的值匹配。

### 6.6 使用Mixin作为函数

从Mixin调用中选择属性和变量。

#### 6.6.1 属性/值访问器

从less3.5开始，您可以使用属性/变量访问其从mixin规则中选择一个值。

```less
.average(@x, @y) {
  @result: ((@x + @y) / 2);
}

div {
  padding: .average(16px, 50px)[@result];
}
```

输出为：

```css
div {
  padding: 33px;
}
```

#### 6.6.2 覆盖混合值

如果您由多个匹配的mixin，则会合并所有规则，并返回具有该标识符的最后一个匹配值。

#### 6.6.3 未命名查找

如果您没有在`[@lookup]`中指定查找值，则所有值都将级联并选择最后一个声明（变量或属性）的值。

```less
#library() {
  #mixin() {
    @prop: green;
    color: skyblue;
  }
}
#library() {
  #mixin() {
    background-color: white;
    @prop: red;
  }
}

.box {
  color: #library#mixin[];
}
```

输出为：

```css
.box {
  color: red;
}
```

相同的行为适用于规则集的变量调用。

```less
@dr: {
  value: foo;
  background-color: skyblue;
}
.box {
  color: @dr[];
}
```

输出为：

```
.box {
  color: skyblue;
}
```



### 6.7 递归混合

在 less中，mixin可以调用自身。

```less
.loop(@counter) when (@counter > 0) {
  .loop((@counter - 1));

  & .primary-@{counter} {
    padding: 20px + @counter;
  }
}

div {
  .loop(4);
}
```

输出为：

```css
div .primary-1 {
  padding: 21px;
}
div .primary-2 {
  padding: 22px;
}
div .primary-3 {
  padding: 23px;
}
div .primary-4 {
  padding: 24px;
}
```



### 6.8 混合守卫

当您想匹配表达式而不是简单的值或元数时，守卫很有用。

为了尽可能接近CSS的声明性，Less选择通过受保护的mixin而不是`if/else`语句来实现条件执行，以符合`@media`查询功能规范。

#### 6.8.1 守卫比较运算符

守卫中可用的比较运算符的完整列表是：`>`  `>=`  `=`  `=<` `<`，关键字`true`是唯一的真值。一下两个mixin等效：

```less
.truth(@a) when (@a) {}
.truth(@a) when (@a = true) {}
```

除了关键字true之外的任何值都是假的。

请注意，你还可以相互比较参数，或与非参数进行比较

#### 6.8.2 守卫逻辑运算符

使用`and`关键字来组合守卫

您还可以逗号分隔首位来模拟or运算符。

使用`not`关键字否定条件

#### 6.8.3 类型检查功能

如果要根据值类型匹配mixin，可以使用以下`is`函数：

- iscolor
- isnumber
- isstring
- iskeyword
- isurl

检查单位：

- ispixel
- ispercentage
- isem
- isunit

### 6.9 别名混入

#### 6.9.1 将mixin 调用分配给变量

Mixin可以赋值给一个变量作为变量来调用，可以用于映射查找。

```less
#theme.dark.navbar {
  .colors(light) {
    primary: purple;
  }
  .colors(dark) {
    primary: black;
    secondary: grey;
  }
}
.navbar {
  @colors: #theme.dark.navbar.colors(dark);
  background: @colors[primary];
  border: 1px solid @colors[secondary];
}
```

输出为：

```CSS
.navbar {
  background: black;
  border: 1px solid grey;
}
```



#### 6.9.2 变量调用

整个mixin调用都可以别名并称为变量调用。

与root中使用的Mixin不同，分配给变量的mixin调用和不带参数的调用总是需要括号。

这是因为如果变量被分类了一个选择器列表或一个mixin调用，他是不明确的。

```less
#library() {
  .colors() {
    background: green;
  }
}
.box {
  @alias: #library.colors();
  @alias();
}
```

输出为：

```css
.box {
  background: green;
}
```



## 7. CSS 守卫

像Mixin 守卫一样，守卫也可以应用与CSS选择器，这是一种语法糖，用于声明mixin然后立即调用它。

您还可以通过与`&`功能结合来实现类型声明，从而运行您对多个守卫进行分组。

```less
@my-option: true;

& when(@my-option) {
  button {
    color: white;
  }
  a {
    color: blue;
  }
}
```

输出为：

```css
button {
  color: white;
}
a {
  color: blue;
}
```

## 8. 分离的规则

分离的规则集时一组CSS属性、嵌套的规则集、媒体声明或存储在变量中的任何其他内容。你可以将其包含到规则集或其他结构中，并且器所有属性都将被复制到那里。您还可以将其用作mixin参数并将其作为任何其他变量传递。

分离规则集调用后的括号是强制性的。

当你想定义一个mixin来抽象出在媒体查询中包装一段代码或不受支持的浏览器类名称时，它很有用。可以将规则传递给mixin，以便mixin可以包装内容。

```less
.desktop-and-old-ie(@rules) {
  @media screen and (min-width: 1200px) { @rules(); }

  html.lt-ie9 & { @rules(); }
}

header {
  background-color: blue;

  .desktop-and-old-ie({
    background-color: red;
  });
}
```

输出为：

```CSS
header {
  background-color: blue;
}
@media screen and (min-width: 1200px) {
  header {
    background-color: red;
  }
}
html.lt-ie9 header {
  background-color: red;
}
```



规则集现在可以分配给一个变量或传递给一个 mixin，并且可以包含完整的Less功能集。

一个分离的规则集调用将它的所有mixin解锁（返回）到调用者中，就像mixin调用一样。但是，它并没有返回变量。

规则集中变量时私有变量。

### 8.1 范围界定

分离的规则集可以使用在声明它和调用它的作用域可访问的所有变量和混合。换句话说，定义和调用者作用域对它是可见的。如果两个作用域都包含相同的变量或mixin，则声明作用域优先。

声明作用域是分离的规则集被定义的地方。

#### 8.1.1 定义和调用者范围可见性

分离的规则集会看到调用者的变量和混合。

#### 8.1.2 引用不会修改分离的规则集范围

规则集不能仅通过在哪里引用来访问新范围。

#### 8.1.3 解锁将修改分离规则集范围

不推荐调用解锁，使用`8.2 属性/变量访问器`

### 8.2 属性/变量访问器

从Less 3.5开始，您可以使用属性/变量访问器（也成为”查找“）从变量（分离的）规则集中选择一个值。

如果查找返回的是另一个分离的规则集，你可以使用第二个查找来获取该值。

#### 8.2.1 查找中的变量

返回的查找值本省可以是可变的。

## 9. @import 规则

从其他样式表导入样式，

在标准CSS中，`@import` at规则必须在所有其他类型的规则之前。但是Less并不关心把`@import`语句放在哪里。

### 9.2 文件扩展名

不同的处理方式：

- 如果有是.css文件，他将被视为CSS并且`@import`语句爆出原样。
- 如果它有任何其他扩展名，它将被视为less并导入；
- 如果他没有扩展名，`.less`将被附件，并作为导入的less文件包含在内。

### 9.3 导入选项

less 为CSS的`@import` at-rule提供了几个扩展，以提供更大的灵活性，让你可以对外部文件执行操作。

语法：`@import (keyword) "filename";`

keyword有如下选项：

- `reference`：使用Less文件但不输出它；
- `inline`： 在输出文件中包含源文件但不处理它；
- `less`： 无论文件扩展名是什么，都将文件视为less文件
- `css`： 无论文件扩展名是什么，都将文件视为css文件
- `once`：只包含文件一次（这是默认行为）
- `multiple`：多次包含文件
- `optional`：找不到文件时继续编译

可包含多个关键字，使用用逗号分隔。

### 9.4 reference

使用`@import (reference)`导入外部文件只是不添加导入样式表以后的输出，除非引用。

`reference`样式不会显示在您生成的CSS中，除非参考样式用作`mixinx`或`extend`

`reference`根据使用的方法（混合或扩展）产生不同的结果：

- `extend`：当一个选择器被扩展时，之后新的选择器被标记为未引用，并在引用`@import`语句的位置被拉入。
- `mixins`：当一个`reference`样式用作隐式mixin时，它的规则时混合的，标记为”不引用“，并正常出现在引用的地方。

### 9.5 inline

不能对其进行处理。

当CSS文件不能兼容时，您将使用它。

### 9.6 less

### 9.7 css

### 9.8 once

该文件的后续导入语句将被忽略。

### 9.9 multiple

多次导入

### 9.10 optional

文件存在时才运行导入，可避免报错。

## 10. @plugin规则

导入JavaScript插件为Less.js提供函数或新功能。

## 11. Maps

使用规则集和混合作为值的映射。

通过将命名空间与`[]`语法相结合，你可以将规则集/mixin转换为映射。

由于命名空间和重载mixin的能力,mixin比map更通用一些。

您还可以通过别名mixins更容易一些。
