## 深入响应性原理

我们可以跟踪的是对象 property 的变化。

最佳实践：永远不要持有对原始对象的引用，而只使用响应式版本。

一个组件的模板被编译成一个 `render` 函数。

## 响应性基础

当从组件中的 `data()` 返回一个对象时，它在内部交由 `reactive()` 使其成为响应式对象。

当 `ref` 作为响应式对象的 property 被访问或更改时，为使其行为类似于普通 property ，它会自动解包内部值。

###  ref

- 作用：定义一个数据的响应式
- 语法：`const xxx = ref(initValue);`
  - 创建一个包含响应式数据的引用 （reference）对象
  - js中操作数据： `xxx.value`
  - 模板中操作数据：不需要.value
- 一般用来定义一个基本类型的响应式数据
- 使用ref处理对象，对象会被自动reactive为proxy对象

### reactive

- 作用：定义多个数据的响应式
- `const proxy = reactive(obj);` 接收一个普通对象然后返回该普通对象的响应式代理器对象

### watchEffect函数

- 不用直接指定要要监视的数据，回调函数中使用的哪些响应式数据就监视哪些响应式数据
- 默认初始时就会执行一次，从而可以手机需要监视的数据
- 监视数据发生变化时回调

### shallowReactive 与 shallowRef

- shallowReactive: 只处理了对象内最外层属性的响应式（也就是浅响应式）
- shallowRef：只处理了value的响应式，不进行对象的reactive处理
- 什么时候使用？
  - 一般情况下使用 ref 和 reactive 即可
  - 如果有一个对象数据，结构比较深，但变化时只是外层属性变化 ===> shallowReactive
  - 如果有一个对象数据，后面会产生新的对象来替换 ===> shallowRef



