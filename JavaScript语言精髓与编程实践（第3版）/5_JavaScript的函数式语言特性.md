### 5.1 概述

通常来讲，函数式语言被认为是基于“数学函数”的一种语言。当用数学领域中的抽象概念来解释函数语言时，问题通常会被聚焦为下面两个描述：

- 数学函数是集合A（称为定义域）中成员到集合B（称为值域）中成员的映射。
- 函数式程序设计就是对函数定义、函数应用加以说明，其运算过程即是对函数应用求值。

#### 5.1.1 从代码风格说起

语言风格的好坏并非判断“连续运算（或某种语言）”价值的重要依据。

#### 5.1.2 为什么常见的语言不赞同连续求值

“不支持连续运算”这种编程系统（和代码风格）其实是为了更加复合冯·诺依曼计算体系的设计。

#### 5.1.3 函数语言的渊源

从函数式语言的鼻祖——LISP开始，函数式语言就是运行在解释环境而非编译环境中的。而究其根源，还是在于冯诺依曼体系的计算机系统是基于存储于指令系统的，而并不是基于（类似Lambda演算的）连续运算的。

### 5.2 从运算式语言到函数式语言

连续运算式函数式语言的基本语言特征之一。其基本运算模型就是：

- 运算（表达式）以产生结果。
- 结果（值）用于更进一步的运算。

#### 5.2.1 JavaScript中的几种连续运算

##### 5.2.1.1 连续赋值

`a = b = c = 100;`

##### 5.2.1.2 三元表达式的连用

三元表达式是推荐连用的，这样能够充分发挥连续运算的特性。

“运算”产生值，“值”产于运算——这个逻辑是三元表达式能够连续运算的关键。

##### 5.2.1.3 连续逻辑运算

##### 5.2.1.4 逗号运算符与连续运算

箭头函数也是一个使用连续运算的好地方。

##### 5.2.1.5 解构赋值

赋值模板的嵌套问题。

##### 5.2.1.6 函数与方法的调用

一项JavaScript特性：对象的构造、函数与方法的调用等，本质上都是表达式运算而非语句。

函数调用在本质上是一个表达式。

#### 5.2.2 如何消灭语句

##### 5.2.2.1 通过表达式消灭分支语句

单个分支的if条件可以被转换成布尔表达式。

switch语句与if语句连用等效。而后者可以被第三元表达式连用替代。

##### 5.2.2.2 通过函数递归消灭循环语句

循环语句可以通过函数递归来模拟。

循环句的一个良好特性就是开销很小，而在函数的递归调用过程中，由于需要为每次函数调用保留私有数据和上下文环境，因此将消耗大量的栈空间。这样一来，用函数模拟循环就必然存在一个问题：栈溢出。

但是递归中也可以存在不占用栈的情况，这就是**尾递归**。

##### 5.2.2.3 其他可以被消灭的语句

#### 5.2.3 运算式语言

它满足说明式语言的两个特性：一是陈述运算，二是求值。

##### 5.2.3.1 运算的实质是值运算

运算的目的就是“产生值”。

- 系统的结果必然是值，并且可以通过一系列的运算来得到这一结果。

##### 5.2.3.2 运算式语言的应用

#### 5.2.4 重新认识函数

##### 5.2.4.1 函数是对运算式语言的补充

在一个纯粹的、完备的运算式语言中，函数是一个必要的补充。

##### 5.2.4.2 函数是代码的组织形式

在运算式语言中，函数不但是消减循环等语句的一个必要补充，也是一种消减代码复杂性的组织形式。

##### 5.2.4.3 当运算符等义与某个函数时

#### 5.2.5 函数式语言

函数式语言中的“函数（function）”除了能被调用之外，还具有其他三个方法的性质：是操作数、可保存数据，以及无副作用。

##### 5.2.5.1 "函数" === "Lambda"

##### 5.2.5.2 函数是操作数

当JavaScript中的函数作为参数时，也是传递引用的，但并没有地址概念。由于彻底杜绝了地址运算。由于参数是“函数调用”运算的操作数，因此当函数也是参数时他就只有操作数的含义了（而不再有地址含义），与普通参数并没有什么特别不同。

##### 5.2.5.3 在函数内保存数据

在JavaScript的函数中，函数内的私有变量可以被修改，而且当再次“进入”该函数内部时，这个被修改的状态仍将持续。

在函数内保持数据的特性被称为“闭包（Closure）”。闭包是函数执行时的现场，以及在执行后可观察、可重入的历史。

##### 5.2.5.4 函数内的运算对函数外无副作用

所谓运算对函数外无副作用，其含义在于：

- 函数使用入口参数进行运算，而不修改它（作为值参数而不是变量参数使用）。
- 在运算过程中中不会修改函数外部的其他数据的值（例如全局变量）。
- 运算结束后通过函数返回项外部系统的传值。

需要开发人员的习惯来实现这一特性。

##### 5.2.5.5 函数式的特性集

### 5.3 JavaScript中的函数

在JavaScript中使用函数式风格编程，应优先使用表达式连续运算来组织代码。

#### 5.3.1 参数

在JavaScript中，函数参数值只支持一种调用约定。它的特点表现为：

- 传入参数是从左至右求值的。
- 传入参数的值（或其引用）在函数内的重写是无副作用的。
- 传入参数的格式相对于函数声明时的形式参数是可变的。

##### 5.3.1.1 可变参数

JavaScript并不检查函数声明与函数调用时的参数类型、个数的关系。

##### 5.3.1.2 默认参数

一旦该参数不传入或者传入undefined，那么该参数在函数内将使用默认值。

尽管所有的默认参数都是有名字的形式参数，但是从第一个默认参数开始，后续的所有参数都不会再计入形式参数计数（也就是不会反映在aFunction.length属性中）。

##### 5.3.1.3 剩余参数

同默认参数一样，剩余参数也不计入形式参数计数。

##### 5.3.1.4 模板参数

模板参数用于“多个标识符对应一个传入参数”的情况。

模板参数是计入形式参数计数的。

##### 5.3.1.5 参数对象

arguments是函数内部的代码可以访问的一个变量。

这里有两条规则：

- 默认情况下，形式参数与arguments中的传入值是绑定的，所以向该参数写值，会影响到arguments中的成员，反之亦然。
- 除了直接使用arguments[x]，其他方式得到的arguments成员都不会有上述（与形式参数绑定）效果。

最后并不存在一个所谓的Arguments类。

##### 5.3.1.6 非简单参数

默认参数、剩余参数和模板参数被统称为“非简单参数”。当参数声明中使用了非简单参数时，会导致函数进入一种特殊模式。在该模式下会有三种限制：

- 函数无法通过显式地使用“use strict”语言切换到严格模式，但能接受它被包含在一个严格模式的语法块中（从而隐式地切换到严格模式）。
- 无论是否在严格模式中，函数参数声明都将不接受“重名参数”。
- 无论是否在严格模式中，形式参数与arguments之间都将解除绑定关系。

当使用非简单参数时，通过arguments获得的参数时不被赋予初值的，因此它可能会与通过参数名得到的值不一样。

arguments只是严格地反映了传入参数，而不受默认参数的影响。

##### 5.3.1.7 非惰性求值

JavaScript使用“非惰性求值”的很大一部分原因，在于它还支持赋值表达式，这也就意味着表达还是会产生副作用。

##### 5.3.1.8 传值参数

“引用求值过程”是指一个引用同时包括“值和引用的含义”。

#### 5.3.2 函数

##### 5.3.2.1 一般函数

在表达式中可以直接使用（通过声明语法来得到的）具名函数的字面量，这种情况下它的标识符仍然在函数内有效，但对函数表达式之外的作用域无效。

匿名函数不会在作用域中创建标识符，也因此它不能作为语句（而只能作为表达式操作数）。

在JavaScript的规范中，所有的函数都可以有一个名字，即aFunction.name属性。这个名字是不可靠的，它可以改变，可以删除，也可以与已具有的名字不同。

所有具名函数与匿名函数的差异也仅仅体现在这两个方面：1.是否有一个可影响当前作用域的标识符；2.是否可以用作声明语句。

##### 5.3.2.2 生成器函数

调用生成器函数时，该函数声明的函数体并不执行，而是直接返回一个生成器对象（Generator/Generator Object），生成器对象同时也是一个可迭代对象。

生成器函数只是具有逻辑执行的意义而不用于产生实例。

在生成器函数中，this引用总是指向调用该生成器函数时所传入的this。

yield也是仅在生成器函数内可用的一个运算符。

yield运算符的计算结果是下一次tor.next()调用传入的数据（取传入的第一个实参）。

有且仅有生成器函数提供“重新进入函数现场”的能力。准确地说，是yield提供退出现场的能力，而迭代对象tor.next()则恢复到执行现场。

##### 5.3.2.3 类

类（Class）也是一个函数。同时，它也是构造器。但是，类不能执行函数调用运算。

当类是声明语句时，在标识符方面的特性与普通函数是一样的。

类可以赋给对象成员，这种情况下它可以被理解为对象的一般属性，具有属性的全部性质。

##### 5.3.2.4 方法

只有在类声明和对象字面量声明中，使用了方法声明语法的函数，才是我们这里将的方法（Method）。

ES6风格方法有三个方面不同：

- 方法不能作为构造器使用
- 方法没有prototype属性（生成器作为方法时例外）。
- 方法不能具名。

方法不能用作构造器是因为JavaScript根本没有为它初始化一个名为[[Construct]]的内部槽，而“不能具名”则是语法限制。在上述所有声明中，方法名既不是上下文中的标识符，也不再方法（函数体）内部可见。

##### 5.3.2.5 箭头函数

箭头函数总是用字面量声明语法来声明的，但它不是声明语句，只能作为表达式的操作数，并以表达式所在的上下文作为它的执行环境。

箭头函数不能作为构造器，但可以作为函数或方法来调用。主要特点是：1.它永远不持有自己的this引用；2.不会有参数对象（arguments）来代表传入参数。

由于它不持有自己的this引用，所以它的代码总是会访问到当前上下文中的this: 如果它声明在全局，则是global；如果它声明在某个函数中，则是该函数调用时有效的this。

##### 5.3.2.6 绑定函数

绑定函数（Bound function）是一个计算值。

特殊性质：

- 内部原型被置为与targetFunc的原型一致。
- 没有自有的prototype属性。

绑定函数是分别将thisArg和arg1...n绑定到自己的内部槽中的，因此可以对绑定函数调用call/apply/bind方法。其中thisArg总是使用bind()方法传入的参数且不可替换，而新的、在调用绑定函数时传入的参数会追加在已绑定的arg1...n参数的后面。

在绑定函数作为构造器使用时，arg1...n的使用规则不变，但thisArg值是没有意义的。

##### 5.3.2.7 代理函数

在不设置apply/construct陷阱的情况下，代理函数的调用与构造行为与源对象一致。

class声明的类是比较特殊的，它具有[[Call]]内部槽，但是不能被调用。如果尝试调用它，那么将触发一个运行期异常。但由于类是在内部槽[[Call]]之内处理class的机制的，因此apply陷阱将被成功调用。

#### 5.3.3 函数的数据性质

##### 5.3.3.1 函数是第一型

