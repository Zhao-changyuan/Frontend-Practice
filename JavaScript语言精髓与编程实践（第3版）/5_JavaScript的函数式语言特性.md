### 5.1 概述

通常来讲，函数式语言被认为是基于“数学函数”的一种语言。当用数学领域中的抽象概念来解释函数语言时，问题通常会被聚焦为下面两个描述：

- 数学函数是集合A（称为定义域）中成员到集合B（称为值域）中成员的映射。
- 函数式程序设计就是对函数定义、函数应用加以说明，其运算过程即是对函数应用求值。

#### 5.1.1 从代码风格说起

语言风格的好坏并非判断“连续运算（或某种语言）”价值的重要依据。

#### 5.1.2 为什么常见的语言不赞同连续求值

“不支持连续运算”这种编程系统（和代码风格）其实是为了更加复合冯·诺依曼计算体系的设计。

#### 5.1.3 函数语言的渊源

从函数式语言的鼻祖——LISP开始，函数式语言就是运行在解释环境而非编译环境中的。而究其根源，还是在于冯诺依曼体系的计算机系统是基于存储于指令系统的，而并不是基于（类似Lambda演算的）连续运算的。

### 5.2 从运算式语言到函数式语言

连续运算式函数式语言的基本语言特征之一。其基本运算模型就是：

- 运算（表达式）以产生结果。
- 结果（值）用于更进一步的运算。

#### 5.2.1 JavaScript中的几种连续运算

##### 5.2.1.1 连续赋值

`a = b = c = 100;`

##### 5.2.1.2 三元表达式的连用

三元表达式是推荐连用的，这样能够充分发挥连续运算的特性。

“运算”产生值，“值”产于运算——这个逻辑是三元表达式能够连续运算的关键。

##### 5.2.1.3 连续逻辑运算

##### 5.2.1.4 逗号运算符与连续运算

箭头函数也是一个使用连续运算的好地方。

##### 5.2.1.5 解构赋值

赋值模板的嵌套问题。

##### 5.2.1.6 函数与方法的调用

一项JavaScript特性：对象的构造、函数与方法的调用等，本质上都是表达式运算而非语句。

函数调用在本质上是一个表达式。

#### 5.2.2 如何消灭语句

##### 5.2.2.1 通过表达式消灭分支语句

单个分支的if条件可以被转换成布尔表达式。

switch语句与if语句连用等效。而后者可以被第三元表达式连用替代。

##### 5.2.2.2 通过函数递归消灭循环语句

循环语句可以通过函数递归来模拟。

循环句的一个良好特性就是开销很小，而在函数的递归调用过程中，由于需要为每次函数调用保留私有数据和上下文环境，因此将消耗大量的栈空间。这样一来，用函数模拟循环就必然存在一个问题：栈溢出。

但是递归中也可以存在不占用栈的情况，这就是**尾递归**。

##### 5.2.2.3 其他可以被消灭的语句

#### 5.2.3 运算式语言

它满足说明式语言的两个特性：一是陈述运算，二是求值。

##### 5.2.3.1 运算的实质是值运算

运算的目的就是“产生值”。

- 系统的结果必然是值，并且可以通过一系列的运算来得到这一结果。

##### 5.2.3.2 运算式语言的应用

#### 5.2.4 重新认识函数

##### 5.2.4.1 函数是对运算式语言的补充

在一个纯粹的、完备的运算式语言中，函数是一个必要的补充。

##### 5.2.4.2 函数是代码的组织形式

在运算式语言中，函数不但是消减循环等语句的一个必要补充，也是一种消减代码复杂性的组织形式。

##### 5.2.4.3 当运算符等义与某个函数时

#### 5.2.5 函数式语言

函数式语言中的“函数（function）”除了能被调用之外，还具有其他三个方法的性质：是操作数、可保存数据，以及无副作用。

##### 5.2.5.1 "函数" === "Lambda"

##### 5.2.5.2 函数是操作数

当JavaScript中的函数作为参数时，也是传递引用的，但并没有地址概念。由于彻底杜绝了地址运算。由于参数是“函数调用”运算的操作数，因此当函数也是参数时他就只有操作数的含义了（而不再有地址含义），与普通参数并没有什么特别不同。

##### 5.2.5.3 在函数内保存数据

在JavaScript的函数中，函数内的私有变量可以被修改，而且当再次“进入”该函数内部时，这个被修改的状态仍将持续。

在函数内保持数据的特性被称为“闭包（Closure）”。闭包是函数执行时的现场，以及在执行后可观察、可重入的历史。

##### 5.2.5.4 函数内的运算对函数外无副作用

所谓运算对函数外无副作用，其含义在于：

- 函数使用入口参数进行运算，而不修改它（作为值参数而不是变量参数使用）。
- 在运算过程中中不会修改函数外部的其他数据的值（例如全局变量）。
- 运算结束后通过函数返回项外部系统的传值。

需要开发人员的习惯来实现这一特性。

##### 5.2.5.5 函数式的特性集

### 5.3 JavaScript中的函数

在JavaScript中使用函数式风格编程，应优先使用表达式连续运算来组织代码。

#### 5.3.1 参数

在JavaScript中，函数参数值只支持一种调用约定。它的特点表现为：

- 传入参数是从左至右求值的。
- 传入参数的值（或其引用）在函数内的重写是无副作用的。
- 传入参数的格式相对于函数声明时的形式参数是可变的。

##### 5.3.1.1 可变参数

JavaScript并不检查函数声明与函数调用时的参数类型、个数的关系。

##### 5.3.1.2 默认参数

一旦该参数不传入或者传入undefined，那么该参数在函数内将使用默认值。

尽管所有的默认参数都是有名字的形式参数，但是从第一个默认参数开始，后续的所有参数都不会再计入形式参数计数（也就是不会反映在aFunction.length属性中）。

##### 5.3.1.3 剩余参数

同默认参数一样，剩余参数也不计入形式参数计数。

##### 5.3.1.4 模板参数

模板参数用于“多个标识符对应一个传入参数”的情况。

模板参数是计入形式参数计数的。

##### 5.3.1.5 参数对象

arguments是函数内部的代码可以访问的一个变量。

这里有两条规则：

- 默认情况下，形式参数与arguments中的传入值是绑定的，所以向该参数写值，会影响到arguments中的成员，反之亦然。
- 除了直接使用arguments[x]，其他方式得到的arguments成员都不会有上述（与形式参数绑定）效果。

最后并不存在一个所谓的Arguments类。

##### 5.3.1.6 非简单参数

默认参数、剩余参数和模板参数被统称为“非简单参数”。当参数声明中使用了非简单参数时，会导致函数进入一种特殊模式。在该模式下会有三种限制：

- 函数无法通过显式地使用“use strict”语言切换到严格模式，但能接受它被包含在一个严格模式的语法块中（从而隐式地切换到严格模式）。
- 无论是否在严格模式中，函数参数声明都将不接受“重名参数”。
- 无论是否在严格模式中，形式参数与arguments之间都将解除绑定关系。

当使用非简单参数时，通过arguments获得的参数时不被赋予初值的，因此它可能会与通过参数名得到的值不一样。

arguments只是严格地反映了传入参数，而不受默认参数的影响。

##### 5.3.1.7 非惰性求值

JavaScript使用“非惰性求值”的很大一部分原因，在于它还支持赋值表达式，这也就意味着表达还是会产生副作用。

##### 5.3.1.8 传值参数

“引用求值过程”是指一个引用同时包括“值和引用的含义”。

#### 5.3.2 函数

##### 5.3.2.1 一般函数

在表达式中可以直接使用（通过声明语法来得到的）具名函数的字面量，这种情况下它的标识符仍然在函数内有效，但对函数表达式之外的作用域无效。

匿名函数不会在作用域中创建标识符，也因此它不能作为语句（而只能作为表达式操作数）。

在JavaScript的规范中，所有的函数都可以有一个名字，即aFunction.name属性。这个名字是不可靠的，它可以改变，可以删除，也可以与已具有的名字不同。

所有具名函数与匿名函数的差异也仅仅体现在这两个方面：1.是否有一个可影响当前作用域的标识符；2.是否可以用作声明语句。

##### 5.3.2.2 生成器函数

调用生成器函数时，该函数声明的函数体并不执行，而是直接返回一个生成器对象（Generator/Generator Object），生成器对象同时也是一个可迭代对象。

生成器函数只是具有逻辑执行的意义而不用于产生实例。

在生成器函数中，this引用总是指向调用该生成器函数时所传入的this。

yield也是仅在生成器函数内可用的一个运算符。

yield运算符的计算结果是下一次tor.next()调用传入的数据（取传入的第一个实参）。

有且仅有生成器函数提供“重新进入函数现场”的能力。准确地说，是yield提供退出现场的能力，而迭代对象tor.next()则恢复到执行现场。

##### 5.3.2.3 类

类（Class）也是一个函数。同时，它也是构造器。但是，类不能执行函数调用运算。

当类是声明语句时，在标识符方面的特性与普通函数是一样的。

类可以赋给对象成员，这种情况下它可以被理解为对象的一般属性，具有属性的全部性质。

##### 5.3.2.4 方法

只有在类声明和对象字面量声明中，使用了方法声明语法的函数，才是我们这里将的方法（Method）。

ES6风格方法有三个方面不同：

- 方法不能作为构造器使用
- 方法没有prototype属性（生成器作为方法时例外）。
- 方法不能具名。

方法不能用作构造器是因为JavaScript根本没有为它初始化一个名为[[Construct]]的内部槽，而“不能具名”则是语法限制。在上述所有声明中，方法名既不是上下文中的标识符，也不再方法（函数体）内部可见。

##### 5.3.2.5 箭头函数

箭头函数总是用字面量声明语法来声明的，但它不是声明语句，只能作为表达式的操作数，并以表达式所在的上下文作为它的执行环境。

箭头函数不能作为构造器，但可以作为函数或方法来调用。主要特点是：1.它永远不持有自己的this引用；2.不会有参数对象（arguments）来代表传入参数。

由于它不持有自己的this引用，所以它的代码总是会访问到当前上下文中的this: 如果它声明在全局，则是global；如果它声明在某个函数中，则是该函数调用时有效的this。

##### 5.3.2.6 绑定函数

绑定函数（Bound function）是一个计算值。

特殊性质：

- 内部原型被置为与targetFunc的原型一致。
- 没有自有的prototype属性。

绑定函数是分别将thisArg和arg1...n绑定到自己的内部槽中的，因此可以对绑定函数调用call/apply/bind方法。其中thisArg总是使用bind()方法传入的参数且不可替换，而新的、在调用绑定函数时传入的参数会追加在已绑定的arg1...n参数的后面。

在绑定函数作为构造器使用时，arg1...n的使用规则不变，但thisArg值是没有意义的。

##### 5.3.2.7 代理函数

在不设置apply/construct陷阱的情况下，代理函数的调用与构造行为与源对象一致。

class声明的类是比较特殊的，它具有[[Call]]内部槽，但是不能被调用。如果尝试调用它，那么将触发一个运行期异常。但由于类是在内部槽[[Call]]之内处理class的机制的，因此apply陷阱将被成功调用。

#### 5.3.3 函数的数据性质

##### 5.3.3.1 函数是第一型

所谓“第一类（first-class）”，意在强调指称目标“不可分解、最高级别、不被重述”等。

“第一型（first-class data types）”通常是指基础类型。

JavaScript中的函数之所以能具有“函数式语言的函数”这样的特性，其最重要的前提是“让函数可以作为操作数”。这使得它既可以作为数据值存储并在函数调用中传入传出，又可以作为函数来执行调用。

在JavaScript中的第一型，就是指7中基本类型：undefined、string、boolean、number、symbol、object和function。

##### 5.3.3.2 数据态的函数

从函数式语言的角度来说，“所有的东西都是值”。

##### 5.3.3.3 类与对象态的函数

Function()即使一个构造器，它能构造实例，也有Function.prototype作为实例的原型。而且最重要的是，它所构造出来的实例就是函数——对象态的函数。JavaScript将所有函数的原型链的顶端都设为Function.prototype。

##### 5.3.3.4 代理态的函数

代理函数也可以称为一个函数的代理态。

函数与一般对象的区别在于，前者的内部结构中初始化了[[Call]]和[[Constuct]]这两个内部方法（之一或全部）。

#### 5.3.4 函数与逻辑结构

##### 5.3.4.1 递归

函数的递归就是函数调用自身。由于可以使用函数参数来传递循环逻辑所必须的控制变量，因此——在不引入新的语义/概念的前提下——递归是实现循环逻辑的首选。

arguments.callee这个属性用来指向函数自身，以便在匿名函数中实现递归。

绑定函数是执行结果，所以它自身没有函数体，也就不能“在绑定函数内调用自身”。

##### 5.3.4.2 函数作为构造器的递归

##### 5.3.4.3 块级作用域中的函数

嵌套函数或函数作为表达式操作数时是性能更低的。

函数声明是在语法分析期完成的，但函数实例的初始化是在运行期进行的。因此函数初始化的位置与运行期性能有关，这也是更推荐奖函数放在模块中的原因。

简而言之，不要将函数声明作为循环逻辑的一部分。

### 5.4 函数的行为

构造以及方法调用中对this的处理历来被函数式语言的维护者所诟病，因为它意味着隐式传入参数，以及JavaScript具有在“参数之外”去影响函数行为的能力。

#### 5.4.1 构造

##### 5.4.1.1 this引用的创建

若MyFunction()是一个一般函数，那么new运算会启用一个标准的、分三步的构建过程：

1. 取有效的MyFunction.prototype或Object.prototype为原型创建this。
2. 调用MyFunction.call(this)来初始化是，取结果值result。
3. 取有效的result值或this作为new运算的结果值。

MyClass()类作为函数的代码体就是声明时所指定的或默认的构造方法constructor()，并且无论如何：

- 如果有extends声明存在，那么该方法总是包括一个“通过super()来调用父类构造方法”的过程。

在通过“标准构建方法”处理MyClass()时，JavaScript跳过了其中的第一步而直接进入MyClass.call()，这使“在进入构造方法时”根本没有有效的this引用；然后上述“总是存在的”super()调用将接管这个“创建this”的动作，从而确保总是能通过动态地、链式地嗲用父类ParentClassFunction()的构造方法来产生this实例。

##### 5.4.1.2 初始化this对象

在JavaScript的类声明中，如果在构造方法中没有调用super()，也是可以通过返回值来作为（它以及它的子类的）this的。

也就是说，如果类有一个正确的构造方法，那么它要么创建了一个有效this，要么返回了一个有效的结果值作为this引用。JavaScript不需要动态地检查用户代码的构造方法中是否包含一个super()调用，而只需在这个构造方法退出时检查上下文和返回值就可以了。

#### 5.4.2 调用

“类”实际上被设计为一个“可调用的函数”，而对它执行“函数调用”是抛出异常。

由于JavaScript引擎总是从“执行上下文栈”的顶端取可执行帧来执行代码，因此入栈也就相当于切换执行指针。

##### 5.4.2.1 不使用函数调用运算符

回调是另一种典型的函数调用行为，它是在框架中实现控制逻辑的基本方法（或模式）。

##### 5.4.2.2 callee：我是谁

由于arguments总可以在函数内部直接访问，因此也就总可以在函数内部识别“我是谁”。

赋值callee的行为其实是发生在参数args的准备阶段的。也就是说，当JavaScript解析到这行代码，决定要为调用f()准备一个参数列表args时，就会为args添加一个名为callee的成员。并且：

- 如果当前是非严格模式，则callee是一个数据描述符，value指向f()；
- 如果当前是严格模式，则callee是一个存取属性描述符，其get()将直接抛出异常。

##### 5.4.2.3 caller：谁调用我

从语义上讲，在递归中，标识符aFunction总是指代同一个函数，因此这两个函数也就只能指向栈顶“最后一次”有效的调用者或传入参数。

#### 5.4.3 方法调用

我们将调用函数时“持有有效this对象”的行为称为方法调用，以强调这种情况下该函数是“作为对象方法来使用的”这一事实。

##### 5.4.3.1 属性存取与this引用的传入

“this引用的传入”实际上发生在执行期，但很大程度上却依赖JavaScript在语法分析阶段所做的工作。

所谓“this引用的传入”实际上是一个动态的运算结果，它依赖JavaScript的语法设计以及语言引擎在运行期动态解析baseReference，并且最后在进行函数调用运算时动态地将thisArg传入。

##### 5.4.3.2 this引用的使用

在函数调用时“（向函数内）传入this引用”并不等于这个函数会实际使用它。

箭头函数“只使用词法上下文中的this引用”。

##### 5.4.3.3 在方法调用中理解super

“使用super引用（super.xxx）”会给自己绑定一个this引用，这个this引用来自当前上下文中的this。

所谓super.xxx是作为整体独立的语法结构直接返回一个“super引用”，并在这时将this绑定到“super引用”之上的。

##### 5.4.3.4 动态地添加方法

就“super引用”来说，一个被调用方法中的“super.xxx中的super”是动态计算得到的，而不是像“this引用”那样将this动态传入给函数。

#### 5.4.4 迭代

为了表达如何循环处理“可计算对象”，JavaScript特意设计了一种“函数的行为”，称为迭代（iteration）；而它的可计算对象就称为可迭代对象。

迭代可以视为对JavaScript中循环逻辑的补充。

##### 5.4.4.1 可迭代对象与迭代

当执行一个迭代方法（函数）时，总是传入该迭代对象作为this引用，并且该方法总是能返回一个用于“控制迭代过程”的对象，称为迭代器（Iterator）。

每次调用迭代器方法总是返回一个新的迭代器，因此一个可迭代对象能在多个各自独立的过程中被多次迭代。

##### 5.4.4.2 可迭代对象在语法层面的支持

认可可迭代对象都可以直接使用for...of来列举它的成员。或被展开，或作为数组等集合对象的初始成员，或匹配结构模式中的元素。

由于“可迭代对象”表达的是对象的访问界面而不是对象的性质，所以某些通过该界面来实现的特性——在几乎所有的可迭代对象中——也是通用的。

但是数组的forEach、filter等方法却不是基于这一特性的，而是基于数组下标遍历的。

并且，对象属性展开的特性看起来根数组展开类似，但实际上是利用对象属性存取（包括下标索引）的特性，而非迭代器。

##### 5.4.4.3 迭代器的错误与异常处理

在JavaScript内部，真正使用迭代器的有且仅有以下场合。

- 特定语法
  - for (... of obj) ...语句会通过对象的属性obj[Symbol.iterator]来列举成员。
  - 在生成器内yield*可以位图给目标迭代器（target）。
  - 在数组的结构赋值中，会取赋值表达式右边的值（value）的迭代器并列举其成员。
- 特定对象的方法或行为：
  - 在Array和TypedArray的from()方法中列举源（items）以复制给数组。
  - Map/Set/WeakMap/WeakSet在创建时使用可选参数并从中（iter）列举成员。
  - Promise在all()和race()方法中需要列举处理所有的promise对象。

并不是所有的异常（或异常触发的方式）都会导致tor.return()或tor.throw()触发。是的，异常也并不见得一定会导致tor.throw()触发，这让这个方法显得名不符实。这些触发的内部机制尽管相当复杂，却都基本遵循着一条“谁用谁负责”的原则：谁使用迭代器，就由谁来负责调用它的return/throw方法。

#### 5.4.5 生成器中的迭代

调用生成器函数可以得到生成器，后者也可以作为迭代器来使用。

##### 5.4.5.1 生成器对象

生成器对象不是通过new运算产生的，而是通过调用对应的生成器函数（例如：myGenerator）得到的。生成器对象（也常简称为生成器）使用myGenerator.prototype作为原型，并因此具有了“迭代器界面”。

迭代器在退出时返回的值，既可能是这里的生成器myGenerator的执行状态，也可能是毫无意义的其他任意值。后者，以我们之前所说的“可迭代对象”来说，当tor.done，各种迭代运算都视为迭代终止且tor.value无意义。

这个tor本质上仍然是迭代器（是用于迭代执行的结构），所以它只能完成一次迭代，这与数组等集合对象略有不同——后者是有着确实数据内容的集合。

##### 5.4.5.2 生成器的错误与异常处理

JavaScript扩展了迭代器的错误与异常处理机制，它默认第为生成器对象提供两个原生方法拉实现迭代器(tor)界面中的return()和throw()方法。

你可以在“生成器函数之外的”代码中直接调用tor.return()来影响生成过程。

在生成器中，tor.return()方法的实际作用是返回（或“唤醒”）生成器函数myGenerator()，并从上次yield的位置“立即退出(return)”该生成器。这种从外部调用tor.return()的方法，实际上是给生成器myGenerator()一个结束处理的机会。

##### 5.4.5.3 方法throw()的隐式调用

##### 5.4.5.4 向生成器中传入的数据

迭代协议并未约定日和使用next方法的参数。而在生成器中对此进行了有限的扩展：允许传入一个参数作为生成器（函数）内的yield运算符的运算结果。

### 5.5 闭包

在JavaScript中，函数只是一段静态的代码、脚本文本，一次它是一个代码书写时，以及编译期、静态的概念；而闭包则是函数的代码在运行过程中的一个动态环境，是一个运行期、动态的概念。

#### 5.5.1 闭包与函数实例

由于JavaScript引擎通过闭包来为每个函数维护执行期的信息，因此当函数被再次执行或者通过某种方法进入函数体内时，就可以通过访问闭包得到这些信息。

##### 5.5.1.1 闭包与非闭包

对于函数代码块中的“可访问标识符”，JavaScript中用“闭包”来指代一个**函数实例**在运行期的作用域。

也就是说，闭包就是记录**函数实例**在运行期的“可访问标识符（identifiers in lexical scope）”的结构。因此一个**函数实例**的一次执行，就会带来一个新的执行期作用域，即一个闭包；而在执行代码看来，它就是执行期的作用域链（scope chain），因其外部引用指向它被调用时的作用域。

##### 5.5.1.2 什么是函数实例

在书写代码的过程中，函数只是一段代码文本。在真实的运行环境中需要先将它们变成可处理的数据对象——“对象系统中”函数类的实例。从文本到数据对象的这个行为：

- 对于“函数声明（Declaration）”来说叫“实例化（Instantiate FunctionObject）”。
- 对于“函数表达式（Expression）”来说叫“创建函数的实例（Function Create）”。

一份函数代码也可以有多份函数实例。

##### 5.5.1.3 看到闭包

##### 5.5.1.4 闭包的数量

- JavaScript中的函数实例可以拥有多个闭包。
- JavaScript中的函数实例与闭包的生存周期是分别管理的。
- JavaScript中的函数被调用时总是初始化一个闭包；而上次调用中的闭包是否销毁，取决于该闭包中是否有被（其他闭包）引用的变量/数据。

#### 5.5.2 闭包的使用

##### 5.5.2.1 运行期的闭包

