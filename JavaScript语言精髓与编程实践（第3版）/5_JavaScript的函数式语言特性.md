### 5.1 概述

通常来讲，函数式语言被认为是基于“数学函数”的一种语言。当用数学领域中的抽象概念来解释函数语言时，问题通常会被聚焦为下面两个描述：

- 数学函数是集合A（称为定义域）中成员到集合B（称为值域）中成员的映射。
- 函数式程序设计就是对函数定义、函数应用加以说明，其运算过程即是对函数应用求值。

#### 5.1.1 从代码风格说起

语言风格的好坏并非判断“连续运算（或某种语言）”价值的重要依据。

#### 5.1.2 为什么常见的语言不赞同连续求值

“不支持连续运算”这种编程系统（和代码风格）其实是为了更加复合冯·诺依曼计算体系的设计。

#### 5.1.3 函数语言的渊源

从函数式语言的鼻祖——LISP开始，函数式语言就是运行在解释环境而非编译环境中的。而究其根源，还是在于冯诺依曼体系的计算机系统是基于存储于指令系统的，而并不是基于（类似Lambda演算的）连续运算的。

### 5.2 从运算式语言到函数式语言

连续运算式函数式语言的基本语言特征之一。其基本运算模型就是：

- 运算（表达式）以产生结果。
- 结果（值）用于更进一步的运算。

#### 5.2.1 JavaScript中的几种连续运算

##### 5.2.1.1 连续赋值

`a = b = c = 100;`

##### 5.2.1.2 三元表达式的连用

三元表达式是推荐连用的，这样能够充分发挥连续运算的特性。

“运算”产生值，“值”产于运算——这个逻辑是三元表达式能够连续运算的关键。

##### 5.2.1.3 连续逻辑运算

##### 5.2.1.4 逗号运算符与连续运算

箭头函数也是一个使用连续运算的好地方。

##### 5.2.1.5 解构赋值

赋值模板的嵌套问题。

##### 5.2.1.6 函数与方法的调用

一项JavaScript特性：对象的构造、函数与方法的调用等，本质上都是表达式运算而非语句。

函数调用在本质上是一个表达式。

#### 5.2.2 如何消灭语句

##### 5.2.2.1 通过表达式消灭分支语句

单个分支的if条件可以被转换成布尔表达式。

switch语句与if语句连用等效。而后者可以被第三元表达式连用替代。

##### 5.2.2.2 通过函数递归消灭循环语句

循环语句可以通过函数递归来模拟。

循环句的一个良好特性就是开销很小，而在函数的递归调用过程中，由于需要为每次函数调用保留私有数据和上下文环境，因此将消耗大量的栈空间。这样一来，用函数模拟循环就必然存在一个问题：栈溢出。

但是递归中也可以存在不占用栈的情况，这就是**尾递归**。

##### 5.2.2.3 其他可以被消灭的语句

#### 5.2.3 运算式语言

它满足说明式语言的两个特性：一是陈述运算，二是求值。

##### 5.2.3.1 运算的实质是值运算

运算的目的就是“产生值”。

- 系统的结果必然是值，并且可以通过一系列的运算来得到这一结果。

##### 5.2.3.2 运算式语言的应用

#### 5.2.4 重新认识函数

##### 5.2.4.1 函数是对运算式语言的补充

在一个纯粹的、完备的运算式语言中，函数是一个必要的补充。

##### 5.2.4.2 函数是代码的组织形式

在运算式语言中，函数不但是消减循环等语句的一个必要补充，也是一种消减代码复杂性的组织形式。

##### 5.2.4.3 当运算符等义与某个函数时

#### 5.2.5 函数式语言

函数式语言中的“函数（function）”除了能被调用之外，还具有其他三个方法的性质：是操作数、可保存数据，以及无副作用。

##### 5.2.5.1 "函数" === "Lambda"

##### 5.2.5.2 函数是操作数

当JavaScript中的函数作为参数时，也是传递引用的，但并没有地址概念。由于彻底杜绝了地址运算。由于参数是“函数调用”运算的操作数，因此当函数也是参数时他就只有操作数的含义了（而不再有地址含义），与普通参数并没有什么特别不同。

##### 5.2.5.3 在函数内保存数据

在JavaScript的函数中，函数内的私有变量可以被修改，而且当再次“进入”该函数内部时，这个被修改的状态仍将持续。

在函数内保持数据的特性被称为“闭包（Closure）”。闭包是函数执行时的现场，以及在执行后可观察、可重入的历史。

##### 5.2.5.4 函数内的运算对函数外无副作用

所谓运算对函数外无副作用，其含义在于：

- 函数使用入口参数进行运算，而不修改它（作为值参数而不是变量参数使用）。
- 在运算过程中中不会修改函数外部的其他数据的值（例如全局变量）。
- 运算结束后通过函数返回项外部系统的传值。

需要开发人员的习惯来实现这一特性。

##### 5.2.5.5 函数式的特性集

### 5.3 JavaScript中的函数

在JavaScript中使用函数式风格编程，应优先使用表达式连续运算来组织代码。

#### 5.3.1 参数

在JavaScript中，函数参数值只支持一种调用约定。它的特点表现为：

- 传入参数是从左至右求值的。
- 传入参数的值（或其引用）在函数内的重写是无副作用的。
- 传入参数的格式相对于函数声明时的形式参数是可变的。

##### 5.3.1.1 可变参数

JavaScript并不检查函数声明与函数调用时的参数类型、个数的关系。

##### 5.3.1.2 默认参数

一旦该参数不传入或者传入undefined，那么该参数在函数内将使用默认值。

尽管所有的默认参数都是有名字的形式参数，但是从第一个默认参数开始，后续的所有参数都不会再计入形式参数计数（也就是不会反映在aFunction.length属性中）。

##### 5.3.1.3 剩余参数

同默认参数一样，剩余参数也不计入形式参数计数。

##### 5.3.1.4 模板参数

模板参数用于“多个标识符对应一个传入参数”的情况。

模板参数是计入形式参数计数的。

##### 5.3.1.5 参数对象

arguments是函数内部的代码可以访问的一个变量。

这里有两条规则：

- 默认情况下，形式参数与arguments中的传入值是绑定的，所以向该参数写值，会影响到arguments中的成员，反之亦然。
- 除了直接使用arguments[x]，其他方式得到的arguments成员都不会有上述（与形式参数绑定）效果。

最后并不存在一个所谓的Arguments类。

##### 5.3.1.6 非简单参数

默认参数、剩余参数和模板参数被统称为“非简单参数”。当参数声明中使用了非简单参数时，会导致函数进入一种特殊模式。在该模式下会有三种限制：

- 函数无法通过显式地使用“use strict”语言切换到严格模式，但能接受它被包含在一个严格模式的语法块中（从而隐式地切换到严格模式）。
- 无论是否在严格模式中，函数参数声明都将不接受“重名参数”。
- 无论是否在严格模式中，形式参数与arguments之间都将解除绑定关系。

当使用非简单参数时，通过arguments获得的参数时不被赋予初值的，因此它可能会与通过参数名得到的值不一样。

arguments只是严格地反映了传入参数，而不受默认参数的影响。

##### 5.3.1.7 非惰性求值

JavaScript使用“非惰性求值”的很大一部分原因，在于它还支持赋值表达式，这也就意味着表达还是会产生副作用。

##### 5.3.1.8 传值参数

“引用求值过程”是指一个引用同时包括“值和引用的含义”。

#### 5.3.2 函数