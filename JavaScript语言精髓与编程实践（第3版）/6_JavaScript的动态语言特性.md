### 6.1 概述

程序最终可以被表达为数据和逻辑（即结构和算法）两个方面，命令式和说明式（以及函数式）语法是从程序的这两个本质方面来进行分类的。借鉴自然语言的体系，所谓语言，是应当包括“语法、语义和语用”三个方面的。具体在计算机体系中实现某种语言时，如果在语言陈述是无法确定而必须在计算机执行时才能确定这三者之间的关系，我们称改语言是动态语义的（反之称为静态语义的）。

#### 6.1.1 动态数据类型的起源

SNOBOL APL

#### 6.1.2 动态执行系统



#### 6.1.3 脚本系统的起源



#### 6.1.4 脚本只是表现形式

### 6.2 动态类型：对象与值类型之间的转换

JavaScript中存在两套类型系统，其一是基础类型系统（Base types），是由typeof运算来检测的按照约定，该类型系统包括7中类型（undefined、number、boolean、string、symbol、function和object）；其二是对象类型系统（Object types），对象类型系统是“对象基础类型（object）”中的一个分支。

#### 6.2.1 包装类：面向对象的妥协

在值类型数据经过“包装类”包装后得到来的对象与原数据将并不再是同一数据，只是二者具有等同的值而已。

##### 6.2.1.1 显式创建

从语言的实现上来说，这与传统语言中的“类型强制转换”完全不同：强制类型转换是在同一数据（相同内存地址的不同引用）的基础上进行，但上述语法将创建一个新的数据。

##### 6.2.1.2 显示包装

JavaScript内建的Object()类支持显示地将boolean、number、string和symbol四种值类型包装成对应的对象，这一语法在语义上解释为“基于值来创建等同的对象”。

##### 6.2.1.3 隐式包装的过程与检测方法

所谓值类型数据到对象的“隐式包装”，在已知的表达式运算中，其实总是由成员存取运算符触发的。

##### 6.2.1.4 包装值类型数据的必要性与问题

“值类型数据的方法调用”其实是被临时地隔离在另外一个对象中完成的。而同样的原因，无论我们如何修改这个新对象的成员，这种修改也不会影响到原来的值。

除了在属性存取等操作中需要一个包装过的对象之外，一些语句也有类似的需求。例如with语句总是视图打开一个对象的闭包，因此如果它作用的表达式返回一个值类型数据，那么with语句会通过包装类转换为对象并打开它的闭包。又例如（与此类似），for...in/of语句也会有这样的过程。

##### 6.2.1.5 其他字面量与相应的构造器

基础类型中还有object与function。这两种类型中的object基础类型，又有Object、Array与RegExp三种对象存在字面量风格的声明语法。

##### 6.2.1.6 函数特例

JavaScript作为函数式语言的重要特性——函数是第一型。JavaScript作为面向对象语言的重要特性——函数是对象。

#### 6.2.2 从对象到值

一个是隐式的对象到值的转换规则，另一个是valueOf()方法。

##### 6.2.2.1 对象到值的隐式转换规则

首先，null是对象。null作为对象总是转换为确定的三种值类型，即0、'null'和false。

并且，除了null之外的所有其他对象都必然转换为Boolean和true值。

对象到数字（number）和字符串（string）类型值的转换，是直接与该对象的valueOf()以及toString()方法相关的。即：

- 如果试图转换为字符串，则先尝试该对象的toString()方法，然后再尝试valueOf()方法；否则（必然是尝试转换为数字），
- 首先尝试调用valueOf()方法，再尝试调用toString()。

如果toString()或valueOf()返回非值的对象，则视为结果值无效，并按上述规则尝试另一个方法。如果两个方法都返回无效结果值，则抛出异常。

ECMAScript规范中，null值会被认为是这样的“（非对象的）原始值”，因此它可以作为toString()、valueOf()的返回值并进入后续的值运算。

##### 6.2.2.2 直接的值运算不受包装类的方法影响

由于值数据在参与值运算是并不需要“对象->值”的转换，因此也就不需要隐式地调用这些包装类的方法。

“在值运算中，加号（+）运算符优先于字符串连接”这一规则是在“+”号运算符两侧的都是值类型数据时才会生效的。

对值类型数据来说，在包装类原型上的toString()和valueOf()方法其实只会对（包装后对象的）显示方法调用有效。而并不会影响原始的值运算。

“类型转换分两个阶段”：其一是转换为原始值（to primitive value），其二是转换为尝试运算的值类型（to a number, or other）。

##### 6.2.2.3 什么是“转换的预期”

并没有文档来说明当“操作数/参数（x）”与运算符或函数界面上的设计不一致时，JavaScript的内核（也包括用户代码，或者具体语言引擎的运行期库）对这个x设定为哪种预期，并用该预期来决定上述调用顺序。

在“所有没有预期”的情况下，JavaScript优先使用“先valueOf()，后toString()”这一顺序。亦即是说，隐式地、默认地以“x.valueOf()”为优先。

在“对象到值的转换”时，默认“x.valueOf()”优先，而在“加号（+）”运算时，却默认字符串优先，二者正好不同。

##### 6.2.2.4 深入研究valueOf()方法

当x是对象时，默认情况下，x.valueOf()返回对象x自身，也就是.valueOf()返回对象，而不是“值类型数据”。

默认时许多引用类型数据并不能通过它的valueOf()方法来得到一个有效的值。隐式规则将会忽略这个值并尝试调用他们的toString()方法来得到一个字符串，以使之能尽量参与值运算。

在用户代码中修改系统内置的这些对象原型的valueOf()或toString()方法是可以做到的，但并不可取。

##### 6.2.2.5 布尔运算的特例

隐式转换规则中，“对值的预期”只有字符串和数字两种。因为除了null值之外，所有的对象都别直接视为true值，而与x.valueOf()或x.toString()的结果值无关。

“任何对象（包括布尔对象）”在进行布尔运算时，都是作为对象使用的；在进行数值或字符串运算时，都是按隐式规则使用valueOf()和toString()来转换为值使用的。

##### 6.2.2.6 符号Symbol.toPrimitive的效果

任何对象都可以通过Symbol.toPrimitive这个符号属性来改变它作为值的效果。一旦对象（或它的原型）声明过Symbol.toPrimitive属性，那么valueOf()与toString()在值运算的隐式转换中就无效了。

无论Symbol.toPrimitive属性的函数中返回的内容是否符合预期，只要它不是对象，那么该值金辉进入后续的运算。

#### 6.2.3 显示的转换

| 转换到   | object    | number    | boolean    | string    | symbol    |
| -------- | --------- | --------- | ---------- | --------- | --------- |
| 值或对象 | Object(x) | Number(x) | Boolean(x) | String(x) | Symbol(x) |

当使用这种函数调用而非他们的构造器形成的风格时，函数预期的值类型是确定的。

##### 6.2.3.1 显示转换的语法定义

上述放在语法上完全类似其他语言中的“类型强制转换”。

##### 6.2.3.2 对“转换预期”的显式表示

布尔值并不在上述所谓“预期的值”的范畴之内，因为布尔值总是按确定规则转换的。

##### 6.2.3.3 关于符号值的补充说明



### 6.3 动态类型：值类型的转换

由于类型只能在代码执行过程中才能获知，所以JavaScript也就只能采用“运算过程中执行某种类型转换规则”来解决不同类型间的运算问题。

问题是：无论是toString()、valueOf()，还是Symbol.toPrimitive，这些显示或隐式转换规则背后的逻辑都只确保了“返回结果是‘值’”，而并没有确保这些“值”是表达式运算（运算符）所预期的的那种类型。

所以在JavaScript的表达式运算中发生的，最终必然是以值类型为基础的类型装换。

#### 6.3.1 值运算：类型转换的基础

基础类型其实是有两类：值类型和引用类型，然而引用类型自身其实并不参与值运算。对于计算系统来说，引用类型的价值是：

- 标识一组值数据。
- 提供一组存取值数据的规则。
- 在函数中传递与存储引用（标识）。

这使得“引用->值”和“值->值”的类型转换是JavaScript中类型转换的终极目标。

##### 6.3.1.1 完整过程

在运行期，引擎执行语法树上（由运算符指定）的运算时，将首先根据“（运算符对）转换的预期”进行一次操作数的隐式转换。

这里首先进行的语法推断是：是检查引用还是求值运算。除了少数直接作用于“引用本身”的运算符之外，都会首先发生“引用->值”的转换，称为“隐式转换”。

隐式转换需要抉择valueOf()和toString()的调用顺序，因此首先要根据具体的操作才确定一个可预期的目标类型。隐式转换的目标是基础类型（toPrimitive）。

除了运算符，一些函数在调用时可能执行一些隐式的类型转换。

##### 6.3.1.2 语句或语义导致的类型转换

还有一些语句在语义分析时会做一些强制类型转换的操作。

“if语句”必然会把表达式的结果转换为布尔值。

在对象声明时，也存在标识符到字符串的转换。

在语法上，switch()语句视图对表达式求值，并用该值与case分支中的值进行比较运算。但是，它在比较中采用的是类似“===”操作符的运算，即，会优先进行类型检测而不会发生类型转换过程。

#### 6.3.2 值类型之间的转换

##### 6.3.2.1 undefined的转换

任何值都不能转换为undefined，但反过来却不是。

undefined能转换为特殊数值NaN。

undefined能转换为字符串'undefined'与布尔值false。

##### 6.3.2.2 number的转换

除了符号之外的任何值都可以被转换为number类型的值。如果转换得不到一个有效的数值，那么结果会是一个NaN，而NaN又是一个可以参与数值运算的值。

number值转换为布尔值时，非零值都转为true，零与NaN都转为false。

number值在转换到字符串时有及其复杂的内部规则。总的来说，一下特殊值被转换为一般字符串文本：

- Number.NEGATIVE_INFINITY，转换为'-Infinity'
- Number.POSITIVE_INFINITY，转换为'Infinity'
- global.Infinity，转换为'Infinity'
- global.NaN，转换为'NaN'

除此之外，其他数值都能被转换为一个有数值含义的字符串。

##### 6.3.2.3 boolean的转换

boolean值的true和false总是被转换为数值1和0。

在操作数不是“string和number之一”的值类型时，“+”运算将被默认为求和运算，并进而尝试将操作数转换为number。

boolean值的true和false总是被转换为字符串“true”和“false”。

##### 6.3.2.4 string的转换

JavaScript中对“字面量数字”与“字符串数字”的处理是不一样的。首先，如果在代码中出现字面量数字，那么这个数字式在语法分析阶段处理并作为一个数字值存放在变量中的。然而，如果是“字符串数字”，那么它的转换过程只会发生在运行期，并且没有任何隐式的机制来处理八进制类型。

亦即是说，如果一个字符串由数值和不多于一个的小数点构成，那么它总是能被当做十进制数来转换为数值。

如果字符串由'0x'（零和x|X）开始作为前缀，且由0~9、A~F、a~f这些字符（不包括小数点）构成，则它总是可以被作为十六进制数转换为数值。

不能把"true"和"false"这两个字符串转换为对应的boolean值。

##### 6.3.2.5 symbol的转换

与undefined一样，没有任何类型能转换成符号。

symbol只有一个值类型的转换可以发生：它可以转换为boolean值的true。

尝试将符号转换成其他值都会导致错误。但可以通过包装类将它转换为一个等值与该符号的对象。

#### 6.3.3 值类型之间的现实转换

##### 6.3.3.1 到数值的显式转换

parseInt()和parseFloat()的特性之一在于总是尽可能地得到转换结果。即使字符串中只有（前缀的）部分能被转换，那么该转换也将成功进行。

parseInt()和parseFloat()的另一个问题是他们总是尝试先将参数转换为字符串，即使参数本身就是数值。

所以对于parseInt()与parseFloat()，除非你能准确理解“将参数转换为字符串”时的规则，或你确实只传入有效的字符串值，否则不要使用他们。

##### 6.3.3.2 到字符串类型的显式转换

显式使用x.toString()来转换仍然不是绝对安全的。

在进行Number到字符串的转换时，还存在两个问题：指定小数点的位置与如何启用指数计数法。

在JavaScript的各种对象中，存在一组以“to”为前缀的方法。这类似于toString()，这些方法无一例外都用于转换为字符串。

##### 6.3.3.3 到undefined值的显示处理

任何情况下你都可以对表达式使用void运算来将其结果“转换”成undefined。

##### 6.3.3.4 到布尔值的显式处理

“!!”确实可以用来显式地将目标数据转换成一个布尔值。

推荐在需要这种处理时直接使用Boolean(x)而非!!x，前者的语义更加明确。

### 6.4 动态类型：对象与数组的动态性

索引数组与关联数组是从数组的下标使用方式上来区分的一种方法。所谓索引数组，是指以序数作为下标遍历，按序存取元素的数组；所谓关联数组，则是指以非序数作为下标遍历来存取的数组。

JavaScript必然是以关联数组为基础，来实现“（使用索引存取的）数组”这种对象类型。

#### 6.4.1 管理数组与索引数组

关联数组的下标是非序数的，所以它看起来更像是一张“表”。

更进一步 明确地说，JavaScript中的对象实例所持有的属性表（自有属性表），就是一个关联数组的内存表达。因而：

- 所谓属性存取，其实就是查表。

既然所谓索引数组其实是使用数字的形式（内部仍然是字符串的形式）来存取的一个关联数组，那么你也就完全可以用in运算，或for...in语句来考察它的成员——这里值得是数组下标（或数组元素）。

如果你仅仅是要考察哪些可索引的数组元素，那么仍然建议使用for...of语句，或者使用数组的forEach()等方法。

#### 6.4.2 索引数组作为对象的问题

JavaScript中的数组表现为索引数组，但是具有对象的全部性质。

##### 6.4.2.1 索引数组更加低效

尽管大多说的处理仍然是基于对象的正常机制，但是JavaScript额外地处理了索引数组中的length属性。

JavaScript在事实上并不为数组“维护某种连续性”。

按照规范，数组的成员和length属性都是动态存取的。也就是说，无论是for...of迭代，还是一般的for/while循环，在循环体内是可以增删数组成员的；而且只要这两个数组成员的下标还没有被访问，那么这些动态添加的成员将是可被列举的。

##### 6.4.2.2 属性length的可写性

每一个数组都将length作为自有属性。

##### 6.4.2.3 类型化数组的一些性质

类型化的数组的length属性是由存取描述符来管理它的性质的，并且默认继承自它的原型（他没有写方法，但可以重置描述符）。

所有类型化数组都实现为一种典型的索引数组的操作界面，但由于他们的length属性被限制为不可写，因此他们总是定长的。

类型化的数组的length属性可能是0值。

#### 6.4.3 类数组对象：对象作为索引数组的应用

在JavaScript，索引数组的独特性并不表现在整数下标存取，而在于length属性的维护。

一个“有length属性”的对象在JavaScript中就被称为“类数组对象（array-like objects）”。

给一个原子对象添加一个可写的length属性，就得到了一个“最原始”的类数组对象。

**所有使用数组的迭代器接口的方法，却不适用于上述对象。这是因为类数组对象默认时并没有定义Symbol.iterator这个属性。**

类数组默认时是不能被当作集合对象（这里是指Collection Types）来使用的，因此也就不能作为其他集合的源。

#### 6.4.4 其他

任何对象只要有迭代器接口，就可以简单地转为集合对象。

类型化数组也是集合类型（Collection Types）对象的一种，它的构建界面也允许传入“有迭代器接口的对象”作为源。但是，类型化数组会先通过迭代器得到一个类数组对象，然后在列举这个类数组对象的每一个成员并将它们添加到数组中去。

### 6.5 重写

JavaScript中的重写是一个代码执行期的行为。

#### 6.5.1 标识符的重写及其限制

标识符的迟绑定是JavaScript的语言特性之一。

绑定行为是推迟到何时才发生的：在环境（作为一个设施）就绪的时候，其上下文中的所有标识符就被创建了；随后，用户代码开始执行，并且依据标识符在用户代码中的逻辑顺序在执行过程中完成绑定。

换言之，“执行不到，就不绑定”。但在这其中有连个例外，可以称为系统内部绑定操作。其一，除了let/const之外的声明，是在用户代码之前绑定的；其二，模块的导入导出是在用户代码执行之前由 模块的装配逻辑浮躁绑定的。其中“let/const之外的声明”是指var声明、函数声明、类声明以及形式参数的默认值声明。然而let变量与const常量只有标识符的声明语义，其绑定语义是在执行过程中由赋值操作来实现的。

##### 6.5.1.1 早于用户代码之前的声明与重写

在系统约定的名字中，只有arguments在非严格模式下可以重写；super/this等式保留不可重写的关键字；而null/false/true等式值，所以不可写。

因为历史原因，undefined是可写的，只是（在非严格模式中）重写该值无效而已。

这是因为历史中undefined并非是一个显式的、可全局访问的值，而是void运算的结果，或当函数没有返回，又或者变量声明后没有赋值等情况下JavaScript语言给返回的一个默认值。

const/let声明的标识符不可重新声明，这貌似是在语法分析期就检测到的行为，但是确实在执行期、在上述“在环境（作为一个设施）就绪的时候”检测抛出异常的。

##### 6.5.1.2 声明对标识符可写性的影响

新方案与旧规则的兼容方案否基于一下设定：

- var/const/let在语法分析期仅得到标识符名。
- 在执行期他们在语义上是“将值绑定到标识符”，而非赋值。

我们之前说过的“在环境（作为一个设施）就绪的时候，其上下文中的所有标识符就被构建了出来”，需要注意的是，上述设定并不包括这个构建过程。这是因为不同“环境”下的构建过程是有区别的。这也是上述两项设定被单独抽象出来的原因。而在这些环境的构建过程中，从“标识符名”变成“环境中可访问的标识符”是一个特定的操作，叫“创建绑定（Create Binding）”。

“绑定初值”的操作只是借用了赋值语句的语法，并非真的赋值。

##### 6.5.1.3 赋值操作带来的重写

JavaScript中非常对的词法元素都可以用作“左手端表达式（lhs）”；并且在多数情况下，对lhs有效性的进一步检测将会发生在执行期（也因此导致执行运算错误而非语法问题）。

lhs总是被作为一个表达式执行并得到它的执行结果（Result），然后赋值语句将尝试向该Result置值（Put Value），此时JavaScript才会检测Result是否能接受赋值操作。

字面量也是未被任何标识符、环境、对象或集合成员引用的、“孤立存在的”一个数据。

当一个操作数作为lhs时，要执行的是“（检查它被谁引用，并）取引用”操作；反之作为rhs时，要执行的是“取值”操作。

赋值语句的完整语义（value get from rhs，and put it to lhs's reference）。

由于操作数作为lhs时是需要“取引用”的，因此如果赋值操作左侧的数据“没有被引用”，就会出现“引用错误（ReferenceError）“；再进一步，如果左侧是被引用的，但当其可写性为false（是常量或只读的属性）时，就会出现”类型错误（TypeError）“。

而这就是重写在赋值操作中的两个主要限制：可引用与可写。

##### 6.5.1.4 对象内部方法对重写的影响



##### 6.5.1.5 非赋值操作带来的重写

自增/自减运算符会先隐式地将操作数转换成数值类型，并将标识符重写为最终运算的结果。

try...catch中的catch块是可以声明标识符的。但是他们以一种类似let声明的方式被声明在catch子句的块级作用域中，因此他们既不能在catch块之外访问，也不能被catch块中的其他声明覆盖。

##### 6.5.1.6 条件化声明中的重写

“条件化声明”允许在函数或全局块中使用if语句来有条件地向标识符绑定值。由于只有var声明和（内嵌的）具名函数声明是处于函数作用域的，因此它（即，有条件地初始绑定）的“条件子句”只能使var和具名函数的声明在当前函数（或全局作用域）中重写标识符，而不能用在let/const/class声明的名字中。

##### 6.5.1.7 运算优先级与引用的暂存

赋值是典型的可用于重写的运算符，但是赋值运算的优先级很低，例如，它远远低于属性存取运算。

对于又结合（即“关联性”从右至左）的操作符来说，在统计操作符中，运算数是优先供右侧运算符使用的。

#### 6.5.2 原型重写

在JavaScript中，我们无法保证对象与其构造器“必然”存在某种相似性。然而，这样（至少在代码的字面语义上）也就违背了“面向对象系统”的基本原则。

#### 6.5.3 构造器重写

##### 6.5.3.1 重写Object()

所谓“重写Object()”事实上只会影响到显式地引用Object这个标识符（例如：new、instanceof或函数调用运算），JavaScript引擎在内部处理时既不直接使用（作为global对象成员的）Object这个标识符，也不直接使用Object.prototype这个属性。