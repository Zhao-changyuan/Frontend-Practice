### 6.1 概述

程序最终可以被表达为数据和逻辑（即结构和算法）两个方面，命令式和说明式（以及函数式）语法是从程序的这两个本质方面来进行分类的。借鉴自然语言的体系，所谓语言，是应当包括“语法、语义和语用”三个方面的。具体在计算机体系中实现某种语言时，如果在语言陈述是无法确定而必须在计算机执行时才能确定这三者之间的关系，我们称改语言是动态语义的（反之称为静态语义的）。

#### 6.1.1 动态数据类型的起源

SNOBOL APL

#### 6.1.2 动态执行系统



#### 6.1.3 脚本系统的起源



#### 6.1.4 脚本只是表现形式

### 6.2 动态类型：对象与值类型之间的转换

JavaScript中存在两套类型系统，其一是基础类型系统（Base types），是由typeof运算来检测的按照约定，该类型系统包括7中类型（undefined、number、boolean、string、symbol、function和object）；其二是对象类型系统（Object types），对象类型系统是“对象基础类型（object）”中的一个分支。

#### 6.2.1 包装类：面向对象的妥协

在值类型数据经过“包装类”包装后得到来的对象与原数据将并不再是同一数据，只是二者具有等同的值而已。

##### 6.2.1.1 显式创建

从语言的实现上来说，这与传统语言中的“类型强制转换”完全不同：强制类型转换是在同一数据（相同内存地址的不同引用）的基础上进行，但上述语法将创建一个新的数据。

##### 6.2.1.2 显示包装

JavaScript内建的Object()类支持显示地将boolean、number、string和symbol四种值类型包装成对应的对象，这一语法在语义上解释为“基于值来创建等同的对象”。

##### 6.2.1.3 隐式包装的过程与检测方法

所谓值类型数据到对象的“隐式包装”，在已知的表达式运算中，其实总是由成员存取运算符触发的。

##### 6.2.1.4 包装值类型数据的必要性与问题

“值类型数据的方法调用”其实是被临时地隔离在另外一个对象中完成的。而同样的原因，无论我们如何修改这个新对象的成员，这种修改也不会影响到原来的值。

除了在属性存取等操作中需要一个包装过的对象之外，一些语句也有类似的需求。例如with语句总是视图打开一个对象的闭包，因此如果它作用的表达式返回一个值类型数据，那么with语句会通过包装类转换为对象并打开它的闭包。又例如（与此类似），for...in/of语句也会有这样的过程。

##### 6.2.1.5 其他字面量与相应的构造器

基础类型中还有object与function。这两种类型中的object基础类型，又有Object、Array与RegExp三种对象存在字面量风格的声明语法。

##### 6.2.1.6 函数特例

JavaScript作为函数式语言的重要特性——函数是第一型。JavaScript作为面向对象语言的重要特性——函数是对象。

#### 6.2.2 从对象到值

一个是隐式的对象到值的转换规则，另一个是valueOf()方法。

##### 6.2.2.1 对象到值的隐式转换规则

首先，null是对象。null作为对象总是转换为确定的三种值类型，即0、'null'和false。

并且，除了null之外的所有其他对象都必然转换为Boolean和true值。

对象到数字（number）和字符串（string）类型值的转换，是直接与该对象的valueOf()以及toString()方法相关的。即：

- 如果试图转换为字符串，则先尝试该对象的toString()方法，然后再尝试valueOf()方法；否则（必然是尝试转换为数字），
- 首先尝试调用valueOf()方法，再尝试调用toString()。

如果toString()或valueOf()返回非值的对象，则视为结果值无效，并按上述规则尝试另一个方法。如果两个方法都返回无效结果值，则抛出异常。

ECMAScript规范中，null值会被认为是这样的“（非对象的）原始值”，因此它可以作为toString()、valueOf()的返回值并进入后续的值运算。

##### 6.2.2.2 直接的值运算不受包装类的方法影响

由于值数据在参与值运算是并不需要“对象->值”的转换，因此也就不需要隐式地调用这些包装类的方法。

“在值运算中，加号（+）运算符优先于字符串连接”这一规则是在“+”号运算符两侧的都是值类型数据时才会生效的。

对值类型数据来说，在包装类原型上的toString()和valueOf()方法其实只会对（包装后对象的）显示方法调用有效。而并不会影响原始的值运算。

“类型转换分两个阶段”：其一是转换为原始值（to primitive value），其二是转换为尝试运算的值类型（to a number, or other）。

##### 6.2.2.3 什么是“转换的预期”

并没有文档来说明当“操作数/参数（x）”与运算符或函数界面上的设计不一致时，JavaScript的内核（也包括用户代码，或者具体语言引擎的运行期库）对这个x设定为哪种预期，并用该预期来决定上述调用顺序。

在“所有没有预期”的情况下，JavaScript优先使用“先valueOf()，后toString()”这一顺序。亦即是说，隐式地、默认地以“x.valueOf()”为优先。

在“对象到值的转换”时，默认“x.valueOf()”优先，而在“加号（+）”运算时，却默认字符串优先，二者正好不同。

##### 6.2.2.4 深入研究valueOf()方法

当x是对象时，默认情况下，x.valueOf()返回对象x自身，也就是.valueOf()返回对象，而不是“值类型数据”。

默认时许多引用类型数据并不能通过它的valueOf()方法来得到一个有效的值。隐式规则将会忽略这个值并尝试调用他们的toString()方法来得到一个字符串，以使之能尽量参与值运算。

在用户代码中修改系统内置的这些对象原型的valueOf()或toString()方法是可以做到的，但并不可取。

##### 6.2.2.5 布尔运算的特例

隐式转换规则中，“对值的预期”只有字符串和数字两种。因为除了null值之外，所有的对象都别直接视为true值，而与x.valueOf()或x.toString()的结果值无关。

“任何对象（包括布尔对象）”在进行布尔运算时，都是作为对象使用的；在进行数值或字符串运算时，都是按隐式规则使用valueOf()和toString()来转换为值使用的。

##### 6.2.2.6 符号Symbol.toPrimitive的效果

任何对象都可以通过Symbol.toPrimitive这个符号属性来改变它作为值的效果。一旦对象（或它的原型）声明过Symbol.toPrimitive属性，那么valueOf()与toString()在值运算的隐式转换中就无效了。

无论Symbol.toPrimitive属性的函数中返回的内容是否符合预期，只要它不是对象，那么该值金辉进入后续的运算。

#### 6.2.3 显示的转换

| 转换到   | object    | number    | boolean    | string    | symbol    |
| -------- | --------- | --------- | ---------- | --------- | --------- |
| 值或对象 | Object(x) | Number(x) | Boolean(x) | String(x) | Symbol(x) |

当使用这种函数调用而非他们的构造器形成的风格时，函数预期的值类型是确定的。

##### 6.2.3.1 显示转换的语法定义

上述放在语法上完全类似其他语言中的“类型强制转换”。

##### 6.2.3.2 对“转换预期”的显式表示

布尔值并不在上述所谓“预期的值”的范畴之内，因为布尔值总是按确定规则转换的。

##### 6.2.3.3 关于符号值的补充说明

