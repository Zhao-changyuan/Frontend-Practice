### 4.1 概述

对计算过程的认识不同产生了不同的计算模型，基于这些计算模型进行的分类，是计算机语言的主要分类方式之一。在这种分类法中，一般将语言分为四大类：命令式语言、函数式语言、逻辑式语言和面向对象程序设计语言。

结构化是命令式语言的主要实现手段。

#### 4.1.1 命令式语言

命令式语言的核心就在于“通过运算去改变内存（中的数据）”。

##### 4.1.1.1 存储与数据结构

由于命令式语言的实质是面向存储过程的编程，所以这里语言比其他语言更加关注存储的方式。

##### 4.1.1.2 结构化编程

是一种程序设计与开发的方法。

##### 4.1.1.3 结构化的疑难

结构体过渡弹性带来的不规范；抽象层次明显过低。

结构体的设计直接面向存储，正是这种过低的抽象层次使重用性大大降低。

#### 4.1.2 面向对象语言

面向对象所解决的主要问题：

- 开发人员必须面对数据的具体含义与关系。
- 脱离了具体使用环境与算法的结构缺乏通用性。
- 类型与逻辑僵化从而影响了业务逻辑的表达。

##### 4.1.2.1 结构化的延伸

“对象”无疑是比“结构体”更高层次的数据抽象/数据结构。

“结构化”的抽象是实体到结构体的直接映射，而“面向对象”的抽象则是实体到类、衍生关系到“继承性”的映射。由此可见，在面向对象系统中，对象基类及其继承树是对象数据抽象的表达，而这种抽象比机构化系统要复杂，因此也更高级且更难深入。

但同时，由于继承关系是现实系统中非常泛化的一种关系，也是人类社会中的一种普遍关系，因此能够帮助开发人员理解并应用。这是面向对象系统能够得以发展的根本。

##### 4.1.2.2 更高层次的抽象：接口

Web Services的基础之一，就是更加范义化的Interface。

##### 4.1.2.3 面向接口的编程方法

接口关注与行为的描述，而不是结构的描述。

#### 4.1.3 再论语言的分类

##### 4.1.3.1 对语言泛型的简化

JavaScript也是语言不同分类间相互作用的产物，它既同时是说明式和命令式语言，由兼具串行和并行语言的特征。

##### 4.1.3.2结构化的性质

#### 4.1.4 JavaScript的语源

### 4.2 基本的组织元素

除了箭头函数体之外，任何表达式在静态语义上都相当于一个值。

箭头函数体在表面上或语法上看来时表达式，但语义上却是语句的组织结构。

#### 4.2.1 标识符

- 标识符表明一个名字。
- 字面量表明由字面含义决定的值。
- 模板表明一个可计算结果的字符串值。

#### 4.2.2 表达式

表达式是0~1个运算符和至少1个操作数的有序书写，其中运算符可以是表单符号和关键字，二操作数可以是标识符、字面量、模板。

在JavaScript语言的概念中，表达式并不能独立于语句而存在，即使是单个表达式，也可以被称为表达式语句；即使是单个字面量的操作数，也可以称为字面量表达式语句。

##### 4.2.2.1 字面量

##### 4.2.2.2 初始器

#### 4.2.3 语句

标识符表达的是名字，而字面量和模板表达的是值。

所有的声明语句都是静态词法分析的，而非声明语句则是动态执行的。

#### 4.2.4 模块

模块作为组织元素，有它自己的产生、发展与被驱动的核心逻辑。

模块只有两个语义，其一是它包含了一个功能集合，并构建和对外宣称了这个集合的一个列表；其二是它用于从外部得到上述列表，并按当前（外部）环境的语义理解和使用该列表。

组织元素所能得到的最小元素集合是“名字+值”。因此模块对外宣称列表时也就只需要提供这两种元素的表示法即可。

#### 4.2.5 组织的原则

##### 4.2.5.1 原则一：抑制数据的可变性

数据的可变性称为状态。

编程的目的是使一个系统对外呈现可解释的信息。那么这个集合越简单，即数据的可变性越低，系统的解释成本就越低，编程的复杂度也就越低。

##### 4.2.5.2 原则二：最小逻辑和最大复用

JavaScript是一门既支持时序逻辑的语言，也是一门支持非时序逻辑的语言。

##### 4.2.5.3 原则三：语法在形式上的清晰与语义一致性

### 4.3 声明

JavaScript中的所有声明都针对标识符名字（IdentifierName），以表明该名字在三方面的性质：标识、值和确定性。

#### 4.3.1 声明名字

一些名字声明与绑定过程是同时发生并交由引擎在初始化环境时完成的。

#### 4.3.2 确定性

在JavaScript中，除const和namespace之外的所有语句声明的名字都是使用MutableBinding来创建的，因此我们总是可以重写标识符（变量名）。

然而函数表达式是字面量风格的值，而非语句。对于此，JavaScript约定，所有类型的函数表达式[插图]—在它作为独立语法元素（表达式的操作数）的环境中—的名字绑定使用ImmutableBinding，因此是不可置值的。

#### 4.3.3 顶层声明

### 4.4 语句与代码分块

#### 4.4.1 块

如果将一段代码理解为一个形式上的块（X），那么块X中出去简单语句（他们不构成自己的形式分块），其他部分也都是分块的。更确切地说：

- 简单语句是该块X（即statements，块中的语句行）的成员，而
- 其他分块是子级的块。

##### 4.4.1.1 简单语句

简单语句自身并不构成代码的形式分块。

##### 4.4.1.2 单值表达式

（字面量风格的）函数表达式是有自己的形式分块的，但它所在的复制表达式却没有。

##### 4.4.2 块与语句的语法结构

##### 4.4.2.1 语义上的代码分块

##### 4.4.2.2 分支逻辑中的代码分块

if语句自身并没有一个代码的形式分块。

##### 4.4.2.3 多重分支逻辑中的代码分块

switch语句中的expression表达式是执行在语句所在的块中（而非语句自有的块中）的，这与case或default分支不同。

##### 4.4.2.4 循环逻辑中的代码分块

只有在循环语句的循环条件中使用let/const声明了新名字时，才会存在代码分块。

var总是将变量声明在全局、模块或函数上下文中，而并不一定是当前块的作用域中。

如果ForBody中存在一个形式分块，那么该块的父级将指向for语句“所在的块”。而一旦使用了let/const，那么上述的父级就将指向for语句“自有的块”.

for语句会为每次循环创建一个新环境（iterationEnv）。由于每次循环都有一个新环境，因此能起到类似比表的效果：将x的引用保留到使用它的时候。

对于全部4种for语句来说，一旦使用带let/const声明的语法，那么：

■ 将总是存在一个自有的形式分块（loopEnv）用于处理循环表达式；并且，

■ 还将有一个形式分块（iterationEnv）来处理由迭代次数决定的循环体实例。

- ◆ 如果是for语句，在每次循环中将创建一个新的实例并将它的父级指向loopEnv。

- ◆ 如果是for...of、for...in，以及for await...of，则每次循环所创建实例的父级直接指向for语句“所在的块”。

在每次创建iterationEnv的新实例时，从上一个实例中复制所有let/const声明的变量值（而不是串接新旧环境）。

可见，“在ForBody”区中使用自有的形式分块“事实上带来了实现上的复杂性，以及更低的执行性能。所以除非是在setTimeout或Promise等并行机制中，通常不建议使用let/const来声明for语句的循环控制变量。

##### 4.4.2.5 异常中的代码分块

#### 4.4.3 块与声明语句

##### 4.4.3.1 只能在块中进行数据声明

while语句本身并没有形式分块，它是但语句（single statement）。

在JavaScript中，事实上只能在“形式分块”中进行数据声明。

##### 4.4.3.2 能同时声明块的声明语句

由于解析“声明”是在语法分析期发生的而非在执行期，因此事实上所有的声明语句都会导致JavaScript在语法分析期构建对应的名字表。

事实上某块的形式分块不是由import语句来创建的，而是由JavaScript引擎在装配所有模块的过程中创建的。

##### 4.4.3.3 声明语句与块的组织

更重要的是，JavaScript约定所有的声明都必须在语法分析期处理。

这意味着，JavaScript在语言设计方向上—尤其是在结构化方向上—更偏向于实现为静态语言。这其实是在为进一步的类型化做准备，并且只有在语言本身可以做静态语义分析的情况下，类型推导、预编译、执行期（JIT）优化等特性才可以方便地被加入JavaScript语言中。

#### 4.4.4 块与语句的值

##### 4.4.4.1 语句的执行状态

##### 4.4.4.2 语句无值

确实有一些语句是无值的，亦即是说，他们并不存在一个值的含义。其中包括所有声明语句、debugger语句、导入导出语句，以及空语句和空块语句。亦即是说，如果语句无值，那么把它放在一批语句的末端时，将不会影响该语句的结果。

##### 4.4.4.3 语句有值

ECMAScript约定，在所有逻辑语句或有形式分块的语句中，

- 子句或块返回无值时，逻辑语句本身将以undefined值返回。

并且，在循环语句和多重分支（switch）语句中，

- continue与break只改变语句的执行流程，对返回的值（Value）无影响。

#### 4.4.5 标签化语句与块

标签是独立的语法元素，因此可以与变量名或其他标识符名字重名。

### 4.5 组织形式分块的方法

形式分块与“块级别的”作用域对应—在代码文本中有一个物理上可见的形式分块，也就意味这JavaScript会为该分块创建作用域，称为词法作用域。

所谓变量作用域既是静态的，也是动态与静态之间的一座桥梁。

#### 4.5.1 词法作用域

代码分块代理的语法效果是信息隐藏。一般来说，所谓信息隐藏，指的是变量或成员的可见性问题。而这个可见性的区间（即“域”），被称为作用域（Scope）。 当这个域是通过静态词法分析而得出的时候，他就被称为词法作用域（Lexical Scope）。

形式分块与词法作用域在概念上所有不同：形式分块是物理上的、语法分析阶段就可以显示识别的，而词法作用域是逻辑上的、语句执行阶段动态创建的。因此形式分块对应的“词法作用域（的实例）可能是零个或多个”。

##### 4.5.1.1 不存在“级别1：表达式”

eval()其实是一个“（函数调用）表达式”，且又确实拥有一个独立的Eval词法环境，因此这种动态语言特性成了“唯一”在JavaScript中拥有表达式级别的词法作用域的特例。

##### 4.5.1.2 级别2：语句

我们说变量“存在于”某个语句级别的作用域，是指该变量被创建出来之后，在脱离了创造它的（单个或连续的）表达式之后，仍然可以在（且仅在）所在语句的作用域中被访问。

由于case子句没有“作用域”的含义，所指示的也仅是其后一个语句的起始位置，因此break子句事实上也并不对case子句起到语法效果。

##### 4.5.1.3 级别3：函数

当使用函数调用运算“()”时，JavaScript会为函数创建一个词法环境，以便将该函数的形式分块实例化为一个函数级的词法作用域。

函数与块语句作为一个形式分块在作用域上最大区别：函数级的做用户可以接受变量声明（varDecls），而语句级的作用域则不接受。

##### 4.5.1.4 级别4：模块

在非模块的环境中，顶层的var声明将被登记到全局。而在使用模块之后，由于模块有自己的词法作用域，因此这些声明将登记到模块中而不会“泄漏”到全局。

所有的导入都将使用所谓的“本地名字”在当前模块的词法作用域中登记，这些本地名字是只读和不可重新声明的，即使他们在源模块中是可以读写的变量。

在模块的词法作用域中访问this引用时，总是得到undefined值。

##### 4.5.1.5 级别5：全局

JavaScript的全局环境中一共存在三种用来登记名字的组件，包括词法作用域、变量作用域和全局对象（global）。所有的变量声明（varDelcs和functionDecls）的名字都在变量作用域中登记。（注：概念上来说是这样，但事实上，全局环境中的变量声明只作为名字登记（varNames），而实际的变量作用域组件与全局对象是共享同一个的）。而用户代码通过“访问不存在的变量名”导致的名字创建是作为全局对象的属性登记的。

全局词法作用域位于最外层的环境，它包括其他所有顶层的代码分块，以及他们对应的作用域，又或者他们更子级的块。用户代码运行在这个词法作用域中，但并不能通过全局对象（global）来访问到它。

#### 4.5.2 执行流程及其变更

“术语‘命令式’（imperative）来自命令和动作，这种计算模型就是基于基础机器的一系列动作。”

##### 4.5.2.1 级别1：可能的逃逸

##### 4.5.2.2 级别2：“break<label>;”等语法

- “break;”是循环和多重分支语句的break子句的语法。
- “break <balel>;”是标签化语句的break子句的语法。

##### 4.5.2.3 级别3：return子句

##### 4.5.2.4 级别4：动态模块与Promise中的流程控制

模块有自己的词法作用域，但没有相关流程控制语句。静态加载的模块并没有执行流程的概念，而对于动态模块来说，它的作用域将会“被包含与”一个Promise对此昂的执行环境中。

##### 4.5.2.5 级别5：throw语句

#### 4.5.3 词法作用域之间的相关性

结构化语言中的作用域是互不相交的，在这些作用域（及其对应的形式分块）之间只存在平行或嵌套两种相关性。

这种关系，就是通过前面所说的“词法作用域的级别”来控制的：

- 相同级别的词法作用域可以相互嵌套。
- 高级别的词法作用域能够包含低级别的词法作用域。
- 低级别的词法作用域不能包含高级别的词法作用域。由于不存在包含关系，因此语言实现时，一般处理成语法上的违例或者强制解释为平行关系。

#### 4.5.4 执行流程变更的内涵

### 4.6 层次结构程序设计

JavaScript的对象其实只是“属性包”。

#### 4.6.1 属性的可见性

所有属性都是公开的。

##### 4.6.1.1 属性在继承层次间的可见性

##### 4.6.1.2 属性在继承树（子树）间的可见性

#### 4.6.2 多态的逻辑

##### 4.6.2.1 super是对多态逻辑的绑定

“访问super”是一个动态的逻辑，而不是子类上的一个确定的、静态的成员

##### 4.6.2.2 super是一个作用域相关的绑定

super关键字是上下文受限的，并且是词法作用域（静态）绑定的。

#### 4.6.3 私有作用域的提出

### 4.7 历史遗产：变量作用域

变量作用域又叫变量的可见性。

早期有且仅有函数和全局环境支持变量作用域，而从ES6开始，模块也是支持变量作用域的。

在严格模式中，eval()会为它执行的代码同时创建词法作用域和变量作用域。

#### 4.7.1 变量作用域

对于ES6开始加入的模块来说，变量是声明在模块的变量作用域中的。

具名函数和var声明一样，所声明的名字都是变量名，登记在变量作用域中。

##### 4.7.1.1 级别3：函数（局部变量）

当在这些不支持变量作用域的语法元素——表达式或语句——中声明变量时，该变量的可见性会逸出到更外层的（surrounding scope）、更高级别的词法结构中去。

##### 4.7.1.2 级别4： 模块

模块的作用域总是严格模式的。

Node.js中的模块是使用函数模拟的。

##### 4.7.1.3 级别5：全局变量

从大型项目的角度看来，项目整体的品质比代码局部的灵活性更为重要。

#### 4.7.2 变量的特殊性与变量作用域的关系

##### 4.7.2.1 变量提升

“变量声明提升（Hoisting）”，它潜在的含义是：一个在当前作用域的任意位置用var声明的变量，其标识符会被“提升”到当前作用域或其外层的、最低级别的变量作用域（的开始处）。

与var语句声明的变量“在初始时置为undefined”不同，函数声明在初始时就绑定了函数体——具体的函数实例。因此函数声明不但是提升的，而且还是静态绑定的。

##### 4.7.2.2 变量动态声明

JavaScript的词法作用域是静态的，因此一旦它被实例化（Instantiation）就不能再增删。而变量作用域是动态的。

变量动态声明事实上只会发生在函数的变量作用域中。

##### 4.7.2.3 变量隐式声明（全局属性）

“全局属性”是直接在global对象的睡醒表中增删的一般属性，而“全局变量”——尽管也是作为全局属性来实现的，但是——还会被抄写到一个特殊内部表进行标记。

### 4.8 私有属性与私有字段的纷争

