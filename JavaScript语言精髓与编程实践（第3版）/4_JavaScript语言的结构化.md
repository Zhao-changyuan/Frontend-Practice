### 4.1 概述

对计算过程的认识不同产生了不同的计算模型，基于这些计算模型进行的分类，是计算机语言的主要分类方式之一。在这种分类法中，一般将语言分为四大类：命令式语言、函数式语言、逻辑式语言和面向对象程序设计语言。

结构化是命令式语言的主要实现手段。

#### 4.1.1 命令式语言

命令式语言的核心就在于“通过运算去改变内存（中的数据）”。

##### 4.1.1.1 存储与数据结构

由于命令式语言的实质是面向存储过程的编程，所以这里语言比其他语言更加关注存储的方式。

##### 4.1.1.2 结构化编程

是一种程序设计与开发的方法。

##### 4.1.1.3 结构化的疑难

结构体过渡弹性带来的不规范；抽象层次明显过低。

结构体的设计直接面向存储，正是这种过低的抽象层次使重用性大大降低。

#### 4.1.2 面向对象语言

面向对象所解决的主要问题：

- 开发人员必须面对数据的具体含义与关系。
- 脱离了具体使用环境与算法的结构缺乏通用性。
- 类型与逻辑僵化从而影响了业务逻辑的表达。

##### 4.1.2.1 结构化的延伸

“对象”无疑是比“结构体”更高层次的数据抽象/数据结构。

“结构化”的抽象是实体到结构体的直接映射，而“面向对象”的抽象则是实体到类、衍生关系到“继承性”的映射。由此可见，在面向对象系统中，对象基类及其继承树是对象数据抽象的表达，而这种抽象比机构化系统要复杂，因此也更高级且更难深入。

但同时，由于继承关系是现实系统中非常泛化的一种关系，也是人类社会中的一种普遍关系，因此能够帮助开发人员理解并应用。这是面向对象系统能够得以发展的根本。

##### 4.1.2.2 更高层次的抽象：接口

Web Services的基础之一，就是更加范义化的Interface。

##### 4.1.2.3 面向接口的编程方法

接口关注与行为的描述，而不是结构的描述。

#### 4.1.3 再论语言的分类

##### 4.1.3.1 对语言泛型的简化

JavaScript也是语言不同分类间相互作用的产物，它既同时是说明式和命令式语言，由兼具串行和并行语言的特征。

##### 4.1.3.2结构化的性质

#### 4.1.4 JavaScript的语源

### 4.2 基本的组织元素

除了箭头函数体之外，任何表达式在静态语义上都相当于一个值。

箭头函数体在表面上或语法上看来时表达式，但语义上却是语句的组织结构。

#### 4.2.1 标识符

- 标识符表明一个名字。
- 字面量表明由字面含义决定的值。
- 模板表明一个可计算结果的字符串值。

#### 4.2.2 表达式

表达式是0~1个运算符和至少1个操作数的有序书写，其中运算符可以是表单符号和关键字，二操作数可以是标识符、字面量、模板。

在JavaScript语言的概念中，表达式并不能独立于语句而存在，即使是单个表达式，也可以被称为表达式语句；即使是单个字面量的操作数，也可以称为字面量表达式语句。

##### 4.2.2.1 字面量

##### 4.2.2.2 初始器

#### 4.2.3 语句

标识符表达的是名字，而字面量和模板表达的是值。

所有的声明语句都是静态词法分析的，而非声明语句则是动态执行的。

#### 4.2.4 模块

模块作为组织元素，有它自己的产生、发展与被驱动的核心逻辑。

模块只有两个语义，其一是它包含了一个功能集合，并构建和对外宣称了这个集合的一个列表；其二是它用于从外部得到上述列表，并按当前（外部）环境的语义理解和使用该列表。

组织元素所能得到的最小元素集合是“名字+值”。因此模块对外宣称列表时也就只需要提供这两种元素的表示法即可。

#### 4.2.5 组织的原则

##### 4.2.5.1 原则一：抑制数据的可变性

数据的可变性称为状态。

编程的目的是使一个系统对外呈现可解释的信息。那么这个集合越简单，即数据的可变性越低，系统的解释成本就越低，编程的复杂度也就越低。

##### 4.2.5.2 原则二：最小逻辑和最大复用

JavaScript是一门既支持时序逻辑的语言，也是一门支持非时序逻辑的语言。

##### 4.2.5.3 原则三：语法在形式上的清晰与语义一致性

### 4.3 声明

JavaScript中的所有声明都针对标识符名字（IdentifierName），以表明该名字在三方面的性质：标识、值和确定性。

#### 4.3.1 声明名字

一些名字声明与绑定过程是同时发生并交由引擎在初始化环境时完成的。

#### 4.3.2 确定性

在JavaScript中，除const和namespace之外的所有语句声明的名字都是使用MutableBinding来创建的，因此我们总是可以重写标识符（变量名）。

然而函数表达式是字面量风格的值，而非语句。对于此，JavaScript约定，所有类型的函数表达式[插图]—在它作为独立语法元素（表达式的操作数）的环境中—的名字绑定使用ImmutableBinding，因此是不可置值的。

#### 4.3.3 顶层声明

### 4.4 语句与代码分块

#### 4.4.1 块

如果将一段代码理解为一个形式上的块（X），那么块X中出去简单语句（他们不构成自己的形式分块），其他部分也都是分块的。更确切地说：

- 简单语句是该块X（即statements，块中的语句行）的成员，而
- 其他分块是子级的块。

##### 4.4.1.1 简单语句

简单语句自身并不构成代码的形式分块。

##### 4.4.1.2 单值表达式

（字面量风格的）函数表达式是有自己的形式分块的，但它所在的复制表达式却没有。

##### 4.4.2 块与语句的语法结构

##### 4.4.2.1 语义上的代码分块

##### 4.4.2.2 分支逻辑中的代码分块

if语句自身并没有一个代码的形式分块。

##### 4.4.2.3 多重分支逻辑中的代码分块

switch语句中的expression表达式是执行在语句所在的块中（而非语句自有的块中）的，这与case或default分支不同。

##### 4.4.2.4 循环逻辑中的代码分块

只有在循环语句的循环条件中使用let/const声明了新名字时，才会存在代码分块。

var总是将变量声明在全局、模块或函数上下文中，而并不一定是当前块的作用域中。

如果ForBody中存在一个形式分块，那么该块的父级将指向for语句“所在的块”。而一旦使用了let/const，那么上述的父级就将指向for语句“自有的块”.

for语句会为每次循环创建一个新环境（iterationEnv）。由于每次循环都有一个新环境，因此能起到类似比表的效果：将x的引用保留到使用它的时候。

对于全部4种for语句来说，一旦使用带let/const声明的语法，那么：

■ 将总是存在一个自有的形式分块（loopEnv）用于处理循环表达式；并且，

■ 还将有一个形式分块（iterationEnv）来处理由迭代次数决定的循环体实例。

- ◆ 如果是for语句，在每次循环中将创建一个新的实例并将它的父级指向loopEnv。

- ◆ 如果是for...of、for...in，以及for await...of，则每次循环所创建实例的父级直接指向for语句“所在的块”。

在每次创建iterationEnv的新实例时，从上一个实例中复制所有let/const声明的变量值（而不是串接新旧环境）。

可见，“在ForBody”区中使用自有的形式分块“事实上带来了实现上的复杂性，以及更低的执行性能。所以除非是在setTimeout或Promise等并行机制中，通常不建议使用let/const来声明for语句的循环控制变量。

##### 4.4.2.5 异常中的代码分块

#### 4.4.3 块与声明语句

##### 4.4.3.1 只能在块中进行数据声明

while语句本身并没有形式分块，它是但语句（single statement）。

在JavaScript中，事实上只能在“形式分块”中进行数据声明。

##### 4.4.3.2 能同时声明块的声明语句

由于解析“声明”是在语法分析期发生的而非在执行期，因此事实上所有的声明语句都会导致JavaScript在语法分析期构建对应的名字表。

事实上某块的形式分块不是由import语句来创建的，而是由JavaScript引擎在装配所有模块的过程中创建的。

##### 4.4.3.3 声明语句与块的组织

更重要的是，JavaScript约定所有的声明都必须在语法分析期处理。

这意味着，JavaScript在语言设计方向上—尤其是在结构化方向上—更偏向于实现为静态语言。这其实是在为进一步的类型化做准备，并且只有在语言本身可以做静态语义分析的情况下，类型推导、预编译、执行期（JIT）优化等特性才可以方便地被加入JavaScript语言中。

#### 4.4.4 块与语句的值

##### 4.4.4.1 语句的执行状态

##### 4.4.4.2 语句无值

确实有一些语句是无值的，亦即是说，他们并不存在一个值的含义。其中包括所有声明语句、debugger语句、导入导出语句，以及空语句和空块语句。亦即是说，如果语句无值，那么把它放在一批语句的末端时，将不会影响该语句的结果。

##### 4.4.4.3 语句有值

ECMAScript约定，在所有逻辑语句或有形式分块的语句中，

- 子句或块返回无值时，逻辑语句本身将以undefined值返回。

并且，在循环语句和多重分支（switch）语句中，

- continue与break只改变语句的执行流程，对返回的值（Value）无影响。

#### 4.4.5 标签化语句与块

标签是独立的语法元素，因此可以与变量名或其他标识符名字重名。