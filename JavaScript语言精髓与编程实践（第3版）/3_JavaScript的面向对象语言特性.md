基于类的语言和程序设计技术也称为面向对象。

### 3.1 面向对象编程的语法概要

正则表达式字面量必须写在同一行。

#### 3.1.1 对象声明与实例创建

##### 3.1.1.1 使用构造器创建对象实例

语法如下：

```javascript
obj = new Constructor; // 和下面一行是等义的
obj = new Constructor();
obj = new Constructor(arg1[, arg2, ...]);
```

JavaScript将在构造器函数执行过程中传入new运算所产生的实例，并将该实例作为this对象引用传入。

也可以只将构造器作为普通函数来使用，例如下面的代码：

```javascript
function foo() {
    var data = this;
    return {};
}
obj = new foo();
```

在这里，最终obj也会被赋值为一个对象。但它并不是由new运算产生的对象实例，而是foo()函数中返回的对象字面量——注意，使用这种方法的时候，只能返回一个引用类型（对象、函数等），而不能是值类型数据——例如不能是true、'abc'之类。当用户试图返回值类型数据时，脚本引擎会忽略掉他们，仍然使用原来的this引用。

##### 3.1.1.2 声明对象字面量

##### 3.1.1.3 数组及其字面量

在数据结构的本质上并不具有某些多维数组的特性。

也可以使用数值字符串作为下标来访问数组成员，但这时在语义上却有所不同。这种情况下是将数组作为对象来进行“名-值”存取的。JavaScript中的数组既是下标存取的索引数组，也是支持属性存取的关联数组。

可迭代的对象不一定都是数组。

##### 3.1.1.4 正则表达式及其字面量

引用匹配`\nn`指在一个正则表达式中复用已通过“匹配分组”获取的、文本中的子字符序列。它的指定格式与“八进制ASCII字符”是冲突的。当发生歧义时，优先理解为“获取匹配”；若找不到足够的匹配个数，则理解为“八进制ASCII字符”。

##### 3.1.1.5 在对象声明中使用属性存取器

#### 3.1.2 使用类继承体系

所谓类继承，其实也是传统原型继承模式的一种表现方式。

##### 3.1.2.1 声明类和继承关系

下面三个声明在语义上是等价的：

```javascript
// 最简单的类声明
class MyObject {}

// 等价于（采用构造函数声明风格）
function MyObject() {}

// 等价于（采用变量声明风格）
var MyObject = new Function;
```

用extends声明的parentClass是一个表达式（的结果值），因此这事实上是说，该表达式将运行在严格模式中。

##### 3.1.2.2 声明属性

使用函数作为构造器时需要通过原型来声明对象实例的属性。

##### 3.1.2.3 调用父类构造方法

在默认情况下使用super()时，将会默认传入当前所构造的实例作为父类可以访问的this引用。

在使用this之前，总是需要先显式地调用super()以便在当前构造方法中获得this实例。

##### 3.1.2.4 调用父类方法

在使用super.XXX调用父类方法时也会隐式第传入当前的this引用，这与在构造器中调用super()时是一致的。

##### 3.1.2.5 类成员（类静态成员）

事实上，类静态成员也可以直接声明为“类/构造器函数”的成员。除了不能使用super之外（this当然也没有绑定到类），并没有特别的不同。

#### 3.1.3 对象成员

JavaScript中的对象是“属性包”，属性即所谓的对象成员。

对象成员可以是自有的（own properties），也可以是继承的（inherited properties）。所谓继承的，是指对象的父类或祖先类原型（即该对象的原型链上）具有该成员；子类对象可以用相同名字重新声明该成员，这称为覆盖（override）或重写（overwirte）。

##### 3.1.3.1 成员的列举，以及可列举性

数组的.length属性是隐藏的。

对于for...in语法来说，它所列举的成员名的顺序是不可依赖的。通常，一个对象的成员的插入不是有序的，那么它的for...in列举也就不是有序的。

在JavaScript中，任何类型的值都可以成为对象属性而并没有办法来辨识他们。也就是说，在JavaScript中，我们不能从成员的类型上准确了解设计者的原始意图。

##### 3.1.3.2 对象及其成员的检查

JavaScript使用in运算来检查对象是否具有某个成员（包括显示的或隐式的，也包括符号作为键名的属性等）。

这种运算也用来检测环境兼容性

我们不能通过typeof运算来检测属性是否存在。正式由于这个远哥，在Web浏览器中，DOM的约定是“如果一个属性没有初值，则应该将其置为null”。

instanceof运算符将会检测类的继承关系。

##### 3.1.3.3 值的存取

对于一些不满足标识符命名规则的属性，只能使用“[]”运算符。

##### 3.2.3.4 成员的删除

可以使用delete运算符来删除一个对象的指定属性，不过该运算符不能用于删除：

- 用var/let/const声明的变量与常量
- 直接继承自原型的成员。

delete运算本质上是用于删除实例的自有属性表中的描述符的。

##### 3.1.3.5 方法的调用

事实上，JavaScript中的方法调用，就是指”取得对象的成员，并执行函数调用运算“。

#### 3.1.4 使用对象自身

##### 3.1.4.1 与基础类型数据之间的运算

对象可以直接与其他基础类型的数据进行运算

##### 3.1.4.2 默认对象的指定

#### 3.1.5 符号

从语言设计的角度来说，符号是用来声明系统中的唯一值的。对象在系统中也有着类似的唯一性，但对象是引用类型，而符号是值类型。

##### 3.1.5.1 列举符号属性

唯一能有效列巨额符号属性的方法时Object.getOwnPropertySymbols()，它总是可以取得一个对象的全部的、自有的符号属性列表。

##### 3.1.5.2 改变对象内部行为

处于JavaScript对内部行为的约定，所有对象的行为都受到一些“与内部行为相关的”符号属性的影响。与内部行为相关的部分符号属性如下表：

| 符号               | 影响的语法元素对象行为      | 类型     |
| ------------------ | --------------------------- | -------- |
| Symbol.hasInstance | object instanceof Class     | function |
| Symbol.iterator    | for...of                    | function |
| Symbol.unscopables | with (object) { ... }       | object   |
| Symbol.toPrimitive | Object.prototype.valueOf()  | function |
| Symbol.toStringTag | Object.prototype.toString() | string   |

##### 3.2.5.3 全局符号表

Symbol在全局建立了一个“符号名-符号”的对照表。

### 3.2 JavaScript的原型链继承

JavaScript使用了原型继承来实现对象系统，并给予原型继承实现了具备类继承特征的对象系统。

#### 3.2.1 空（null）与空白对象（empty）

"空白对象"是整个原型继承体系的根基。

在JavaScript中，“空（null）”是作为一个保留字存在的，代表一个“属于对象类型的空值”。由于它不创建自Object()构造器或其子类，因此instanceof 运算会返回false.

空白对象（empty object, 也称为裸对象），是一个标准的、通过Object()构造的对象实例。

##### 3.2.1.1 空白对象是所有对象的基础

Object()构造器的原型就是一个空白对象。

原型的含义是指：如果构造器（Ojbect）有一个原型对象（Ojbect.prototype），则由该构造器创建的实例（obj）都必然复制自该原型对象。

##### 3.2.1.2 构造复制？写时复制？还是读遍历？

写复制，它的内存区总是写时复制的。这种机制先指明obj1和obj2与原型的应用关系，如下图

![image-20210106164122253](assets/image-20210106164122253.png)

系统将这种应用关系理解为“obj1和obj2等同于他们的原型”，那么在读取的时候只需要顺着指示去读原型即可。接下来，当需要写对象（例如obj2）的属性时，我们就复制一个原型的映象出来，并使用以后的操作指向该映象就行。这大致就变成了如下图：

![image-20210106164347734](assets/image-20210106164347734.png)

JavaScript采用了第三种方法：把写复制的粒度从整个原型编程了成员。这种特点是：仅当写某个实例的成员时，才将成员的信息复制到实例映象中（这一行为现在被标准化为：“创建同名属性并赋值以默认性质”）。这时对象实例都需要维护一张成员列表。这张成员列表指向在obj中发生了修改的成员名、值与类型，称为对象的自有属性表（own properties）。这张表是否与原型一直并不重要，只需要遵循以下两条规则：

- 规则1：保证优先读取对象的最优属性表。
- 规则2：如果在上述自有属性表中没有指定属性，则尝试遍历对象的整个原型链，知道原型为空（null）或找到该属性。

而且在为某个属性置值时，本质上就是在这个自有属性表中创建一项，以覆盖原型汇总同名的属性。

存取实例中的属性，比存取原型中的属性的效率要高。

所谓“空白对象（empty object）”，是指在它的原型链上的所有自有属性表都为空的对象。而所谓“原型链（prototype chain）”，就是对象所有的父类和祖先类的原型所形成的、可上溯访问的链表。

##### 3.2.1.3 构造过程：从函数到构造器

其实函数首先只是函数，尽管它有一个prototype成员。在默认情况向，所有函数的这个成员总是一个指向标准Object()构造器的实例——空白对象，不过该实例创建后，这个空白对象的constructor属性总是先被赋值为当前函数。如下图：

![image-20210106173754867](assets/image-20210106173754867.png)

MyObject.prototype其实与一个用new Object()创建的空白对象并没有本质却别，然而当函数有了prototype这个属性之后，他就变成一个“构造器”。

函数与构造器并没有明显的界限，唯一的区别只在于原型prototype属性是不是一个有意义的值。

##### 3.2.1.4 内置属性与方法

JavaScript对象实例本身并没有什么特别的性质。对象的行为来源于引擎对原型以及对属性表的理解，例如所谓的“空白对象”只不过是下面这样一个结构：

- “原型”指向Object.prototype。
- “属性表”指向一个空表。

更进一步的推论是：所有“实例”之所以具有对象的某些属性（以及相关的对象特征），是因为他们的共同原型Object.prototype具有这些属性（继承自Object.prototype）。

##### 3.2.1.5 原型为null：“更加空白”的对象

原型为null是原型继承中的特例，他有两种情况：其一，Constructor.prototype值为null；其二，Object.getPrototypeOf(Obj)值为null，这样的对象实例是一个只有一级（没有原型链）的属性包——只有一个自有属性表。比起空白对象（empty object），它“更加空白”——连Object类的内置属性也没有继承。

当一个函数作为构造器使用，且它的prototype属性为null值时（或prototype属性为任何非对象值），这个函数也是能创建出实例的。但实质上这个实例是直接通过new Object()创建的。

Object.setPrototypeOf()方法不接受对象和null之外的其他值。

#### 3.2.2 原型链的维护

在原型链继承继承中，“类”即是创建对象的构造函数。这里所谓的“类”，是早期JavaScript为了描述“对象（或实例）与创建它的构造器”之间的关系而引入的概念。

##### 3.2.2.1 外部原型链与constructor属性

在ES6以前的JavaScript中，需要用户代码来维护一个外部原型链，也称之为“构造器原型链”。

##### 3.2.2.2 使用内部原型链

ECMAScript约定对象实例必须在内部持有该对象的原型。并且，ECMAScript还进一步规范了存取这个内部原型的标准方法，这就是Object.getPrototypeOf()和Object.setPrototypeOf()。

Object.setPrototypeOf()用于重写内部原型，以切断对象与它的构造器或类之间的关系，或者使对象实例“变成”基于其他原型，从而得到新的内部原型链。

#### 3.2.3 原型继承的实质

修改原型是JavaScript中最常用的构建对象系统的方法，它的好处是可以在实例构造之后“动态地”影响到这些实例。也就是说，对象实例的特性不但可以在new运算中通过“构造”来得到，也可以在此后通过“原型修改”来持续获得。

JavaScript原型继承的实质便是对原型修改“效果的传递”。它基于一下两个事实：

- 原型：原型是一个对象。
- 原型链：在访问属性时，如果子类对象没有该属性，则将访问其原型的属性表。

##### 3.2.3.1 简单模型

##### 3.2.3.2 基于原型继承的设计方法

“原型修改”本质上是一种动态语言特性。因此这里正好就是动态语言与面向对象继承交汇的关键点。JavaScript也正是依赖动态语言的特性（可以动态地修改成员）来实现原型构建模式的。这种模式代表一种所谓“从无到有（ex nihilo("from scratch")）”的过程。

在这里所谓“从无到有”是指：在理论上可以先构建一个“没有任何成员”的类属关系的继承系统，然后通过“不断地修改原型”，从而获得一个完整的对象系统。

##### 3.2.3.3 如何理解“继承来的成员”

从ES6开始，这一行为有了明确规范：重写操作被约定为针对自有属性表进行。因此重写的结果决定于写该属性时的性质设置，而不再继承自父类。

### 3.3 JavaScript的类继承

JavaScript的类继承系统仍然是基于原型的。

#### 3.3.1 类是静态的声明

因为子类依赖于父类的构造过程，所以子类必然晚于父类构造。

类是静态的声明，意味着类继承关系的构建过程也是静态的，是在语法分析期就决定了的。与此相关，这也就意味着类声明语法中的方法会属性存取器只是（对象方法的）声明，而不是函数，因此也就不能在声明内直接引用他们的名字。

#### 3.3.2 super是全新的语法元素

super是与new类似的一个语法元素。

##### 3.3.2.1 super的作用

填补原型继承的一项众所周知的不足：无法有效调用父类方法。

super的使用基于一个前提：即明确地知道类继承关系。

##### 3.3.2.2 super指向什么

事实上，不同地方的super的语义并不相同，super作为语法关键字的一个附加效果：

super.xxx作为方法调用时，将会隐式地传入当前方法中的this对象。 

##### 3.3.2.3 super对一般属性的意义

super是基于声明方法时所在的对象或类来动态计算的，因而与当前调用时传入的this引用无关。

##### 3.3.2.4 super在两种继承关系中的矛盾

##### 3.3.2.5 super的动态计算过程

JavaScript中的每一个方法都有一个名为[[HomeObject]]的内部槽（Internal slots），用来在方法执行过程中找到对应的super。

它用于保存一个在语法分析阶段确定的、声明方法时所基于的对象（对于独享方法来说是AClass.prototype，对类静态方法来说则是AClass）。至于“找到super”，则是一个使用该[[HomeObject]]内部槽进行动态计算的过程。

由于super是动态计算并与绑定给它的内部槽[[HomeObject]]相关的，所以也可以通过重置prototype的方式来影响super。

#### 3.3.3 类是用构造器（函数）来实现的

只要是类，就总是显式或隐式地存在一个对应的构造方法。因此在JavaScript中，类所谓标识符在实质上就是“一个引用了该构造方法的函数”。如下所示：

```javascript
class MyClass {
    constructor() {}
}
MyClass === MyClass.prototype.constructor // true
```

但类继承仍然与原型继承有着非常大的不同。

JavaScript实现类继承时并不通过动态过程来构造原型链，而是简单地执行重置了原型的原型。

并且它还会修改类的原型。

对于类来说，new运算将使用它的基类来构造实例。更准确地说，new运算将回溯它的继承链并使用顶端的原生构造器来构造实例。

在类的构造方法中，不能在调用super()之前使用this引用。

#### 3.3.4 父类的默认值与null值

如果你个类声明MyClass是有父类的，那么相当于MyObject.prototype这个对象是构造自ParentClass的一个实例。

### 3.4 JavaScript的对象系统

#### 3.4.1 封装与多态

##### 3.4.1.1 封装

JavaScript的原型继承模型是依赖“变量作用域”来实现封装特性的。

##### 3.4.1.2 多态

多态性表现在两个方面：类型的模糊与类型的确认（或识别）。

使用instanceof时，其实是在检测右边操作数的原型属性（aConstructor.prototype）的原型链，而不是这个操作数本身（例如不是aConstructor）的原型链，因此当试图将一个函数作为一般对象参与运算时，instanceof就失效了。而isPrototypeOf()可以在这种情况下检测两个函数间的继承关系。

##### 3.4.1.3 多态与方法继承

#### 3.4.2 属性

在本节中，“方法”是特指那些函数类型的属性的。

##### 3.4.2.1 方法

方法是函数类型的属性。

在项的自有属性表中维护的方法称为对象方法，而在Constructor.prototype这个对象上维护的方法，是那些用new Constructor()所创建实例的原型方法。原型方法是所有实例通过原型继承来共享使用的——相同父类的实例调用的原型方法是同一个函数。

如果一个方法“仅仅作为”函数被调用（而没有关联对象）的话，那么它的this会指向全局对象或undefined。

方法/函数中所关联的this引用，是在调用该函数时（在运行期）动态传入的。传入的this的总的规则有三项：

- 使用当前上下文中的this或函数已绑定的this；或，
- 在使用属性存取运算符（包括.和[]运算符）时将左操作数作为this传入，或
- 使用Function.call、Function.apply、Function.bind或Reflex.apply等，将指定参数传入以用来作为this引用。

当个函数在调用时得到的this值是undefined或null时，那么：

- 如果函数工作在严格模式下，则仍使用undefined或null值作为this；否则
- 将以全局作为this值。

**箭头函数使用“当前上下文中的this”。**

##### 3.4.2.2 事件

事件并非ECMAScript或JavaScript语言的一个组成部分。

#### 3.4.3 构造对象系统的方法

##### 3.4.3.1 类抄写

类抄写后来进一步发展为称为“混入（mixin）”的对象编程方法。

ES6之后的Object.assign()方法是对类抄写过程的一个复现。

类抄写有两个问题。第一个问题是以内存开销换取效率。

类抄写的第二个问题是系统不维护原型继承链。

总的来说，类抄写并没有利用原型继承的任何特性。

##### 3.4.3.2 原型继承

原型继承，它不但存在一些语言特性上的缺陷：

- 在维护构造器引用和外部原型链之间无法平衡；和
- 没有提供调用父类方法的机制。

并且还很显然是一个典型的、以时间换空间的解决方案：继承层次中临近的成员访问更快，二视图访问一个不存在的成员时耗时最久。

JavaScript原本就是为了一种轻量级、嵌入式的、以Web浏览器端为主的脚本语言而设计的，这种应用环境决定了它的空间占用是关键，而时间消耗则相对次要得多。

##### 3.4.3.3 类继承

类继承既是对原型继承的增强，也是一种再实现。

从纯粹概念的层面来讨论，“原型也是对象实例”是一个极为关键的性质，这是它与“类继承体系”在本质上的不同。

JavaScript中的类，本质上就是在描述对象；其extends声明，则是在描述继承关系。

使用类声明与原型继承还是有些不一样：

- 其一，类的实例是创建自基类的。
- 其二，类构造方法的调用顺序是逆向的。

类继承比原型继承更加强调类的设计过程，类是对象的描述者，并且这种描述是强加在对象（类创建的实例）之上的。

##### 3.4.3.4 直接创建对象

无论是经典的原型继承，还是通过class来声明的类继承，都会用new运算调用一次构造器函数。“构造”这一过程既包括对原型链的委会，也包括对新实例的修饰。

new运算的可替代性，让我们注意到一个事实：所谓原型继承，器本质只是“复制原型”，即，以原型为模板复制一个新的对象。

Object.create()只是避免使用构造器来设置新实例原型的一种方法，它没有了在构造器中修饰对象实例这一过程，但和class声明一样，在本质上仍然是原型继承。

##### 3.4.3.5 如何选择继承方式

类抄写与原型继承正好是互补的两种方案。

原型继承中的“写复制”机制决定了我们不能单纯地依赖原型继承。写复制机制在“引用类型”与“值类型”数据中的表现并不一致。具体来说，就是复制引用时，所有实例都将指向同一个引用——从语义上来将也的确应当如此。但我们也会有这样的需求：实例成员指向基于同一类型的不同实例的引用。

这种需求导致出现了Object.assign()这样的方法。并且在远程或跨进程传递对象的系统模型中，使用JSON.stringify()这类方法来序列化和反序列化对象，也成为现实的需求。这些方法除了“传递对象或其性质”之外，本质上也是在所见原型继承的层次，将对象性质尽可能几种在它的自有属性表中，从而访问更快，控制也更加方便灵活。

在稳定性和进化需求上兼备且平衡的系统构建模型，就目前可见的，就是类继承和类库了。

JavaScript在灵活多变的同时带来了一种混杂的程序设计语言学知识体系，其结果是易学难精，而且是越深入底层云容易感到混乱。

在继承方式的选择上，仍应择需而用：其一，在大型系统上必须采用类继承的思路，其继承关系的确定性和支持静态语法检测等特性，可以帮助开发者最终简化构建大型系统的开发和业务逻辑的实现，并提供足够的系统稳定性；其二，在小型结构或者体系的局部使用原型继承的思路，既可以有优美的实现和高效的性质，也可以更深入地理解JavaScript中混合不同语言特性的精髓。

#### 3.4.4 内置的对象系统

内置（Built-in）对象与原生（Native）对象的区别在于：前者是在引擎初始化阶段就被创建好的的对象，是后者的一个子集；而后者包括一些在运行过程中动态创建的对象。

理解Global()类 与global对象，是理解JavaScript内置对象系统的起点。

##### 3.4.4.1 早期规范（ES5之前）中的对象

Arguments确实存在一个“语义上”独立的构造器。

Arguments()的实例总是由引擎在函数调用时动态创建并添加在函数闭包中的，因此能在函数的执行代码中直接使用arguments这个标识符。

有且仅有一个对象不再global所代表的对象系统中，即不能由他们的类或子类创建，这就是null对象。这是因为JavaScript中的Null作为类型只有一个字面量形式的null值，并且这null值也是一个对象。

##### 3.4.4.2 集合对象

JavaScript的数组是异质、交错和稀疏的。

TypedArray不能改变长度。

Set集合中元素的键与值（key/value）是一样的。

##### 3.4.4.3 结构化数据对象

所有的TypedArray对象其实都是结构化的数据（Structured Data）,它们本身也都是基于ArrayBuffer()对象来实现的。如下图所示：

![image-20210108220225576](assets/image-20210108220225576.png)

ArrayBuffer()主要提供一种访问其他高级语言或引擎外部数据的方式，多数情况下它的实例会作为TypedArray来使用，但它并不是TypedArray基类。不能直接存取ArrayBuffer中的数据，需要使用TypedArray对象作为视图，或直接使用DataView()来创建视图。

通常情况下，外部系统可以将结构化数据走位一个数据块传给JavaScript，并提供一个ArrayBuffer()的接口，然后JavaScript就可以操作这个数据块而无须依赖外部系统的应用程序接口（API）了。

JSON.parse()的结果并不总是对象。因为JSON格式的数据既包括对象与数组，也包括number、string、boolean和null值。所以JSON.parse()可能返回这些值。

##### 3.4.4.4 反射对象

通过反射（Reflection）机制，可以访问、检测和修改对象的内部状态与行为。

Reflect对象用于“调用”对象的行为。与此不同，Proxy类从另一个角度来实现反射，它用于“改变”对象的行为。Proxy可以代理目标对象的全部行为，并通过助手对象handler上的陷阱来响应“在代理对象上发生的”指定行为。未定义陷阱的行为会被直接投射到目标对象。

--experimental-modules

模块名字空间对象（module namespace object）也被归为反射机制的一部分，一定程度上是因为它可以用于观察一个模块的内部情况，这与反射的定义是类似的。模块名字空间对象有两个含义，其一是指模块自身导出表，这定义在该模块的名为[[Namespace]]的内部槽中；其二是指使用

`import * as xxx from 'module-name';`

语法导入的对象xxx。这个对象xxx是真正用户可见的模块名字空间对象，并且也事实上是对[[Namespace]]的间接引用。

##### 3.4.4.5 其他

#### 3.4.5 特殊效果的继承

使用class声明的方式可以“派生引擎原生对象”并继承特殊效果，这对大多说类是有效的（除了与“包装类”相关的几种效果之外）。这是由于class声明实际上是使用基类来创建实例的。

### 3.5 可定制的对象属性

属性的性质也并不用于描述该属性的类型或作用，而主要用于描述一个属性之于这个集合的种种关系。这些关系有三种：Writable（可写）、Enumberable（可列举）和Configurable（可配置）。除此之外，一个属性本身还具有两种性质：Name/Value，即名字和值。

#### 3.5.1 属性描述符

##### 3.5.1.1 数据描述符

必须至少具有value或writable两种性质之一。

##### 3.5.1.2 存取描述符

带读写器的存取描述符（Accessor descriptor）与上述的数据描述符只能存在一种，而不可能同时存在。

必须至少具有get或set两种方法之一。

##### 3.5.1.3 隐式创建的描述符：字面量风格的对象或类声明

类静态成员会声明为类（AClass）的属性，而一般成员会声明为类的原型（AClass.prototype）的属性。

#### 3.5.2 定制对象属性

##### 3.5.2.1 给属性赋值

##### 3.5.2.2 使用属性描述符

在JavaScript中不能直接修改属性描述符的性质以影响源对象，这是因为属性描述符只是复制了对此昂属性的内部性质，而不是这些性质的直接引用。

- 属性的性质不可继承。

##### 3.5.2.3 取属性或属性列表

#### 3.5.3 属性表的状态

对象有一个内部属性[[Extensible]]用来影响其自有属性表的相关行为。

seal与freeze状态不是直接的状态值，二是基[[Extensible]]和效用属性（的性质）而计算出来的、动态的值。

对一个自有属性表为空的对象，使用preventExtensions(obj)将导致它同时密封和冻结。

存取属性并不受freeze装填的“置属性只读”的影响。

当父类（原型）冻结或指定属性只读，赋值运算会失效，但能用重新声明属性的方法达到与赋值运算相同的效果。

### 3.6 运行期侵入与元编程系统

#### 3.6.1 关于运行期侵入

最早被真正用于运行期侵入的是一个一直以来都未被规范的语法元素：对象的`__proto__`属性。

##### 3.6.1.1 运行期侵入的核心机制

对象在JavaScript内部被描述为具有一些内部槽的结构体，操作这个结构体的方法称为内部方法（internal methods），并基于此提供了处理对此昂各种行为的确定逻辑。

基本对象的内部槽有且仅有两个，分别是[[Prototype]]和[[Extensible]]。

函数对象也会多出两个内部槽[[Realm]]和[[ScriptOrModule]]。[[Realm]]是指这个函数对象所在的领域，而[[ScriptOrModule]]则指向初始化该函数的结构：脚本块、模块或null（例如它是动态创建的）。

##### 3.6.1.2 可被符号影响的行为

- Symbol.toStringTag，仅对原生的Object.prototype.toString方法有效。
- Symbol.toPrimitive，toPromitive指向的函数在需要将target对象转换为值数据的情况向就会被调用。
- Symbol.hasInstance，指向一个函数，在使用obj instanceof target这样的语法时，才会由引擎去访问：调用该函数且以它的返回值作为obj instanceof target运行的结果。
- Symbol.unscopables，指向一个对象，该对象的每一个属性指明是否从with闭包中强制排除对应的target.xxx属性。
- Symbol.isConcatSpreadable，是一个布尔值，仅当target是一个数组或类数组的集合（Collection对象），并且视图使用arr.concat来连接它是才有意义。注意这里的连结展开（ConcatSpreadable）与JavaScript运算符中的展开运算（SpreadableOperator）并不一样。其中连结展开只作用于arr.concat()方法，在数组连接时用于展开目标对象（target），整个过程是对目标对象的下标存取。
- Symbol.match、Symbol.replace、Symbol.search和Symbol.split，这4个符号都指向函数，如果目标对象使用了其中之一，那么会使（对应的）字符串操作受到相应的影响。
- Symbol.species，它指向一个构造器函数，主要影响JavaScript内部隐式创建对象的行为。

##### 3.6.1.3 内部方法与反射机制

Proxy这个侵入的路径看起来很好，但实力使用时却会有些问题。这有两个方面的原因。其一是因为部分JavaScript内部检测会绕过代理。其二，因为这些内部方法事实上也是相互调用的，进而带来了递归调用的可能。

在[[Set]]置值时，如果他需要创建或更新自有的属性描述符，会调用[[DefineOwnProperty]]来实现。而且在整个过程中[[GetOwnProperty]]会发生多次，包括检测当前对象（例如，proxy）是否有指定属性，以及检测目标对象（例如，receiver）、目标对象的原型等。

##### 3.6.1.4 侵入原型

Object()是JavaScript对象系统的基类，然而（仅对于Object.prototype）来说，不能重置它的原型。

处于同样的原因，JavaScript也将Object.prototype属性的性质置为不可写和不可重置。

所以对Object及其子类，只剩下一种侵入方法：扩展Object.prototype上的属性，从而影响所有以它为祖先的子类和子类实例。

事实上我们可以做的更多——只是这样的操作不能在Object.prototype上做罢了。比如入侵它的一个子类的原型，我们有机会再子类域基类之间插入一个代理，从而完全透明地侵入这个子类。

最后需要注意的是，直接替换Object.prototype并不是严格意义上的运行期侵入，因为这会导致替换前/后两种不同原型的对象实例。

#### 3.6.2 类类型与元类继承

运行期侵入只是元编程的冰山一角。事实上，深入立即语言机制，可以让我们在更多方面进行拓展，例如构建自己的对象系统或继承体系。

这里所说的类（Class），是指用class关键字声明的类，包括静态类和类表达式。

所谓元类（meta class），是指能产生类的类。

##### 3.6.2.1 原子

只考虑JavaScript的对象系统，它的原子——最小颗粒度的运算对象是“更加空白的对象”：

`var atom = Object.create(null)`

最小颗粒度的类应该是以atom为原型的类：

```javascript
var Atom = new Function;
Object.setPrototypeOf(Atom.prototype, null);
```

##### 3.6.2.2 元与元类

由于类是函数（构造器），因此所谓元类就必须是“能产生函数的函数”。

##### 3.6.2.3 类类型系统

##### 3.6.2.4 类类型的检查
