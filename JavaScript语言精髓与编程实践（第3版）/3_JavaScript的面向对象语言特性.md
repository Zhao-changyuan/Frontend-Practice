基于类的语言和程序设计技术也称为面向对象。

### 3.1 面向对象编程的语法概要

正则表达式字面量必须写在同一行。

#### 3.1.1 对象声明与实例创建

##### 3.1.1.1 使用构造器创建对象实例

语法如下：

```javascript
obj = new Constructor; // 和下面一行是等义的
obj = new Constructor();
obj = new Constructor(arg1[, arg2, ...]);
```

JavaScript将在构造器函数执行过程中传入new运算所产生的实例，并将该实例作为this对象引用传入。

也可以只将构造器作为普通函数来使用，例如下面的代码：

```javascript
function foo() {
    var data = this;
    return {};
}
obj = new foo();
```

在这里，最终obj也会被赋值为一个对象。但它并不是由new运算产生的对象实例，而是foo()函数中返回的对象字面量——注意，使用这种方法的时候，只能返回一个引用类型（对象、函数等），而不能是值类型数据——例如不能是true、'abc'之类。当用户试图返回值类型数据时，脚本引擎会忽略掉他们，仍然使用原来的this引用。

##### 3.1.1.2 声明对象字面量

##### 3.1.1.3 数组及其字面量

在数据结构的本质上并不具有某些多维数组的特性。

也可以使用数值字符串作为下标来访问数组成员，但这时在语义上却有所不同。这种情况下是将数组作为对象来进行“名-值”存取的。JavaScript中的数组既是下标存取的索引数组，也是支持属性存取的关联数组。

可迭代的对象不一定都是数组。

##### 3.1.1.4 正则表达式及其字面量

引用匹配`\nn`指在一个正则表达式中复用已通过“匹配分组”获取的、文本中的子字符序列。它的指定格式与“八进制ASCII字符”是冲突的。当发生歧义时，优先理解为“获取匹配”；若找不到足够的匹配个数，则理解为“八进制ASCII字符”。

##### 3.1.1.5 在对象声明中使用属性存取器

#### 3.1.2 使用类继承体系

所谓类继承，其实也是传统原型继承模式的一种表现方式。

##### 3.1.2.1 声明类和继承关系

下面三个声明在语义上是等价的：

```javascript
// 最简单的类声明
class MyObject {}

// 等价于（采用构造函数声明风格）
function MyObject() {}

// 等价于（采用变量声明风格）
var MyObject = new Function;
```

用extends声明的parentClass是一个表达式（的结果值），因此这事实上是说，该表达式将运行在严格模式中。

##### 3.1.2.2 声明属性

使用函数作为构造器时需要通过原型来声明对象实例的属性。

##### 3.1.2.3 调用父类构造方法

在默认情况下使用super()时，将会默认传入当前所构造的实例作为父类可以访问的this引用。

在使用this之前，总是需要先显式地调用super()以便在当前构造方法中获得this实例。

##### 3.1.2.4 调用父类方法

在使用super.XXX调用父类方法时也会隐式第传入当前的this引用，这与在构造器中调用super()时是一致的。

##### 3.1.2.5 类成员（类静态成员）

事实上，类静态成员也可以直接声明为“类/构造器函数”的成员。除了不能使用super之外（this当然也没有绑定到类），并没有特别的不同。

#### 3.1.3 对象成员

JavaScript中的对象是“属性包”，属性即所谓的对象成员。

对象成员可以是自有的（own properties），也可以是继承的（inherited properties）。所谓继承的，是指对象的父类或祖先类原型（即该对象的原型链上）具有该成员；子类对象可以用相同名字重新声明该成员，这称为覆盖（override）或重写（overwirte）。

##### 3.1.3.1 成员的列举，以及可列举性

数组的.length属性是隐藏的。

对于for...in语法来说，它所列举的成员名的顺序是不可依赖的。通常，一个对象的成员的插入不是有序的，那么它的for...in列举也就不是有序的。

在JavaScript中，任何类型的值都可以成为对象属性而并没有办法来辨识他们。也就是说，在JavaScript中，我们不能从成员的类型上准确了解设计者的原始意图。

##### 3.1.3.2 对象及其成员的检查

JavaScript使用in运算来检查对象是否具有某个成员（包括显示的或隐式的，也包括符号作为键名的属性等）。

这种运算也用来检测环境兼容性

我们不能通过typeof运算来检测属性是否存在。正式由于这个远哥，在Web浏览器中，DOM的约定是“如果一个属性没有初值，则应该将其置为null”。

instanceof运算符将会检测类的继承关系。

##### 3.1.3.3 值的存取

对于一些不满足标识符命名规则的属性，只能使用“[]”运算符。

##### 3.2.3.4 成员的删除

可以使用delete运算符来删除一个对象的指定属性，不过该运算符不能用于删除：

- 用var/let/const声明的变量与常量
- 直接继承自原型的成员。

delete运算本质上是用于删除实例的自有属性表中的描述符的。

##### 3.1.3.5 方法的调用

事实上，JavaScript中的方法调用，就是指”取得对象的成员，并执行函数调用运算“。

#### 3.1.4 使用对象自身

##### 3.1.4.1 与基础类型数据之间的运算

对象可以直接与其他基础类型的数据进行运算

##### 3.1.4.2 默认对象的指定

#### 3.1.5 符号

从语言设计的角度来说，符号是用来声明系统中的唯一值的。对象在系统中也有着类似的唯一性，但对象是引用类型，而符号是值类型。

##### 3.1.5.1 列举符号属性

唯一能有效列巨额符号属性的方法时Object.getOwnPropertySymbols()，它总是可以取得一个对象的全部的、自有的符号属性列表。

##### 3.1.5.2 改变对象内部行为

处于JavaScript对内部行为的约定，所有对象的行为都受到一些“与内部行为相关的”符号属性的影响。与内部行为相关的部分符号属性如下表：

| 符号               | 影响的语法元素对象行为      | 类型     |
| ------------------ | --------------------------- | -------- |
| Symbol.hasInstance | object instanceof Class     | function |
| Symbol.iterator    | for...of                    | function |
| Symbol.unscopables | with (object) { ... }       | object   |
| Symbol.toPrimitive | Object.prototype.valueOf()  | function |
| Symbol.toStringTag | Object.prototype.toString() | string   |

##### 3.2.5.3 全局符号表

Symbol在全局建立了一个“符号名-符号”的对照表。

### 3.2 JavaScript的原型链继承

JavaScript使用了原型继承来实现对象系统，并给予原型继承实现了具备类继承特征的对象系统。

#### 3.2.1 空（null）与空白对象（empty）

"空白对象"是整个原型继承体系的根基。

在JavaScript中，“空（null）”是作为一个保留字存在的，代表一个“属于对象类型的空值”。由于它不创建自Object()构造器或其子类，因此instanceof 运算会返回false.

空白对象（empty object, 也称为裸对象），是一个标准的、通过Object()构造的对象实例。

##### 3.2.1.1 空白对象是所有对象的基础

Object()构造器的原型就是一个空白对象。

原型的含义是指：如果构造器（Ojbect）有一个原型对象（Ojbect.prototype），则由该构造器创建的实例（obj）都必然复制自该原型对象。

##### 3.2.1.2 构造复制？写时复制？还是读遍历？

写复制，它的内存区总是写时复制的。这种机制先指明obj1和obj2与原型的应用关系，如下图

![image-20210106164122253](assets/image-20210106164122253.png)

系统将这种应用关系理解为“obj1和obj2等同于他们的原型”，那么在读取的时候只需要顺着指示去读原型即可。接下来，当需要写对象（例如obj2）的属性时，我们就复制一个原型的映象出来，并使用以后的操作指向该映象就行。这大致就变成了如下图：

![image-20210106164347734](assets/image-20210106164347734.png)

JavaScript采用了第三种方法：把写复制的粒度从整个原型编程了成员。这种特点是：仅当写某个实例的成员时，才将成员的信息复制到实例映象中（这一行为现在被标准化为：“创建同名属性并赋值以默认性质”）。这时对象实例都需要维护一张成员列表。这张成员列表指向在obj中发生了修改的成员名、值与类型，称为对象的自有属性表（own properties）。这张表是否与原型一直并不重要，只需要遵循以下两条规则：

- 规则1：保证优先读取对象的最优属性表。
- 规则2：如果在上述自有属性表中没有指定属性，则尝试遍历对象的整个原型链，知道原型为空（null）或找到该属性。

而且在为某个属性置值时，本质上就是在这个自有属性表中创建一项，以覆盖原型汇总同名的属性。

存取实例中的属性，比存取原型中的属性的效率要高。

所谓“空白对象（empty object）”，是指在它的原型链上的所有自有属性表都为空的对象。而所谓“原型链（prototype chain）”，就是对象所有的父类和祖先类的原型所形成的、可上溯访问的链表。

##### 3.2.1.3 构造过程：从函数到构造器

其实函数首先只是函数，尽管它有一个prototype成员。在默认情况向，所有函数的这个成员总是一个指向标准Object()构造器的实例——空白对象，不过该实例创建后，这个空白对象的constructor属性总是先被赋值为当前函数。如下图：

![image-20210106173754867](assets/image-20210106173754867.png)

MyObject.prototype其实与一个用new Object()创建的空白对象并没有本质却别，然而当函数有了prototype这个属性之后，他就变成一个“构造器”。

函数与构造器并没有明显的界限，唯一的区别只在于原型prototype属性是不是一个有意义的值。

##### 3.2.1.4 内置属性与方法

JavaScript对象实例本身并没有什么特别的性质。对象的行为来源于引擎对原型以及对属性表的理解，例如所谓的“空白对象”只不过是下面这样一个结构：

- “原型”指向Object.prototype。
- “属性表”指向一个空表。

更进一步的推论是：所有“实例”之所以具有对象的某些属性（以及相关的对象特征），是因为他们的共同原型Object.prototype具有这些属性（继承自Object.prototype）。

##### 3.2.1.5 原型为null：“更加空白”的对象

