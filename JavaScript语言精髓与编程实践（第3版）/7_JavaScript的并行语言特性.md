## 7.1 概述

JavaScript是一门支持并行计算的编程语言。

### 7.1.1 并行计算的思想

并行计算是非时序逻辑下的计算模型。真正的、绝对的并行计算模型中没有“时间”，也不需要考虑多个计算对象之间的时序依赖等问题。

#### 7.1.1.1 并行计算范型的抽象

并行逻辑可以层叠为时间复杂度为“1”的数。

#### 7.1.1.2 分布与并行逻辑

分布只是并行逻辑得以运行的现场。

#### 7.1.1.3 并发的讨论背景

在集中式的现场解决该并行问题的方法被称为并发，而这些并行逻辑就被称为并发单元。多处理器或多核被用来运行并发单元时，称为物理并发；而并发单元被运行与单个处理器或单核上面时，被称为逻辑并发。

通常含义的并发，指的就是“一个单位长度”的时间度量上，发生多个行为“例如任务”的能力，而无论这个行为是操作数据，还是操作逻辑。

所以并发不是并行，并发的讨论背景中有“时间”维度，而并行计算模型中是没有这一维度的。

**最佳实践：**优先使用并行，然后在考虑并发

就其本质来说，加入并发就意味着原本“不考虑时间维度”的场景不再有了，背离了并行的要义

#### 7.1.1.4 分支也可以不是时序逻辑

在“如果...那么...”的语义中，“那么”是预知的可行使行为，而“如果”只是条件。既然如此，假使我们可以“预知/预设”所有的可行使行为，则“如果”这一条件就没有任何“需要前置”的意义了。

在“预期的结果‘完备且就绪’”的前提下，分支也可以是非时序逻辑。

### 7.1.2 并行程序设计的历史

早期计算机的存储是几种的，算力也是几种的，这导致（在这样的基础条件下，）最早解决并行问题的方法——如前所诉的——就是并发。

#### 7.1.2.1 从“支持并行”到并行程序语言



#### 7.1.2.2 用并发思想处理数据的语言

在“数据集中”既成事实，即在所谓“共享存储”的场景下，目前采用的所有所谓“并行”的手段其本质都是并发编程技术。

#### 7.1.2.3 多数传统程序设计语言是“伪并行”的

语言有“并行特性”并不等于这门语言是“并行程序语言”。

#### 7.1.2.4 真正的并行：在语言层面无视时间

并行计算本质上的特点就是“非时序逻辑”。

如果语言可以陈述计算结果而不依赖计算过程，那么它必然是可并行的。

现今的并行设计语言都不约而同地选择了一个说明式语言作为基础范型，并逐渐添加一些适用于具体场景的，或面向特定问题的并行算法的语言机制。

### 7.1.3 并行语言特性在JavaScript中的历史

事件回调的本质其实就是“消息收发”，这也是一种在语言层面上实现并行特性的可选模型。

JavaScript对这样的并行语言特性的支持主要包括两部分,其一是用于支持Future并行模型的Promise，其二是执行环境中对执行栈的使用。

Promise本身并不具有“并行执行”的特性。

## 7.2 Promise的核心机制

任何一种方法都是立即得到promise对象的。

### 7.2.1 Promise的核心过程

#### 7.2.1.1 Promise的构造方法

当JavaScript引擎通过new运算来创建promise对象时，它事实上会在调用executor()之前就创建好一个新的promise对象的实例。

#### 7.2.1.2 需要清楚的事实：没有延时

Promise机制中并没有延时，也没有卑延时的行为，更没有对“时间”这个维度的控制。

所有promise对象都是在你需要时立即就生成的，只不过——重要的是——这些promise所代理的那个值/数据还没有“就绪（Ready）”。

#### 7.2.1.3 Then链

#### 7.2.1.4 Then链中promise2的置值逻辑

一个promise可能会被置入两种值之一（并且一旦置值就将不可变更，称为“终态”）。这两种值是指：

- 如果promise被成功resolve，则该值为有效值（value）。
- 如果promise被主动reject或resolve失败，则该值用于记录原因（reason）。

#### 7.2.1.5 Then链对值的传递以及.cath()处理

如果没有有效的响应函数，仍将产生新的promise2，并且它的resolve将以Then链中当前promise的值为值。

**始于promise，终于catch。**

### 7.2.2 Promise类与对象的基本应用

#### 7.2.2.1 Promise的其他类方法

#### 7.2.2.2 Promise.resolve()处理thenable对象的具体方法

在Promise.resolve(x)中“x是对象”的一个特例是：当x是promise对象时，将直接返回它。

当x是thenable对象时，Promise.resolve()方法将返回一个新的对象promise2，它将是Promise()的实例。而x.then()将被调用并且传入promise2的resolve和reject方法。

#### 7.2.2.3 promise对象的其他原型方法

promise对象最主要的原型方法——.catch()和.finally()试试上都是通过.then()来间接实现的。

使用.catch()方法，由其是Then链末端的.catch()仍然是安全和必要的。因为.then(onFulfilled, onRejected)中的onRejected句柄并不能捕获或响应到在onFulfilled句柄中发生的异常（以及其中返回的rejected promise）。

正确的处理方法时遵循“始于promise，终于catch”的原则。

.finally()在调用界面上并不接收任何传入参数。并且JavaScript也不处理在响应函数onFinally()中的任何返回值。

#### 7.2.2.4 未捕获异常的promise的检测

对于任何一个promise对象p来说，向p置值与调用p.then()是并行的过程，这意味着他们同时作为状态并以此为unhandledRejection的判断依据时，其结果是不确定的。

#### 7.2.2.5 特例：将响应函数置为非函数

在p.then(onFulfilled, onRejected)中，如果onFulfilled或onRejected传入非函数，则JavaScript将它们视同undefined处理。

### 7.2.3 Promise的子类

#### 7.2.3.1 由Promise()派生的子类

#### 7.2.3.2 thenable对象或其子类

### 7.2.4 执行逻辑

多个执行上下文可以运行在同一个执行域（Realm）中，这个Realm其实就指代了Global，它映射了一系列由引擎提供的原始组件。

#### 7.2.4.1 任务队列

调度宇哥PromiseJob与调度一个函数，并没有区别。

#### 7.2.4.2 执行栈

执行栈是用来确保多个可执行上下文可以按约定顺序顺次处理的另一个结构。任何情况下，这个所谓的“约定顺序”只有一项原则：

**当前栈顶的上下文，就是运行中的活动上下文。**

因此：

- 当一个新的上下文入栈时，那么新的上下文必然是活动。这证号对应于“在当前函数中调用新函数”，亦即是说，函数调用就是将目标函数的上下文入栈。与此相反<
- 当有一个并行行为（例如Promise的Reactions）出现时，该行为在概念上由于并行的而不能入栈（入栈就会激活它），因此需要通过EnqueueJob()过程将它作为一个PendingJob条件到任务队列（JobQueues）中。

当栈顶为空（即引擎在闲）时，从上诉队列中取出PendingJob来执行即可。

这个过程就是所谓的RunJobs()。

## 7.3 与其他语言特性的交集

### 7.3.1 与函数特性的交集：异步的函数

#### 7.3.1.1 异步函数的引入

长的Then链出错的可能会更高，且排错的代价通常也更大。异步函数就是用来解决这一问题的，它封装了“一组promise对象之间的时序性”，并最终“返回一个新的promise对象”。

#### 7.3.1.2 异步函数的值

异步数总是或返回一个promise对象。换个视角来看，该函数总是可以“先”返回上述的promise对象，而无须执行它的函数体。

#### 7.3.1.3 异步函数中的await

await会将它的操作数（例如x）处理为一个promise对象。

如果promise是rejected状态，那么await将会reject的原因（reason）作为错误抛出。而await爬出错误意味着将潜在地执行一个类似throw e的操作，其中e是任意值，并且可以被try...catch捕获。

#### 7.3.1.4 异步生成器函数

一般生成器函数与异步生成器函数获得值的方法是不同的。前者，即一般生成器函数通常使用同步过程直接从tor.next()中获得值（value），而后者必须通过promise对象Then链来异步地访问值。

#### 7.3.1.5 异步生成器函数中的await

严格来说，在异步生成器函数中，所谓“生成器”的部分只负责调度生成器对象（例如tor）的每一次tor.next()调用，并组装返回一个promise对象（例如p）；而函数体才是所谓“异步”的部分，负责让每一次的yield（产生值）以及其后的p.then()调用异步地发生于不同的过程中。

**JavaScript在异步生成器函数中yield，将会是一个隐式的yield after await。**

在异步生成器函数中，所有的tor.next()都将立即返回promise对象，但是由于他们的yield存在隐式的await，因此yield值的过程以及promise对象就绪该值的过程都是同步的。

#### 7.3.1.6 异步生成器函数与for await...of语句

除了使用的是Symbol.asyncIterator属性之外，for await...of语句与for...of语句在逻辑上并没有什么不同。

使用for await...of处理一个“（一般的）生成器对象或迭代器”时，迭代结果将先转换为promise对象。

### 7.3.2 与动态特性的交集

一定程度上来说，面向对象中的多态性也是对动态特性的一种补偿。

#### 7.3.2.1 await在语义上的特点

你可以将await视为在特定上下文（异步函数）中将Promise“转换为”它所代理数据的一种方式。

#### 7.3.2.2 resolve行为与类型模糊

在promise对象的resolve行为中也隐式第存在一个与await()语义类似的转换过程。这是因为用户代码是指上是在通过调用置值器函数resolve(x)来向promise对象的内部槽中填写值x。

#### 7.3.2.3 then方法的动态绑定

#### 7.3.2.4 通过接口识别的类型（thenable）

通常来讲，JavaScript引擎会假设thenable objects也代理了一个数据。

当x是thenable对象时，直接使用“await x”并不会去到x所代理的数据。

#### 7.3.2.5 通过动态创建函数来驱动异步特性

promise对象事实上由相同的方法产生（但可能是显示的或隐式的），因此何时调用他们的resolve/reject置值器，取决于个紫的创建者。例如：

`p = Promise.resolve(x)`

- 调用p这个promise对象的resolve置值器。而后者（resolve置值器）将检测x。
  - 如果x是值或一般对象，将直接置为对象p所代理的数据；否则
  - 是一个thenable对象（包括是一个Promise及其子类的对象），会调用x.then()来为p置值。

### 7.3.3 对结构化特性带来的冲击

#### 7.3.3.1 对执行逻辑的再造



#### 7.3.3.2 迟来的finally

#### 7.3.3.3 new Function()风格的异步函数创建

#### 7.3.3.4 异步方法与存取器

## 7.4 JavaScript中对并发的支持

一个高性能的并行系统的主要设计障碍在于应对公共资源的访问。

### 7.4.1 Agent、Agent Cluster及其工作机制

#### 7.4.1.1 工作线程机器环境

一个Agent记录指向一个执行线程，并包含一组用于指代引擎环境的信息：

- 一个执行上下文栈（包括一个当前活动的执行上下文的状态标记）。
- 一些执行上下文（由引擎为代码的每个执行结构创建）。
- 一些工作队列（用于存放上述上下文对应的“任务Job”）。

#### 7.4.1.2 线程及其调度

在ECMAScript规范中，用“执行线程”的概念隐藏了“线程（thread）”被真实操作系统调度所带来的这些特性。一个执行线程可以调度多个代理，但任何情况下只可能激活一个代理并执行其中的任务（Job）.

#### 7.4.1.3 与谁协商

ECMAScript对此没有任何约定。在具体环境中，应用开发者通常将一个簇规划为“主从结构（master-slaves）”：在概念上将所有参与者统称为“工作者（Worker，workers）”，并将其中代理所有协商权的唯一一个Worker——通常是这些Worker的创建者——称为“主工作者（Main worker，main）”。

#### 7.4.1.4 多线程的可计算环境

当使用Node.js中的worker_threads模块时，在主线程（MainThread，main）与工作线程（workers）之间是通过postMessage()方法和对'message'时间的响应来通信的。

#### 7.4.1.5 通过消息通信完成协商

### 7.4.2 SharedArrayBuffer

ECMAScript规范中所描述的SharedArrayBuffer是一种共享存储的具体实现。

### 7.4.3 Atomics

#### 7.4.3.1 锁

#### 7.4.3.2 置值：锁的状态切换

## 7.5 在分布式网路环境中的并行执行

### 7.5.1 分布式并行架构的实践

#### 7.5.1.1 N4C的背景

N4C架构是一个可控、可计算的通信集群架构。

#### 7.5.1.2 N4C的机构设计

#### 7.5.1.3 N4C架构的实现

### 7.5.2 构建一个集群环境



### 7.5.4 可参考的意义