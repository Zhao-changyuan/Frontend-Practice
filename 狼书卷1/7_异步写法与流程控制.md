## 第7章 异步写法与流程控制

在Node.js里，为了解决API级别的回调地狱问题，便引入了用于流程控制的部分——异步流程控制。

### 7.1 异步调用

很多人认为掌握了源码才算精通，但在深入源码之前，最好能对API用法非常熟悉，避免理解不全面。

#### 7.1.1 异步与同步

异步：合理利用时间高效做事，即充分利用服务器并行执行操作。

#### 7.1.2 浏览器中的异步

Ajax, 异步JavaScript与XML。A表示Asyncchronous。

#### 7.1.3 Node.js异步原理

Ajax的核心是XHR（XMLHttpRequest）。而Node.js的核心是EventLoop。

我们调用Node.js API方法的时候，它会把具体操作和回调函数交给EventLoop去执行，EventLoop维护了一个回调函数队列，当异步函数执行时，回调函数会被放入这个队列。JavaScript引擎知道异步函数执行完成后，才会开始处理EventLoop，这意味着JavaScript代码不是多线程的，即使表现出来的行为相似。EventLoop维护的是一个先进先出的队列，这说明回调函数在队列中是顺序执行的。

#### 7.1.4 API和示例

Node.js SDK中使用的错误优先回调（error-first callback）的写法，具体如下：

- 回调函数通常是API的最后一个参数。
- 回调函数中会约定回调内容。
  - err在前，没有err时第一个参数为空。
  - 具体返回结果在后，可以有多种结果。

要注意的是，在高并发场景下要慎用同步写法，不然可能会称为性能瓶颈，毕竟同步写法是模拟实现的，和Node.js本身异步的设计初衷是相悖的。

#### 7.1.5 代码优化

异步执行的效率更高，但结果却不一定是我们想要的。**异步执行的结果具有一定的不确定性。**

### 7.2 Node.js自带的异步写法

Node.js中有两种事件处理方式，分别是callback（回调）和EventEmitter（事件发射器）。

简单来说，callback采用错误优先（error-first）的回调方式，EventEmitter则是事件驱动里的事件发射器。

#### 7.2.1 错误优先的回调方式

**错误优先回调方式的写法**

定义错误优先的回调方式只需要注意两条规则即可，如下：

- 回调函数的第一个参数返回的error对象，如果发生错误，该对象会作为第一个参数返回。如果执行正常，一般做法是返回null。
- 回调函数的第二个参数返回的是所有成功响应的结果数据。如果结果正常，即没有发生错误，操作err就会被设置null，并在第二个参数处返回成功响应的结果。

**API写法约定**

模块应该暴露错误优先的回调接口。

应该经常在回调中检查错误。

只有在同步代码块才能使用try-catch（在Node.js 8之后的优化版本里，try-catch几乎没有性能损坏，可以放心使用），在回调函数中不能随意使用。

异常处理是异步流程控制里最难的部分。

**函数定义**

通常情况下，函数定义的方式如下：

```javascript
function(arg1, arg2, ..., callback) {
    // 进行参数校验，然后调用回调函数
}
```

从语义上讲，遵守约定是指程序根据输入参数完成某些工作，在特定场景下调用回调对异步处理进行注册，在异步处理完成后通过调用函数通知程序调用方。

写法越底层，使用者越有可发挥的空间。

#### 7.2.2 EventEmitter

事件模块是Node.js内置的对观察者模式的实现，通过EventEmitter属性提供一个构造函数。该构造函数的实例中具有两个常用方法，其中on方法可以用来监听指定事件，并触发回调函数，另一个emit方法可以用来发布事件。我们可以通过发布订阅模型来理解，一般是按照“订阅（on）—>发布（emit）”的顺序进行的，这和消息队列有异曲同工之处。

**EventEmitter入门**

EventEmitter对象的事件触发和监听是同步的，即只有在事件的回调函数是异步的情况下，函数emit才会被触发执行。

EventEmitter和前端的事件机制很类似，其实Vue里的$emit和$on也是一模一样的机制。

**继承EventEmitter类**

events模块值提供了一个对象：events.EventEmitter。EventEmitter的核心部分就是对事件触发与事件监听器功能的封装。

**设置最大监听数**

默认情况下，Node.js运行同一个事件最多指定10个回调函数。

EventEmitter实例的emit方法是用来触发事件的，它的第一个参数表示事件名称，其余的参数都会依次被传入回调函数。

**事件**

1. **事件操作接口**

events模块默认支持如下两个事件：newListener事件和removeListener事件。newListener事件在添加新的回调函数时被触发，removeListener事件在添加新的回调函数时被触发，removeListener事件在移除回调函数时被触发。

2. **once方法**

回调函数只被触发一次。

3. **获取监听器信息**

获取监听器信息是通过listeners方法实现的，该方法接收一个事件名称作为参数，返回由该事件所有回调函数组成的数组。

4. **事件错误处理**

事件错误处理的方法和常规回调方式处理错误的方法一样，即在回调函数里判断err参数，同时结合Event里最常用的on方法来监听error事件。

如果说http是Node.js的核心模块，那么Stream就是核心中的核心，是保证http高效的秘密武器。相比之下，events显得极为“底层”，是为核心模块服务的。 

#### 7.2.3 该选择哪种风格的写法

API推荐使用错误优先的回调方式，统一使用Node.js SDK的回调风格。在同一对象内，使用EventEmitter解耦可以合理利用集成，使代码可读性更强。

### 7.3 更好的异步流程控制

#### 7.3.1 回调地狱

回调里嵌套回调的问题。

#### 7.3.2 Thunk

Thunk曾在某段时间内非常受到关注，著名的co模块在v4以前的版本中曾大量使用Thunk函数，Redux中也有redux-thunk这样的中间件。

#### 7.3.3 Promise

Promise最早也是在CommonJS社区被提出来的。

**Promise/A+规范**

要点：

- 递归：每个异步操作返回的都是Promise对象
- 状态机：三种状态，只在Promise对象内部可以控制，不能在外部改变状态。
- 全局异常处理

Promise的交互主要是通过then函数实现的。如果Promise成功执行了resolve，那么它就会将resolve的值传给最近的then函数，作为then函数的参数。

为了简化编程的复杂性，我们约定每个函数的返回值都得是Promise对象。

一般情况下then函数只传fulfilled状态的回调函数即可，rejected状态的回调函数可选，使用catch来捕获异常比通过fail函数进行处理更加可控。

一定要注意，只有异步操作有结果的时候，才可以决定当前Promise处于哪个状态，任何其他操作都无法改变这个状态。这些状态是由Promise内部维护的，我们能做的只是在写法上对其进行控制。

Node.js源码里实际上使用的是Chrome V8内置的Promise。

Bluebird是Node.js世界里性能最好的Promise/A+规范的实现。

Node.js原生的Promise和Bluebird的实现是兼容的。只要掌握了其中一种，几乎可以零成本学会另一种。

在Koa或Express这样的Web项目里声明时则可以使用全局声明的方式。造应用的入口文件app.js里使用global关键字进行全局替换即可：`global.Promise = require('bluebird')`.

#### 7.3.4 Generator

生成器本质上是一种特殊的迭代器。

co是ES6 Generator的执行器，它可以使用Generator里的yieldable支持的所有形式。

co的典型用法是作为Generator执行器使用。

ES6 Generator是用来进行计算的迭代器，它是过渡性的产物。

#### 7.3.5 async 函数

Generator的弊病是没有执行器，它本身也不是为流程控制而生的。

**使用async函数是趋势。**

