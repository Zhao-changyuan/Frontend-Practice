## 1. 控制器(Controller)

一般来说，控制器常用于对用户的请求参数做一些校验，转换，调用复杂的业务逻辑，拿到相应的业务结果后进行数据封装，然后返回。

在 Midway中，控制**也承载了路由的能力**。

### 1.1 路由

控制器文件一般来说在`src/controller`目录中，我们可以在其中创建控制器文件。Midway使用`@Controller()`装饰器标注控制器，其中装饰器有一个可选参数，用于进行路由前缀（分组），这样这个控制器下面的所有路由都会带上这个前缀。

Midway还提供了其他的装饰器，`@Get`、`@Post`、`@Del()`、`@Patch()`、`@Options()`、`@Head()`、`@All()`，表示各自的HTTP请求方法。

你可以将多个路由绑定到同一个方法上。

### 1.2 请求参数

`@Query`装饰器有参数，可以传入要给指定的字符串key，回去对应的值，复制给入参，如果不传入，则默认的字符串key为参数名。

还有其他装饰器：

- @Session(key?: string)
- @Param(key?: string)
- @Body(key?: string)
- @Query(key?: string)
- @Queries(key?: string)
- @Headers(name?: string)

ALL这个key这些装饰器都可用，`ALL`和`All`是不同的，`ALL`用来获取到所有的属性，是一个变量，而`All`是一个装饰器，用于匹配所有的method的请求。

还有一些常见的参数装饰器：

- `@requestPath`
- `@requiestIP`

### 1.3 状态码

默认情况下，相应的状态码总是200，我们可以通过在处理程序层条件`@HttpCode`装饰器来轻松更改此行为。

注意，状态码修饰器不能在响应流关闭后（response.end之后）修改。

### 1.4 响应头

Midway通过`@SetHeader`装饰器来简单的设置响应头。

当有多个响应头需要修改的时候，你可以直接传入对象。

### 1.5 重定向

`@Redirect`装饰器，参数为一个跳转的URL，以及一个可选的状态码，默认跳转的状态码为`302`。

### 1.6 响应类型

`@ContentType`装饰器用于设置响应类型。

### 1.6 优先级

通配的路径将自动降低优先级，在最后被挂载。

规则如下：

1. 绝对路径规则优先级最高
2. 星号只能出现最后且必须在`/`后面
3. 如果绝对路径和通配路径都能匹配一个路径时，绝对规则优先级高。
4. 有多个通配能匹配时，最长的规则匹配。
5. 如果`/`与`/*`都能匹配`/`，但`/`的优先级高于`/*`
6. 如果都为通配，但是其余权重都一样，那么两者权重等价，以编码加载顺序为准。

简单理解为，“**明确的路由优先级最高，长的路由优先级最高，通配的优先级最低**”

不同的 Controller 的优先级，我们会以长度进行排序，`/`根Controller我们将会最后加载。

## 2. 服务与注入

在业务中只有控制器（Controller）的代码是不够的，一般来说会有一些业务逻辑被抽象到一个特定的逻辑单元中，我们一般称为服务（Service）。

![image-20211211151833653](https://gitee.com/zhaochangyuan/pic-bed/raw/master/202112111518690.png)

- 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。

### 2.1 创建服务

在Midway中，普通的服务就是一个 Class，对于服务的文件，我们一般会存放到`src/service`目录中。

除了一个`@Provide`装饰器外，整个服务的结构和普通的 Class 一模一样。

### 2.2 使用服务

在Midway中，只需要编写"依赖注入"的代码写法。

使用服务的过程分为几部分：

1. 使用`@Provide`装饰器暴露你的服务
2. 在调用的代码处，使用`@Inject`装饰器注入你的服务
3. 调用诸如服务，执行对应的方法。

Midway的核心“依赖注入”容器会**会自动关联**你的控制器（Controller）和服务（Service），在运行过程中会自动初始化所有的代码。

### 2.3 注入行为描述

`@Provide`装饰器的作用：

- 这个Class，被依赖注入容器托管，会自动被实例化（new）
- 这个Class，可以被其他在容器中的Class注入

而对应的`@Inject`装饰器，作用为：

- 在依赖注入容器中，找到对应的属性名，并复制为对应的实例化对象。

注意：`@Inject`的类中，必须有`@Provide`才会生效。



## 3. 请求、响应、应用

每个使用的 Web 框架会提供自己独特的能力，这些独特的能力都会体现在各自的**请求和响应**(Context)和**应用**(Application)之上。

### 3.1 上下文和应用定义约定

所有的上层框架导出 请求和响应（Context）和应用（Application）定义，都保持一直，即`Context`和`Application`。

### 3.2 请求和响应

在默认的请求作用域中，也就是说在控制器（Controller）或者普通的服务（Service）中，我们可以使用`@Inject`来注入对应的实例。

### 3.3 应用实例

在编写业务代码中，有时我们需要拥戴原本框架的能力，而这些能力可能暴露在各自的`app`对象之上，Midway提供了`@App`这个装饰器，用于注入当前运行时的app实例。

我们在任意的`@Provide`装饰器的 Class 上都可以使用 `@App`装饰器。

## 4. Web 中间件

Web中间件是在控制器调用 之前和之后（部分）调用的函数。中间件函数可以访问请求和响应对象。

![image-20211211151858018](https://gitee.com/zhaochangyuan/pic-bed/raw/master/202112111518046.png)

EggJS基于洋葱圈模型。

### 4.1 编写 Web 中间件

一般情况下，我们会在`src/middleware`文件夹中编写Web中间件。

### 4.2 使用 Web 中间件

两种：

- 全局中间件，所有的路由都会执行的中间件，比如cookie、session等等。
- 路由中间件，单个/部分路由会执行的中间件，比如某个路由的前置校验，数据处理等等。

![image-20211210162826846](D:\codeRepo\f-p\Midway\nodes\assets\image-20211210162826846.png)

#### 4.2.1 路由中间件

`@Controller`装饰器的第二个参数，恶意让我们方便在某个路由分组之上添加中间件。

Midway同时也在`@get`、`@Post`等路由装饰器上都提供了 middleware参数。

#### 4.2.2 全局中间件

设置全局中间件需要拿到应用的实例，同时，需要在所有请求之前被加载。

在EggJS中，其提供了一个配置性的加载全局中间件的用法，在`src/config/config.default.ts`中配置middleware属性即可以定义全局中间件，同样的，指定全局中间件的 key 即可。

### 4.3 常见示例

#### 4.3.1 中间件中获取请求作用域实例

由于Web中间件在生命周期的特殊性，会在应用请求前就被加载到路由上，所以无法和请求关联。中间件类的的作用域固定为单例（Singleton）

中间件中注入的实例和请求不绑定，**无法获取到ctx**，无法使用`@Inject()`注入请求作用域的实例，只能获取 Singleton 的实例。

如果要获取请求作用域的实例，可以使用从请求作用域容器`ctx.requestContext`中获取。

#### 4.3.2 特殊的全局中间件用法

Midway提供了一个生命周期的口子，方便业务在非常早的时候可以做一些自定义处理。我们需要手动创建一个生命周期文件，位于`src/configuration.ts`

Midway在各个Web矿建的 app 上提供了一个`generateMiddleware`方法，用于快速创建 Class 形式的中间件，然后使用框架原有的`use`方法即可加载为全局中间件。

在 onReady 中加载的中间件，**框架会保证在 egg 中间件加载之前被执行。**

#### 4.3.3 全局路由前缀

全局路由前缀可以由反向代理工具来做，比如nginx，也可以由中间件代码来完成。

## 5. 启动与部署

多种部署模式，你既可以将应用按照传统的样子，部署到任意的服务上（比如自己购买的服务器），也可以将应用构建为一个 Serverless 应用，Midway 提供跨多云的部署方式。

### 5.1 本地开发

#### 5.1.1 快速启动单个服务

`midway-bin dev --ts`

这是一个最精简的指令，它有如下特性：

- 使用`--ts`指定 TypeScript (ts-node)环境启动
- 使用内置的（@midwayjs/mock的createApp）创建一个匹配当前框架的服务，并返回app

所谓匹配当前框架，指的是根据内部的框架列表，和 pkg 的依赖匹配查找到最符合当前的框架并茄冬。

内部的框架列表如下：

```javascript
const currentFramework = [
	'@midwayjs/web',
	'@midwayjs/koa',
	'@midwayjs/express',
	'@midwayjs/serverless-app',
	'@midwayjs/grpc',
	'@midwayjs/rabbitmq',
	'@midwayjs/socketio',
	'@midwayjs/faas'
]
```

这样启动的服务用于本地快速开发测试，使用的是框架初始化的默认值。

#### 5.1.2 指定入口启动服务

`--entryFile=bootstrap.js`

### 5.2 部署到普通服务器

#### 5.2.1 部署后和本地开发的区别

1.  **node 环境的变化**

最大的不同是，服务器部署后，会直接使用node来启动项目，而不是ts-node，则意味着不再读取`*.ts`文件

2. **加载目录的变化**

服务器部署后，只会加载构建后的`dist`目录，而本地开发则是加载`src`目录。

|         | 本地                    | 服务器                   |
| ------- | ----------------------- | ------------------------ |
| appDir  | 项目根目录              | 项目根目录               |
| baseDir | 项目根目录下的 src 目录 | 项目根目录下的 dist 目录 |

3. **环境的变化**

服务器环境，一般使用`NODE_ENV=production`，很多库都会在这个环境下提供性能更好的方式。

4. **日志文件**

一般服务器环境，日志不在打印到项目的logs目录下，而是其他不会受到项目更新影响的目录，比如`home/admin/logs`等等，这样固定的目录，也方便其他工具采集日志。

#### 5.2.2 部署流程

![image-20211211121343913](C:\codeRepo\f-p\Midway\nodes\assets\image-20211211121343913.png)

#### 5.2.3 编译代码和安装依赖

`npm run build`

推荐大家先执行测试和 lint

一般来说，部署构建的环境和本地开发的环境是两套，我们推荐在一个干净的环境中构建的的应用。

示例脚本：

```sh
## 服务器构建（已下载好代码）
$ npm install # 安装开发期依赖
$ npm run build # 构建项目
$ npm prune --production # 移除开发依赖

## 本地构建（已经安装好 dev 依赖）
$ npm run build
$ npm prune --production # 移除开发依赖
```

#### 5.2.4 打包压缩

构建完成后，你可以简单的打包要锁，上传到待发布的环境。

#### 5.2.5 上传和解压

`ssh/FTP/git`等

#### 5.2.6 启动方式一：使用纯 Node.js 或则 pm2 等工具启动

Midway 构建出来的项目是单进程的。

Midway 提供了一个简单方式以满足不同场景的启动方式，只需要安装我们提供的`@midwayjs/bootstrap`模块。

编写启动脚本 bootstrap.js

```js
// 获取框架
const WebFramework = require('@midwayjs/web').Framework;

// 初始化 web 框架并传入启动参数
const web = new WebFramework().configure({
  port: 7001,
});

const { Bootstrap } = require('@midwayjs/bootstrap');

// 加载框架并执行
Bootstrap.load(web).run();
```



启动命令：

`NODE_ENV=production node bootstrap.js`

也可以使用 pm2 来执行启动。

#### 5.2.7 启动方式二：EggJS特有的启动方式

由于EggJS提供了默认的多进程部署工具`egg-scripts`，Midway 也继续支持这种方式，如果上层是 EggJS，推荐这种部署方式。

注意：`egg-scripts`对Windows系统的支持有限。

**启动参数：**

- `--port=7001` 端口号，默认会读取环境变量 process.env.PORT，如未传递将使用框架内置端口 7001.
- `--deamon` 是否允许在后台模式，无需 nohup。
- `--env-prod` 框架运行环境，默认会读取环境变量 process.env.EGG_SERVER_ENV，如未传递将使用框架内置环境 prod。
- `--workers=2`框架 worker线程数，默认会创建和 CPU 核数相当的app worker数，可以充分利用 CPU 资源。
- `--title=egg-server-showcase`用于方便 ps进程时grep用，默认为egg-server-${appname}
- `--framework=yadan`如果应用使用了自定义框架，可以配置 package.json 的 egg.framework或指定该参数。
- `--ignore-stderr`忽略启动期的报错。
- `--https.key`指定 HTTPS 所需密钥文件的完整路径。
- `--https.cert` 指定 HTTPS 所需证书文件的完整路径。
- 所有 egg-cluster 的 Options 都支持透传,，如 --port等。

注意：使用egg-scripts部署的日志会存放在用户根目录下，比如`/home/xxx/logs`



### 5.3 部署为 Serverless 应用

下面以阿里云函数计算作为示例。

#### 5.3.1 部署到 Serverless 环境

1. 添加`f.yml`文件到你的项目根目录。

```yaml
service: my-miday-app ## 应用发布到云平台的名字，一般指应用名

provider:
	name: aliyun ## 发布的云平台，aliyun，tencent 等
	
deployType: egg ## 部署的应用类型
```

应用类型选项如下：

- @midwayjs/web: egg
- @midwayjs/experss: express
- @midwayjs/koa: koa

2. 添加发布时的构建钩子

在`package.json`加入下面这段，用于在发布时自动执行`npm run build`。

```json
"midway-integration": {
    "lifecycle": {
      "before:package:cleanup": "npm run build"
    }
  },
    "scripts": {
    "deploy": "midway-bin deploy"
  },
  "egg":{
    "framework": "@midwayjs/web"
  }
```

3. 执行 `npm run deploy`即可，发布后，阿里云会输出一个临时可用的域名，打开浏览器即可访问。

#### 5.3.2 部署到 Serverless 平台的限制

- 不支持 egg-socketio等网关不支持的协议
- 不支持 文件上传 等网关无法支持的能力
- 不支持 定时任务 （可以使用组合 Timers 触发器的方式）



### 5.4 使用 Docker 部署

#### 5.4.1 编写 Dockerfile，构建镜像



