## 1. 控制器(Controller)

一般来说，控制器常用于对用户的请求参数做一些校验，转换，调用复杂的业务逻辑，拿到相应的业务结果后进行数据封装，然后返回。

在 Midway中，控制**也承载了路由的能力**。

### 1.1 路由

控制器文件一般来说在`src/controller`目录中，我们可以在其中创建控制器文件。Midway使用`@Controller()`装饰器标注控制器，其中装饰器有一个可选参数，用于进行路由前缀（分组），这样这个控制器下面的所有路由都会带上这个前缀。

Midway还提供了其他的装饰器，`@Get`、`@Post`、`@Del()`、`@Patch()`、`@Options()`、`@Head()`、`@All()`，表示各自的HTTP请求方法。

你可以将多个路由绑定到同一个方法上。

### 1.2 请求参数

`@Query`装饰器有参数，可以传入要给指定的字符串key，回去对应的值，复制给入参，如果不传入，则默认的字符串key为参数名。

还有其他装饰器：

- @Session(key?: string)
- @Param(key?: string)
- @Body(key?: string)
- @Query(key?: string)
- @Queries(key?: string)
- @Headers(name?: string)

ALL这个key这些装饰器都可用，`ALL`和`All`是不同的，`ALL`用来获取到所有的属性，是一个变量，而`All`是一个装饰器，用于匹配所有的method的请求。

还有一些常见的参数装饰器：

- `@requestPath`
- `@requiestIP`

### 1.3 状态码

默认情况下，相应的状态码总是200，我们可以通过在处理程序层条件`@HttpCode`装饰器来轻松更改此行为。

注意，状态码修饰器不能在响应流关闭后（response.end之后）修改。

### 1.4 响应头

Midway通过`@SetHeader`装饰器来简单的设置响应头。

当有多个响应头需要修改的时候，你可以直接传入对象。

### 1.5 重定向

`@Redirect`装饰器，参数为一个跳转的URL，以及一个可选的状态码，默认跳转的状态码为`302`。

### 1.6 响应类型

`@ContentType`装饰器用于设置响应类型。

### 1.6 优先级

通配的路径将自动降低优先级，在最后被挂载。

规则如下：

1. 绝对路径规则优先级最高
2. 星号只能出现最后且必须在`/`后面
3. 如果绝对路径和通配路径都能匹配一个路径时，绝对规则优先级高。
4. 有多个通配能匹配时，最长的规则匹配。
5. 如果`/`与`/*`都能匹配`/`，但`/`的优先级高于`/*`
6. 如果都为通配，但是其余权重都一样，那么两者权重等价，以编码加载顺序为准。

简单理解为，“**明确的路由优先级最高，长的路由优先级最高，通配的优先级最低**”

不同的 Controller 的优先级，我们会以长度进行排序，`/`根Controller我们将会最后加载。

## 2. 服务与注入

在业务中只有控制器（Controller）的代码是不够的，一般来说会有一些业务逻辑被抽象到一个特定的逻辑单元中，我们异常成为服务（Service）。

![image-20211210154032220](D:\codeRepo\f-p\Midway\nodes\assets\image-20211210154032220.png)

- 保持业务逻辑的独立性，抽象出来的 Service 可以被多个 Controller 重复调用。

### 2.1 创建服务

在Midway中，普通的服务就是一个 Class，对于服务的文件，我们一般会存放到`src/service`目录中。

除了一个`@Provide`装饰器外，整个服务的结构和普通的 Class 一模一样。

### 2.2 使用服务

在Midway中，只需要编写"依赖注入"的代码写法。

使用服务的过程分为几部分：

1. 使用`@Provide`装饰器暴露你的服务
2. 在调用的代码处，使用`@Inject`装饰器注入你的服务
3. 调用诸如服务，执行对应的方法。

Midway的核心“依赖注入”容器会**会自动关联**你的控制器（Controller）和服务（Service），在运行过程中会自动初始化所有的代码。

### 2.3 注入行为描述

`@Provide`装饰器的作用：

- 这个Class，被依赖注入容器托管，会自动被实例化（new）
- 这个Class，可以被其他在容器中的Class注入

而对应的`@Inject`装饰器，作用为：

- 在依赖注入容器中，找到对应的属性名，并复制为对应的实例化对象。

注意：`@Inject`的类中，必须有`@Provide`才会生效。



## 3. 请求、响应、应用

每个使用的 Web 框架会提供自己独特的能力，这些独特的能力都会体现在各自的**请求和响应**(Context)和**应用**(Application)之上。

### 3.1 上下文和应用定义约定

所有的上层框架导出 请求和响应（Context）和应用（Application）定义，都保持一直，即`Context`和`Application`。

### 3.2 请求和响应

在默认的请求作用域中，也就是说在控制器（Controller）或者普通的服务（Service）中，我们可以使用`@Inject`来注入对应的实例。

### 3.3 应用实例

在编写业务代码中，有时我们需要拥戴原本框架的能力，而这些能力可能暴露在各自的`app`对象之上，Midway提供了`@App`这个装饰器，用于注入当前运行时的app实例。

我们在任意的`@Provide`装饰器的 Class 上都可以使用 `@App`装饰器。

## 4. Web 中间件

Web中间件是在控制器调用 之前和之后（部分）调用的函数。中间件函数可以访问请求和响应对象。

![image-20211210162125890](D:\codeRepo\f-p\Midway\nodes\assets\image-20211210162125890.png)

EggJS基于洋葱圈模型。

### 4.1 编写 Web 中间件

一般情况下，我们会在`src/middleware`文件夹中编写Web中间件。

### 4.2 使用 Web 中间件

两种：

- 全局中间件，所有的路由都会执行的中间件，比如cookie、session等等。
- 路由中间件，单个/部分路由会执行的中间件，比如某个路由的前置校验，数据处理等等。

![image-20211210162826846](D:\codeRepo\f-p\Midway\nodes\assets\image-20211210162826846.png)

#### 4.2.1 路由中间件

`@Controller`装饰器的第二个参数，恶意让我们方便在某个路由分组之上添加中间件。

Midway同时也在`@get`、`@Post`等路由装饰器上都提供了 middleware参数。

#### 4.2.2 全局中间件

设置全局中间件需要拿到应用的实例，同时，需要在所有请求之前被加载。

在EggJS中，其提供了一个配置性的加载全局中间件的用法，在`src/config/config.default.ts`中配置middleware属性即可以定义全局中间件，同样的，指定全局中间件的 key 即可。

### 4.3 常见示例

#### 4.3.1 中间件中获取请求作用域实例

由于Web中间件在生命周期的特殊性，会在应用请求前就被加载到路由上，所以无法和请求关联。中间件类的的作用域固定为单例（Singleton）

中间件中注入的实例和请求不绑定，**无法获取到ctx**，无法使用`@Inject()`注入请求作用域的实例，只能获取 Singleton 的实例。

如果要获取请求作用域的实例，可以使用从请求作用域容器`ctx.requestContext`中获取。