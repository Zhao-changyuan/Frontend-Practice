## 1. 实用类型

### 1.1 `Partial<Type>`

构造一个类型，Type中的所有属性都是可选的。

### 1.2 `Required<Type>`

构造一个类型，Type中的所有属性都是必须的。

### 1.3 `Readonly<Type>`

构造一个类型，Type中的所有属性都是只读的。

### 1.4 `Record<Keys, Type>`

构造一个对象类型，其属性键为Keys，属性值类型为Type。此实用类型可用于将一种类型的属性映射到另一种类型。

### 1.5 `Pick<Type, Keys>`

通过从Type中选取一组属性Keys（字符串字面量类型或字符串字面量联合类型）来构造类型

### 1.6 `Omit<Type, Keys>`

通过从Type中排除一组属性Keys（字符串字面量类型或字符串字面量联合类型）来构造类型

### 1.7 `Exclude<Type, ExcludeUnion>`

构造一个类型，排除一部分联合成员类型。

### 1.8 `Extract<Type, Union>`

构造一个类型，提起一部分联合成员类型。

### 1.9 `NonNullable<Type>`

排除null undefined类型

### 1.10 `Parameters<Type>`

根据函数类型的参数中使用的类型构造元组类型Type.

### 1.11 `ConstructorParameters<Type>`

根据构造函数类型的参数中使用的类型构造元组类型Type.

### 1.12 `ReturnType<Type>`

获取一个函数类型的返回值类型

### 1.13 `InstanceType<Type>`

通过构造函数类型Type获取实例类型。

### 1.14 `ThisParameterType<Type>`

提取函数类型Type的this参数类型。

### 1.15 `OmitThisParameter<Type>`

从Type构造一个没有this参数的函数类型。

### 1.16 `ThisType<Type>`

此实用程序**不返回转换后的类型**， 仅是一个约束，提示旗下所定义的函数，在函数body中，其调用则的类型是什么。相反，它充当上下文[`this`](https://www.typescriptlang.org/docs/handbook/functions.html#this)类型的标记。请注意，[`noImplicitThis`](https://www.typescriptlang.org/tsconfig#noImplicitThis)必须启用该标志才能使用此实用程序。

```typescript
type ObjectDescriptor<D, M> = {
  data?: D,
  methods?: M & ThisType<D & M>; // 在methods中的this是 D & M
};

function makeObject<D, M>(desc: ObjectDescriptor<D, M>): D & M {
  let data: object = desc.data || {};
  let methods: object = desc.methods || {};

  return { ...data, ...methods } as D & M;
}

let obj = makeObject({
  data: { x: 0, y: 0 },
  methods: {
    moveBy(dx: number, dy: number) {
      this.x += dx // 强类型this
      this.y += dy
    }
  }
})

obj.x = 10;
obj.y = 20;
obj.moveBy(5, 5)
```

在对象字面量的上下文类型中被识别。

## 2. 装饰器



## 3. 声明合并

声明合并是指编译器将两个单独声明的同名声明合并为一个定义。

在TypeScript，声明至少在以下三组之一中创建实体：命名空间、类型或值。

| 声明的类型 | 命名空间 | 类型 | 值   |
| ---------- | -------- | ---- | ---- |
| 命名空间   | ×        |      | ×    |
| 类         |          | ×    | ×    |
| 枚举       |          | ×    | ×    |
| 接口       |          | ×    |      |
| 类型别名   |          | ×    |      |
| 函数       |          |      | ×    |
| 变量       |          |      | ×    |

### 3.1 合并接口

在接口A与后面的接口合并时，第二个接口将比第一个具有更高优先级。但是，如果签名有一个参数，其类型是单个字符串文字类型，那么它将冒泡到其合并的重载列表的顶部。

### 3.2 合并命名空间

为了合并命名空间，每个命名空间中声明的导出接口的类型定义本身被合并，形成一个内部合并接口定义的单个命名空间。

未导出的成员仅在原始（未合并）命名空间中可见。这意味着合并后，来自其他声明的合并成员看不到非导出成员。

### 3.3 将命名空间与类、函数和枚举合并

#### 3.3.1 将命名空间与类合并

最终结果是在另一个类中管理一个类。

JavaScript创建函数然后通过向函数添加属性来进一步扩展函数的做法。TypeScript使用声明合并以类型安全的方式构建这样的定义。

同样，命名空间可用于扩展具有静态成员的枚举。

### 3.4 不允许的合并

目前，类不能与其他类或变量合并。

### 3.5 模块增强

```typescript
// observable.ts
export class Observable<T> {
  // ... implementation left as an exercise for the reader ...
}
// map.ts
import { Observable } from "./observable";
declare module "./observable" {
  interface Observable<T> {
    map<U>(f: (x: T) => U): Observable<U>;
  }
}
Observable.prototype.map = function (f) {
  // ... another exercise for the reader
};
// consumer.ts
import { Observable } from "./observable";
import "./map";
let o: Observable<number>;
o.map((x) => x.toFixed());
```



模块扩充的两个限制：

- 你不能在扩充中声明新的顶级声明——只是对现有声明的补充。
- more你到处也不能增加，只能增加命名导出。

### 3.6 全局增强

你还可以从模块内部向全局范围添加声明：

```typescript
// observable.ts
export class Observable<T> {
  // ... still no implementation ...
}
declare global {
  interface Array<T> {
    toObservable(): Observable<T>;
  }
}
Array.prototype.toObservable = function () {
  // ...
};
```

全局增强与模块增强具有相同的行为和限制。

## 4. 枚举

TypeScript提供数字和基于字符串的枚举。

### 4.1 数字枚举

数字枚举可以混合在计算成员和常量成员中。意思是没有初始化的枚举要么排在第一位，要么排在用数字常量或其他常量枚举成员初始化的数字枚举之后。

### 4.2 字符串枚举

字符串枚举中，每个成员都必须使用字符串文字或另一个字符串枚举成员进行常量初始化。

### 4.3 异构枚举

不建议混合数字和字符串

### 4.4 计算成员和常量成员

每个enum成员都有一个与之关联的值，该值可以是常量或计算值。

### 4.5 联合枚举和枚举类型

有一个不计算的常量枚举成员的特殊子集：文字枚举成员是一个没有初始化值的常量枚举成员，具有初始化为

- 任何字符串文字
- 任何数字
- 应用于任何数字文字的一元减号

枚举成员也能成为类型。



枚举类型本身有效地成为每个枚举成员的联合。

### 4.6 运行时枚举

枚举是在运行时存在的真实对象。

### 4.7 编译时枚举

使用`keyof typeof`将获取将所有Enum键表示为字符串的类型。

#### 4.7.1 反向映射

除了为成员创建具有属性名称的对象之外，数字枚举成员还获得从枚举值到枚举名称的反向映射。字符串枚举成员不会。

#### 4.7.2 const 枚举

常量枚举只能使用常量枚举表达式，并且与常规枚举不同，他们在编译期间被完全删除。

### 4.8 环境枚举

环境枚举用于描述已经存在的枚举类型的形状。

```typescript
declare enum Enum {
  A = 1,
  B,
  C = 2,
}
```

区别：在常规枚举中，如果前一个枚举成员被视为常量，则没有初始化器的成员将别是为常量。相比之下，没有初始化器程序的环境（和非常量）枚举成员始终被视为已计算。

### 4.9 对象与枚举

当定义对象时， 结尾出现 `as const`，您可能不需要枚举

## 5. 迭代器和生成器

### 5.1 可迭代对象

#### 5.1.1 Iterable 界面

#### 5.1.2 `for..of`声明

- `for...in`返回正在迭代的对象上的键列表，而`for...of`返回正在迭代的对象的数字属性的值列表。
- `for...in`对任何对象进行操作，他用作检查此对象上的属性的一种方式，`for...of`主要对可迭代对象的值感兴趣。

## 6. JSX



## 7. 混合

### 7.1 Mixin如何工作？

该模式依赖使用具有类似继承的泛型来扩展积累。TypeScript最好的mixin支持是通过类表达式模式完成的。

## 8. 模块

任何包含顶级import或export模块的文件都被视为模块。相反，没有人任何顶级import或export声明的文件被视为脚本，其内容在全局范围内可用。

### 8.1 导出

任何声明（例如变量、函数、类、类型别名或接口）都可以通过添加`export`关键字导出。

#### 8.1.1 重新导出

重新导出并不会将其导入本地，也不会引入本地变量。

一个模块可以包装一个或多个模块并使用g`export * from "module"`语法组合他们的所有导出。

### 8.2 导入

### 8.3 导入类型

可以使用`import`或`import type`导入类型。

`import type`总是能保证从你的JavaScript中删除。

### 8.4 默认导出

默认导出类和函数声明名称是可选的。

### 8.5 `export =`和`import = require()`

TypeScript支持`export =`对传统的CommonJS和AMD工作流程进行建模。

使用`export =`导出模块时，必须使用`import module = require("module")`来导入模块。

### 8.6 使用其他JavaScript库

为了描述不是用TypeScript编写的库，