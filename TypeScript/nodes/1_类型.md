## 1. 基本类型

### 类型声明

语法：

```typescript
let name: string;
let password: string = '333';
function fn(username: string) {
    ...
}
```

如果变量的什么和赋值是同时进行的，TS可以自动对变量进行类型检测，这是一个特性，当类型系统最终会推断出相同的类型时，最好不要添加类型注解。

**类型注解永远不会改变程序的运行时行为。**

JS中的函数是不考虑参数的类型和个数的。

### 类型

| 类型    | 例子             | 描述                             |
| ------- | ---------------- | -------------------------------- |
| number  | 1, 2, 3          | 任意数字                         |
| string  | 'hi' "hello"     | 任意字符串                       |
| boolean | true false       | 布尔值true或false                |
| 字面量  | 其本身           | 限制变量的值就是该字面量的值     |
| any     | *                | 任意类型                         |
| unknown | *                | 类型安全的any                    |
| void    | 空值 (undefined) | 没有值 （或undefined）           |
| never   | 没有值           | 不能是任何值                     |
| object  | `{name: '悟空'}` | 任意的js对象                     |
| array   | [1, 2, 3]        | 任意的JS数组                     |
| tuple   | [4, 5]           | 元组，TS新增类型，固定长度的数组 |
| enum    | enum(A, B)       | 枚举，TS中新增类型               |

#### 字面量类型

使用字面量定义变量类型，表示该变量只能被赋值相应的字面量。

#### 联合类型

可以使用 | 来连接多个类型（联合类型）。

#### any

any 表示的任意类型，一个变量设置类型为any后相当于对该变量关闭了TS的类型检测。

使用ts时，不建议使用any类型。

声明变量如果不指定类型，则TS解析器会自动判断变量的类型为 any (隐式的any)

它可以赋值给任意变量。

当一个数组中要存储多个数据，个数不确定，类型不确定，此时也可以使用any类型来定义数组：`let arr: any[] = ['年少不知富婆好']`

**注意：**建议尽量避免使用显式或隐式的any，不到万不得已。

#### unknown

实际上就是一个类型安全的any，不能直接赋值给其他变量。

对unknown值执行任何操作都是不合法的。

这在描述函数类型时很有用，因为您可以描述接受任何值的函数，而any函数体中没有值。

#### 类型断言

可以用来告诉解析器变量的实际类型

语法（两种）：

变量 as 类型

 or <类型>变量

```typescript
let e: unknown;
e = 'hello'
let s: string = e as string;
// or
let s: string = <string>e;
```

TypeScript只允许类型断言转换为更具体或不太具体的类型版本。

有时这条规则可能过于保守，将不允许更复杂的可能有效的强制转换。如果发生这种情况，您可以使用两个断言，首先是`to any`（或`to unknown`），然后是所需的类型：

```typescript
const a = (expr as any) as T;
```



#### void

某种程度上来说，void 类型像是 any 类型相关，它表示没有任何类型。

以函数为例，就表示没有返回值的函数。

在JavaScript中，不返回任何值的函数将隐式返回value undefined。但是void和undefined在TypeScript中不是一回事。

具有void返回类型的上下文函数类型，在实现时，可以返回任何其他值，但会被忽略。

当字面量函数定义具有void返回类型时，该函数不得返回任何内容。

#### never

以函数为例，表示永远不会返回结果，用来报错，用的比较少。

在返回类型中，这意味着函数抛出异常或终止程序的执行。

#### object

不实用，我们在限制一个对象的时候，更多是限制的对象的属性的类型。

{} 用来指定对象中可以包含哪些属性，在属性名后面添加?，表示属性是可选的。

语法：

```typescript
let b: {
	name: string,
    age?: number,
    [propName: string]: any // 表示任意类型的属性
};
```

object是指任何非原始值（string 、number、bigint、boolean、symbol、null或undefined）。这不同于空对象类型{}，也不同于全局类型Object。

#### array

定义数组的两种方式：

`let arr: string[] ` 表示字符串数组

`let arr2: Array<number> ` 表示数值类型数组

#### tuple

元组，固定长度的数组，在定义时元素类型和长度即确定。

语法：

[类型，类型，类型...]

#### enum

枚举，默认元素的值是数值，从0开始。

```js
enum Color {
    red,
    green,
    blue
}
```

枚举类型提供的一个遍历时你可以由枚举类型的值得到它的名字：

```js
Color[Color.green] // "green"
```



#### &

表示同时满足，如：

```
let j: {name: string} & {age: number};
```

#### 类型的别名

```typescript
type: Point = {
	x: number,
	y: number
}
```

#### 接口

```typescript
interface Point = {
	x: number,
	y: number
}
```

只关心类型的接口和功能是我们将TypeScript成为结构型类型系统的原因。

##### 类型类别名和接口之间的差异

interface中几乎所有的功能都可以用在type中，关键区别在于不能重写打开类型以添加新数据与始终可扩展的接口。

#### undefined 和 null

ts中，`undefined` 和 `null` 两者各自有自己的类型分别叫做 `undefined` 和 `null`。他们的本身的类型用处不是很大。

默认情况下，`undefined` 和 `null` 是所有类型的子类型。可以把undefined 和null 赋值给其他类型的变量，如：number类型的变量。

## 2. 对象类型

### 1. 只读属性

readonly只是意味着属性本身不能被重写。

#### 索引签名

有时您实现并不知道到类型属性的所有名称，但您知道值的形状。在这些情况下，您可以使用索引签名来描述可能值的类型。

```typescript
interface StringArray {
	[index: number] = string;
}

const myArray: StringArray = getStringArray()
const secondItem = myArray[1]
```

索引签名属性类型必须是“字符串”或“数字”。

他们也强制所有属性匹配他们的返回类型。

### 2. 扩展类型

使用extends关键字，我们可以继承其他interface。

interface也可以从多种类型扩展，使用逗号分隔(,)

### 3. 交叉路口类型

interface运行我们通过扩展其他类型来构建新类型。TypeScript提供了另一种称为交集类型的构造，主要用于组合现有的对象类型。

### 4. 通用对象类型

interface和type类型别名都可以使用泛型。

## 3. 数组类型

可赋值性在常规Array和ReadonlyArray之间不是双向的。

## 4. 元组类型

元组在大量基于约定的API中很有用。

元组也可以通过问号来具有可选属性。可选的元素元素只能放在最后，也会影响length。

元组也可以由剩余元素，这些元素必须是数组/元组类型。

## 5. 类型操作

### 5.1 keyof类型运算符

keyof运算符采用对象类型并生成其键的字符串或数字文字联合。

keyof当与映射类型结合使用时，类型变得特别有用。



### 5.2 typeof 类型运算符

TypeScript添加一个一个`typeof`运算符，您可以在类型上下文中使用它来引用变量或属性的类型。



### 5.3 索引访问类型

我们可以使用索引访问类型来查找另一种类型的特定属性。

索引类型本身就是一种类型，因此我们可以完全使用联合类型、或其他类型。

您只能在索引时使用类型。

### 5.4 条件类型

条件类型有助于描述输入和输出类型之间的关系。

条件类型的强大之处在于将它们与泛型一起使用。

#### 5.4.1 条件类型约束

条件类型的真正分支将通过我们检查的类型进一步限制泛型。

#### 5.4.2 在条件类型中进行推断

inter关键字声明性地引入了一个新的泛型类型变量。

#### 5.4.3 分配条件类型

当条件类型作用域泛型类型时，当给定联合类型时，他们变成分布式的。

### 5.5 映射类型

映射类型建立在索引签名的语法上，用于声明尚未提前声明的属性类型。

映射类型是一种泛型类型，它使用PrpertyKeys的联合（通常是通过keyof创建）来迭代键以创建类型。

#### 5.5.1 映射修饰符

`readonly` 和 `?`

您可以删除或用前缀添加这些修饰`-`和`+`。如果不添加前缀则默认为`+`

#### 5.5.2 键重映射as

- 利用模板文字类型等功能从先前的属性名称创建新的属性名称
- 通过never条件类型生成过滤键
- 可以映射任意联合

### 5.6 模板字符串类型

模板文字类型建立在字符串文字类型之上，并且能够通过联合扩展为多个字符串。

他们与JavaScript中的模板文字字符串具有相同的语法，但用于类型位置。当与具体文字类型一起使用时，模板文字通过连接内容产生新的字符串文字类型。

对于模板文字中的每个插值位置，联合交叉相乘。

模板文字的强大之处在于根据类型中的信息定义新字符串。

#### 5.6.1 内在字符串操作类型

内置于编译器中，无法在`.d.ts`TypeScript包含的文件中找到。

大写`Uppercase<StringType>`

小写`Lowercase<StringType>`

首字母大写`Capitalize<StringType>`

首字母小写`Uncapitalize<StringType>`
