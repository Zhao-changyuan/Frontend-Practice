泛型都是关于将两个或多个具有相同类型的值关联起来！

指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的一种特性。

泛型可以同时指定多个。

T extends Inter表示泛型T必须是Inter的实现类（子类）

语法：

```typescript
function fn<T>(a: T): T {
  return a;
}

fn('33')
let a:number = 33
fn(a)
fn<string>('hello')
```

### 1. 泛型接口

在定义接口时，为接口中的属性或方法定义泛型类型，在使用接口时，再指定具体的泛型类型。



### 2. 泛型类

定义一个类，类中的属性值的类型是不确定的，方法中的参数及返回值的类型也是不确定的。

### 3. 泛型约束

如果我们直接对一个泛型参数取 length 属性，会报错，因为这个泛型根本就不知道它有这个属性。

### 4. 编写良好的泛型函数的指南

- 下推类型参数，如果可能使用类型参数本身而不是约束它
- 使用更少的类型参数
- 类型参数应该出现两次，如果一个类型参数在函数签名中只使用一次，它就没有任何关系。

### 5. 在通用约束中使用类型参数

您可以声明另一个类型参数约束的类型参数。例如，在这里我们想从一个给定名称的对象中获取一个属性。我们想确保不会意外地获取在obj上不存在的属性，因此我们将在两种类型之间放置一个约束。

```typescript
function getProperty<Type, Key extends keyof Type>(obj: Type, key: Key) {
  return obj[key]
}

let x = { a: 1, b: 2, c: 3, d: 4 }
getProperty(x, "a")
getProperty(x, "m") // error
```



