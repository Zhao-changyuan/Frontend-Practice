## 1. 理解对象

在调用 Object.defineProperty()时，configurable、enumerable 和 writable 的值如果不指定，则都默认为 false。

## 2. 创建对象

使用 new 操作符调用构造函数会执行如下操作：

1. 在内存那种创建一个新对象；
2. 这个新对象内部的 `[[Prototype]]` 特性被赋值为构造函数的 prototype 属性，这个新对象的 constructor 属性被赋值为这个构造函数；
3. 构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）；
4. 执行构造函数内部的代码；
5. 如果构造函数返回非空对象，则返回该对象；否则返回广创建的新对象。

构造函数也是函数，任何函数只要使用 new 操作符调用就是构造函数。而不使用 new 操作符调用的函数就是普通函数。

每个函数都会创建一个 prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。

**理解原型**
无论何时，只要创建一个函数，就会按照特定的规则为这个函数创建一个 prototype 属性（指向原型对象）。默认情况下，所有原型对象自动获得一个名为 constructor 的属性，指回与之关联的构造函数。

在自定义构造函数时，原型对象默认只会获得 constructor 属性，其他的所有方法都继承自 Object。每次调用构造函数创建一个新实例，这个实例的内部`[[Prototype]]`指针就会被赋值为构造函数的圆心对象。脚本中没有防伪这个`[[Prototype]]`特性的标准方式，但 Firefox、Safari 和 Chrome 会在每个对象上暴露`__proto__`属性，通过这个属性可以访问对象的原型。关键在于理解这一点：实例与构造函数原型之间有直接的关系，但实例与构造函数之间没有。

构造函数、原型对象和实例是 3 个完全不同的对象。
同一个构造函数创建的两个实例共享同一个原型对象。
instanceof 检查实例的原型链中是否包含指定构造函数的原型。

在 for-in 循环中使用 in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。遮蔽原型中不可枚举（`[[Enumerable]]`特性被设置为 false）属性的实例属性也会在 for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。

要获得对象上所有可枚举的实例属性，可以使用 Oject.keys()方法。这个方法接受一个对象作为参数，返回该对象所有可枚举属性名称的字符串数组。

如果想列出所有实例属性，无论是否可以枚举，都可以使用 Object.getOwnPropertyNames()。

for-in 循环和 Object.keys()的枚举顺序是不确定的。Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和 Object.assgin()的枚举顺序是确定的。先以升序数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。

Ojbect.values()和 Object.entries()两个方法会忽略符号属性。

从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对象所做的修改也会在实例上反映出俩。

**虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两回事。实例的`[[Prototype]]`指针时在调用构造函数时自动复制的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型于构造函数的联系，但实例引用的仍然是最初的圆心。记住，实例只有指向原型的指针，没有指向构造函数的指针。**

## 3. 继承

### 3.1 原型链

构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回后遭函数，而实例有一个内部指针指向原型。

默认情况下，所有引用类型都继承自 Object。任何函数的默认原型都是一个 Object 的实例。

以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写了原型链。

在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变为了原型属性。

### 3.2 盗用构造函数

思路：在子类构造函数中调用父类构造函数。
盗用构造函数问题：必须在构造函数中定义方法，因此函数不能重用。

### 3.3 组合继承

组合继承综合了原型链和盗用构造函数。
基本的思路是使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性。

组合继承弥补了原型链和盗用构造函数的不足，是 JavaScript 中使用最多的继承模式。

### 3.4 原型式继承

触发点是即使不自定义类型也可以通过原型实现对象之间的信息共享。

使用情况：你有一个对象，项在它的基础上再创建一个新对象。

Object.create()的第二参数与 Object.defineProperties()的第二个参数一样：每个新增属性都通过格子的描述符来描述。

### 3.5 寄生式继承
