## HTML 篇

### 1. 页面导入样式时，使用 link 和@import 有什么区别？

1. 从属关系区别。@import 只能导入样式表，link 还可以定义 RSS、rel 连接属性、引入网站图标等；
2. 加载顺序区别；加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载；
3. 兼容性区别；link 兼容性更好；

### 2. 常见浏览器内核

- Trident：IE 浏览器内核；
- Gecko：Firefox 浏览器内核；
- Presto：Opera 浏览器内核；
- Webkit：Safari 浏览器内核；
- Blink：谷歌浏览器内核，属于 Webkit 的一个分支；

### 3. 简述浏览器渲染原理

1. 首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的；
2. 然后对 CSS 进行解析，生成 CSSOM 规则树；
3. 根据 DOM 树和 CSSOM 规则构建 Render tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 对象相对应，但这种关系不是一对一的，不可见的 DOM 不会被插入渲染树。
4. 当渲染对象被创建并添加到树中，他们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个结点在页面中的确切位置和大小。通常这一行为被称为“自动重排”。
5. 布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件；

为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。

### 4. HTML5 的 form 的自动完成功能是什么？

`autocomplete` 属性规定输入字段是否应该启用自动完成功能，默认为启动，设置 autocomplete=off 可以关闭该功能。

自动完成功能运行浏览器预测对字段的输入。在用户在字段开始键入时，浏览器基于之前键入过的值，应该显示出在字段中填写的选项。

### 5. 如何实现浏览器多个标签页之间的通信？

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者来让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

1. 使用 Websocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端；
2. 可以调用 localStorage，localStorage 在另一个浏览器上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们可以通过监听 storage 事件，控制它的值来进行页面信息通信。
3. 如果我们能够获得对应标签的引用，通过 postMessage 方法也是可以实现多个标签通信的。

### 6. 简述前端性能优化

**页面内容方面**

1. 通过文件合并、CSS 雪碧图、使用 bese64 等方式减少 HTTP 请求数，避免过渡的请求造成等待的情况；
2. 通过 DNS 缓存等机制来减少 DNS 查询次数；
3. 通过设置缓存策略，对常用不变的资源进行缓存；
4. 通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载；
5. 通过用户行为，对某些资源使用预加载方式，来提高用户需要访问资源时的响应速度；

**服务器方面**

1. 使用 CDN 服务器，来提高用户对于资源请求时的响应速度；
2. 服务器端使用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积；
3. 尽量减少 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对应该资源请求时携带不必要的 cookie；

### 7. 什么是 webp

WebP 是谷歌开发的一种新图片格式，它是支持有损和无损两种压缩方式的使用直接色的点阵图。使用 WebP 格式的最大优点是，在相同质量的文件下，它拥有更小的文件体积。因此它非常适合于网络图片的传输，因为图片体积的减少，意味着请求时间的减少，这样会提高用户的体验。这是谷歌开发的一种新的图片格式。

**浏览器如何判断是否支持 webp 格式图片？**

通过创建 Image 对象，将其 src 属性设置为 Webp 格式的图片，然后在 onload 事件中获取图片的宽高，如果能够获取，则说明浏览器支持 webp 格式图片。如果不能获取或者触发 onerror 函数，那么就说明浏览器不支持 webp 格式图片。

## CSS 篇

### 1. 介绍下 BFC 及其应用

BFC（Block Format Context）块级格式上下文，是页面盒模型中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外面的元素相互不影响。

创建`BFC`的方式有：

1. `html` 根元素
2. `float` 浮动
3. 绝对定位
4. `overflow`不为`visible`
5. `display`为表格布局或者弹性布局；

`BFC` 主要的作用是：

1. 清除浮动
2. 放置同一`BFC` 容器的相邻元素之间的外边距重叠问题。

### 2. 怎么让一个 div 水平垂直居中？

```html
<style>
  <!-- 1 -- > div.parent {
    display: flex;
    justify-content: center;
    align-items: center;
  }

  <!-- 2 -- > div.parent {
    position: relative;
  }

  div.child {
    position: absolute;
    left: 50%;
    top: 50%;
    tranform: tranlate(-50%, -50%) ；;
  }

  <!-- 3 -- > div.parent {
    display: grid;
  }

  div.child {
    justify-self: center;
    align-self: center;
  }

  <!-- 4 -- > div.parent {
    font-size: 0;
    text-align: center;

    &::before {
      content: "";
      display: inline-block;
      width: 0;
      height: 100%;
      vertical-align: middle;
    }
  }

  div.child {
    display: inline-block;
    vertical-align: middle;
  }
</style>
<div class="parent">
  <div class="child"></div>
</div>
```

### 3. 介绍下重绘和回流（Repaint & Reflow），以及如何进行优化？

**重绘**

由于节点的属性发生改变或者由于样式改变而不会影响布局的，称为重绘，例如：`outline visibility color background-color`等，重绘的代价是高昂的，因此浏览器必须验证`DOM`树项其他节点元素的可见性。

**回流**

回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或整个页面）的布局更新。一个元素的回流可能会导致其所有子元素及其 DOM 中紧随其后的节点、祖先节点元素的随后的回流。大部分的回流将导致页面的重写渲染。

回流必定会发生重绘，重绘不一定会引发回流。

**浏览器优化**

现代浏览器大多是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即 16.6.ms）才会清空队列，但当你获取布局信息的时候，队列中可能有影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流和重绘来确保返回正确的值。

例如：`offsetTop clientTop scrollTop getComputedStyle() width height getBoundingClientRect()`应避免频繁使用这些属性，他们都会强制重新刷新队列。

**减少重绘和回流**

1. CSS
   1. 使用 `transform` 代替 `top`;
   2. 使用`visibility`代替 `display: none`,前者引起重绘，后者引发回流；
   3. 避免使用`table`布局
   4. 尽可能在 `DOM` 树的最末端改变 `class`；
   5. 避免设置多层内联样式，CSS 选择符从右往左匹配查找，避免节点层级过多；
   6. 将动画效果应用到`position`属性为`absolute`或`fixed` 的元素上，避免影响其他元素的布局；
   7. 避免使用 CSS 表达式，可能会引发回流；
   8. CSS 硬件加速；
2. Javascript
   1. 避免频繁操作样式，修改`class`最好
   2. 避免频繁操作`dom`，合并多次修改为一次；
   3. 避免频繁读取会引发回流或重绘的属性，将结果缓存；
   4. 对具有复杂动画的元素使用绝对定位，使它脱离文档流；

### 4. 分析比较 opacity: 0、visibility: hidden、display: none 优势和适用场景

1. display: none - 不占空间，不能点击，会引起回流，子元素不影响
2. visibility: hidden - 占据空间，不能点击，引起重绘，子元素可设置 visible 进行显示
3. opacity: 0 - 占据空间，可以点击，引起重绘，子元素不影响

### 5. 简述盒模型

盒子由`margin border padding content`组成；

标准盒模型：`box-sizing: content-box;`

IE 盒模型： `box-sizing: border-box`;

### 6. 简述 Rem 及其转换原理

`rem` 是 CSS3 新增的相对长度单位，是指相对于根元素`html`的`font-size`计算值的大小。

默认根元素的`font-size`都是`16px`的。如果想要设置`12px`的字体大小也就是`12px/16px = 0.75rem`

- 由于`px`是相对固定单位，字号大小直接被定死，无法随着浏览器进行缩放；
- `rem`直接相对于根元素`html`，避开层级关系，移动端新型浏览器对其支持较好；

### 7. 移动端视口配置

`<meta name="viewport" content="width:device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, use-scalable=no "/>`

- initial-scale：初始缩放比例；
- minimum-scale: 运行用户缩放到的最小比例；
- maximum-scale: 运行用户缩放到的最大比例；
- user-scalable: 用户是否可以手动缩放；

### 8. 简述伪类和伪元素

**伪类**

伪类用于当已有元素处于某种状态时，为其添加对应的样式，这个状态是根据用户行为变化而变化的。比如说:hover，它只有处于`dom`树无法描述的状态才能为元素添加样式，所以称为伪类。

**伪元素**

伪元素用于创建一些根本不在文档树中的元素，并为其添加样式，比如说`::before`。虽然永辉可以看到这些内容，但是其实它不在文档树中。

**区别**

伪类的操作对象是文档树中已存在的元素，而伪元素是创建一个文档树之外的元素。

css 规范中用双冒号`::`表示伪元素，用一个冒号`:`表示伪类。

### 9. 行内元素的 margin 和 padding

- 水平方向：水平方向上，都有效；
- 垂直方向：都无效；（`padding-top`和`padding-bottom`会显示出效果，但是高度不会撑开，不会对周围元素有影响）

### 10. CSS 中有哪些属性可以继承？

1. 字体系列属性
   1. font-family
   2. font-size
   3. font-weight
   4. font-style
2. 文本系列属性
   1. text-indent
   2. text-align
   3. line-height
   4. word-spacing
   5. letter-spacing
   6. color
3. 其他
   1. color
   2. visibility

### 11. CSS3 新增伪类有哪些？（例如 nth-child）

- elem:nth-child(n)：选中父元素下的第 n 个标签名为 elem 的元素；
- elem:nth-last-child(n): 作用同上，从后开始查找；
- elem:last-child: 最后一个子元素
- `elem:only-child`： 如果 elem 是父元素下唯一的子元素，则选中；
- `elem:nth-of-type(n)`：选择父元素下第 n 个 elem 类型元素；
- `elem:empty`：选中不包含子元素和内容的 elem 类型元素；
- `:not(elem)`：选择非 elem 原始的每个子元素
- `:enabled`： 启用状态的表单组件

### 12. 用纯 CSS 创建一个三角形

```css
#demo {
	width: 0;
    height: 0;
    border-width: 20;
    border-style: solid;
    border-color transparent transparent red transparent;
}
```

原理是相邻边框连接处是均分的原理。

### 13. min-width/max-width 和 min-height/max-height 属性的覆盖规则？

1. max-width 会覆盖 width，即使 width 是行内样式或者设置 !important；
2. min-width 会覆盖 max-width，此规则发生在 min-width 和 max-width 冲突的时候；

## JavaScript 篇

### 1. Vue 的响应式原理中 Object.defineProperty 有什么缺陷？为什么 Vue3.0 采用了 Proxy，抛弃了 Object.defineProperty?

原因如下：

1. `Object.defineProperty` 无法低耗费的监听到数组下标的变化，导致通过数组下标添加元素，不能实时响应；
2. `Object.defineProperty`只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历。如果属性值是对象，还需要深度遍历。`Proxy`可以劫持整个对象，并返回一个新的对象；
3. `Proxy`不仅可以代理对象，还可以代理数组。还可以动态增加的属性。

### 2. 写 React/Vue 项目时为什么要在列表组件中写 key，其作用是什么？

`vue` 和 `react`都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在`vue` 的 diff 函数交叉对比中，当新节点旧旧节点`头尾交叉对比`没有结果时，会根据新节点的`key`去对比旧节点数组中的`key`，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没有找到就认为是一个新增节点，而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言，map 映射的速度更快。

### 3. `['1', '2', '3'].map(parseInt) what & why?`

`[1, NaN, NaN]`

因为`parseInt(string, radix)`将一个字符串 string 转换为 radix 进制的整数，radix 为介于 2-36 之间的数。

在数组的 map 方法的回调函数中会传入`item（遍历项）`和`index(遍历下标)`作为前两个参数，所以这里的 parseInt 执行了对应的三次分别是：

- parseInt(1, 0)
- parsetInt(2, 1)
- parsetInt(3, 2)

### 4. 什么是防抖和节流？有什么区别？如何实现？

**防抖**

触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次触发，则重新计算时间。

```js
function debounce(fn, timing) {
  let timer;
  return function () {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn();
    }, timing);
  };
}
```

**节流**

高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行效率。

```js
function throttle(fn, timing) {
  let trigger;
  return function () {
    if (trigger) return;
    trigger = true;
    fn();
    setTimeout(() => {
      trigger = false;
    }, timing);
  };
}
```

### 5. 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

**Set**

1. 成员不能重复；
2. 只有键值，没有键名；
3. 可以遍历，方法有`add delete has`

**WeakSet**

1. 成员都是对象（引用）；
2. 成员都是弱引用，随时可以消失（不计入垃圾回收机制）。可以用来保存 DOM 节点，不容易造成内存泄漏。
3. 不能遍历，方法有`add delete has`

**Map**

1. 本质上是键值对的集合，类似集合；
2. 可以遍历，方法很多，可以跟各种数据格式转换；

**WeakMap**

1. 只接受对象为键名（null 除外），不接受其他类型的值作为键名；
2. 键名指向的对象，不计入垃圾回收机制；
3. 不能遍历，方法有`get set has delete`

### 6. ES5/ES6 的继承除了写法以外还有什么区别？

1. class 声明会 提升，但不会初始化值。
2. class 声明内部会启用严格模式；
3. class 的所有方法（包括静态方法和实例方法）都是不可枚举的；
4. class 的所有方法（包括静态方法和实例方法）都没有原型对象`prototype`，所以也没有`[[constructor]]`，不能使用`new`来调用；
5. 必须使用`new`来调用`class`;
6. class 内部无法重写类名；

### 7. setTimeout、Promise、Async/Await 的区别

setTimeout 的回调会放到宏任务队列里，等到执行栈清空以后执行；

Promise 本身是同步的立即执行函数，当在 executor 中执行 resolve 或者 Reject 的时候，此时是异步操作，会先执行 then/catch 等，当主栈完成时，才会去调用 resolve/reject 方法中存放的方法。

async 返回返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，在执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。

### 8. Async/Await 如何通过同步的方式实现异步？

Async/Await 是一个执行的`generate`函数。利用 generate 函数的特性吧异步的代码写成同步的形式。

### 9. 简述一下 Generate 函数

yield 命令是异步两个阶段的分界点。协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。

Generator 函数是协程在 ES6 的实现，最大的特点就是可以交出函数的执行权（即暂停执行）。

### 10. JS 异步解决方案的发展历程以及优缺点

**回调函数**

优点：解决了同步的问题（整体任务执行时长）

缺点：回调地狱，不能用 try catch 捕获错误，不能 return

**Promise**

优点：解决回调地狱的问题

缺点：无法取消 Promise，错误需要通过回调函数来捕获；

Generator

特点：可以控制函数的执行。

**Async/Await**

优点：代码清晰，不用向 Promise 那样写一大堆 then 链，处理了回调地狱问题；

缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。

### 11. 简述浏览器缓存读取规则

**缓存位置**

**Service Worker**

Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓冲功能。使用 Service worker 的话，传输协议必须为 HTTPS，Service Worker 的缓存与浏览器其他内建的缓存机制不同，它可以让我们自由的缓存哪些文件、如何匹配缓存、如何读取缓存，而缓存是可持续性的。Service Worker 也是 PWA 的核心技术。

**Memory Cache**

主要包含的是当前页面中已经抓取到的资源，例如页面上已经下载的样式、脚本、图片等。读取内存中的数据很高效，但是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 tab 页面，内存汇总的缓存也就被释放了。

**`Disk Cache`**

`Disk Cache` 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 `Memory Cache` 胜在容量和存储时效性上。

在所有浏览器缓存中，`Disk Cache` 覆盖面基本上是最大的。它会根据 `HTTP Header` 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。绝大部分的缓存都来自 `Disk Cache`。

**`Push Cache`**

`Push Cache`（推送缓存）是 `HTTP/2` 中的内容，当以上三种缓存都没有命中时，它才会被时候用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂（大约 5 分钟）。

**缓存过程分析**

浏览器与服务器通信的方式为应答模式。即是：浏览器发起`http`请求-服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，浏览器对于缓存的处理是根据第一次请求资源返回的响应头来确定的。

- 浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识；
- 浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器中。

### 12. 为什么 Vuex 的 mutation 和 Redux 和 reducer 中不能做异步操作？

纯函数，给定同样的输入返回同样的输出，可预测性。

### 13. 下面代码中 a 在什么情况下会打印 1？

```js
var a = ?;
if (a == 1 && a == 2 && a ==3) {
    console.log(1)
}

var a = {
    value: 0,
    valueOf() {
        return ++this.value;
    }
}
```

### 14. 在 Vue 中，子组件为何不可以修改父组件传递的 Prop，如果修改了，Vue 是如何监控到属性的修改并给出警告的。

1. 因为 vue 是单向数据流，易于检测数据的流动，出现了储物可以更加迅速的定位到错误发生的位置；
2. 通过 setter 属性进行检测，修改值将会触发 setter，从而触发警告；

### 15. 实现一个 sleep 函数？

简单

### 16.双向绑定和 vuex 是否冲突？

当在严格模式中使用 vuex 时，在属于 vuex 的 state 上使用 v-model 会导致出错。

解决方案：

1. 给 input 中绑定 value，然后侦听 input 或者 change 事件，在事件回到中调用一个方法；
2. 使用带有 setter 的双向绑定计算属性。

### 17. call 和 apply 的区别是什么？哪个性能更好一些？

区别在于传入参数的不同

apply 是传入带下标的集合，数组或者类数组，apply 把它传给函数作为参数，call 从第二喀什传入的参数是不固定的，都会传给函数作为参数。

call 比 apply 的性能要好，call 传入参数的格式正是内部所需要的格式。

### 18. 为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？

1. 能够完成整个 http 请求+响应（尽管不需要响应内容）
2. 触发 get 请求之后不需要获取和处理数据，服务器也不需要发送数据；
3. 跨域友好；
4. 执行过程无堵塞；
5. 相比 XMLHttpRequest 对象发送 get 请求，性能更好；
6. gif 的最低合法体积最小；

### 19. 实现(5).add(3).minus(2)功能

```js
Number.prototype.add = function (n) {
  return this + n;
};
Number.prototype.minus = function (n) {
  return this - n;
};
```

### 20. 操作题（考察数组基础）

某公司 1 到 12 月份的销售额存在一个对象里面 如下：{1:222, 2:123, 5:888}，请把数据处理为如下结构：[222, 123, null, null, 888, null, null, null, null, null, null, null]

```js
function convert(obj) {
  return Array.from({ length: 12 })
    .map((item, index) => obj[index] || null)
    .slice(1);
}
```

### 21. 操作题（考察消息队列）

### 22.箭头函数与普通函数（function）的区别是什么？构造函数（function）可以使用 new 生成实例，那么箭头函数可以吗？为什么？

区别如下：

1. 函数体内的 this 对象，就是定义时所在的对象，而不是使用时所在的对象；
2. 不可以使用 arguments 对象；
3. 不可以使用 yield 命令；
4. 不可以使用 new 命令，因为：
   1. 没有自己的 this，无法调用 call、apply；
   2. 没有 propotype 属性，而 new 命令在执行时需要将钩子函数的 prototype 赋值给新的对象`__proto__`

### 23. redux 为什么要把 reducer 设计成纯函数

redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处是纯函数。

### 24. ES6 代码转成 ES5 代码的实现思路是是什么？

babel 的实现方式：

1. 将代码字符串解析成抽象语法树，即所谓的 AST；
2. 对 AST 进行处理，在这个阶段可以对 ES6 AST 进行相应转换，即转换成 ES5 AST;
3. 根据处理后的 AST 在生成代码字符串；

### 25. vue 的父组件和子组件生命周期钩子执行顺序是什么？

1. 加载渲染过程：父 beforeCreate -> 父 created -> 父 beforeMount -> 子 beforeCreate -> 子 created -> 子 beforeMount -> 子 mounted -> 父 mounted。
2. 子组件更新过程：父 beforeUpdate -> 子 beforeUpdate -> 子 updated -> 父 updated
3. 父组件更新过程：父 beforeUpdate -> 父 updated
4. 销毁过程：父 beforeDestroy -> 子 beforeDestroy -> 子 destoryed -> 父 destroyed

### 26. react-router 里的 link 标签和 a 标签的区别？

1. 有 onClick 则执行 onClick
2. 阻止默认事件；
3. 在取得跳转 href，用 history/hash 跳转，此时只是链接发生改变，并没有刷新页面；

### 27. vue 在 v-for 时给每项元素绑定事件需要用事件代理吗？为什么？

在 v-for 中使用事件代理可以使监听器数量和内存占用率都减少，vue 内部并不会自动做事件代理，所以在 v-for 上使用事件代理在性能上回更优。

### 28. 谈谈对 MVC、MVP、MVVM 模式的理解

MVC

MVC 除了把应用程序分为 View、Model 层，还额外的加了一个 Controller 层，它的职责是进行 Model 和 View 之间的协作（路由、输入预处理等）的应由逻辑（application logic）；Model 进行处理业务逻辑。

用户对 View 操作以后，View 捕获到这个操作，会把处理的权利交移给 Controller（Pass calls）；Controller 会对来自 View 数据进行预处理、决定调用哪个 Model 的接口；然后由 Model 执行相关的业务逻辑；当 Model 变更了以后，会通过观察者模式（Observer Pattern）通知 View；View 通过观察者模式收到 Model 变更的消息以后，会向 Model 请求最新的数据，然后重新更新界面。

MVP

和 MVC 模式一样，用户对 View 的操作都会从 View 交易给 Presenter。Presenter 会执行相应的应用程序逻辑，并且会对 Model 进行相应的操作；而这时候 Model 执行业务逻辑以后，也是通过观察者模式把自己变更的消息传递出去，但是是传给 Presenter 而不是 View。Presenter 获取到 Model 变更的消息以后，通过 View 提供的接口更新界面。

MVVM

MVVM 可以看做是一种特殊的 MVP（Passive View）模式，或者说是对 MVP 模式的一种改良。

MVVM 代表的是 Model-View-ViewModel，可以简单把 ViewModel 理解为页面上所显示内容的数据抽象，和 Domain Model 不一样，ViewModel 更适合用来描述 View。 MVVM 的依赖关系和 MVP 依赖关系一致，只不过是把 P 换成了 VM。

MVVM 的调用关系：

MVVM 的调用关系和 MVP 一样。但是，在 ViewModel 当中会有一个叫 Binder，或者是 Data-binding engine 的东西。以前全部由 Presenter 负责的 View 和 Model 之间数据同步操作交由给 Binder 处理。你只需要在 View 的模板语法当中，指令式声明 View 上的显示的内容是和 Model 的哪一块数据绑定的。当 ViewModel 对进行 Model 更新的时候，Binder 会自动把数据更新到 View 上，当用户对 View 进行操作（例如表单输入），Binder 也会自动把数据更新到 Model 上。这种方式称为：Two-way data-binding，双向数据绑定。可以简单而不恰当地理解为一个模板引擎，但是会根据数据变更实时渲染。

### 29. 简单说说 js 中有哪几种内存泄漏的情况

1. 意外的全局变量
2. 闭包；
3. 未被清空的定时器
4. 未被销毁的事件监听
5. DOM 引用。

### 30. 跨域问题如何解决？

有服务端设置 CORS

### 31. instanceof 的实现原理

```js
while (x.__proto__) {
  if (x.__proto__ === y.prototype) {
    return true;
  }
  x.__proto__ = x.__proto__.__proto__;
}
if (x.__proto__ === null) {
  return false;
}
```

### 32. 简述执行上下文和执行栈

**执行上下文**

- 全局执行上下文：默认的上下文，任何不在函数内部的代码都在全局上下文里面。它会执行两件事情：创建一个全局的 window 对象，并且设置 this 为这个全局对象。一个程序只有一个全局对象。
- 函数执行上下文：每当一个函数被调用时，就会为该函数创建一个新的上下文，每个函数都有自己的上下文，不过是在函数调用的时候创建的。函数上下文可以有任意多个，每当一个新的执行上下文被创建，它会按照定义的顺序执行一系列的步骤。
- Eval 函数执行上下文：执行在 eval 函数内部的代码有它自己的执行上下文；

**执行栈**

执行栈就是一个调用栈，是一个后进先出的数据结构的栈，用来存储代码运行时创建的执行上下文；

**this 绑定**

全局执行上下文中，this 指向全局对象；

函数执行上下文中，this 取决于函数是如何被调用的。如果他被一个引用对象调用，那么 this 会设置成那个对象，否则是全局对象。

### 34. 简述浏览器与 Node 的事件循环

**浏览器**

- 宏任务：script 中的代码、setTimeout、setInterval、I/O、 UI render
- 微任务：promise (async/await)、Object.observe、MutationObserver。

**Node**

- 宏任务：setTimeout setInterval setImmediate script IO 操作等；
- 微任务：process.nextTick(与普通的微任务有区别，在微任务队列执行之前执行)、new Promise().then(回调)

**区别：**

- node 环境下的 setTimeout 定时器会依次一起执行，浏览器是一个一个分开的；
- 浏览器环境下微任务的执行是在每个宏任务执行之后，而 node 中的微任务会在各个阶段执行，一个阶段结束立刻执行 microTask；

### 35. 什么是 CSP?

内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截浏览器自己来实现。

### 36. 什么是 CSRF 攻击？如何防范 CSRF 攻击？

跨站请求伪造攻击，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态（cookie），绕过后台的用户验证，冒充用户向服务器执行一些操作。

CSRF 攻击的本质是利用了 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。

防护方法：

- 同源检测，服务器检测请求来源；
- 使用 token 来进行验证；
- 设置 cookie 时设置 Samesite，限制 cookie 不能作为第三方使用；

### 37. 谈一谈你理解的函数式编程？

函数式编程是一种编程范式，也就是如何编写程序的方法论。

它具有一下特性：闭包和高阶函数、惰性运算、递归、函数是第一等公民，只用表达式。

### 38. 什么是尾调用？

尾调用指的是函数的最后一步调用另一个函数。我们代码执行是基于执行栈的，所以当我们在一个函数里调用另一个函数时，我们会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这个时候我们可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。

### 29. vue 组件间如何通信？

父子组件通信

1. props + emit
2. $refs + $parent
3. provider/inject

兄弟组件通信

1. eventBus
2. $parent.$refs

### 30. vue 中 computed 和 watch 的差异？

1. computed 是计算一个新的属性，并将该属性挂载到 vue 实例上，而 watch 是监听已经存在且已挂载到 vue 实例上的数据，所以用 watch 同样可以监听 computed 计算属性的变化；
2. computed 本质是一个惰性求值的观察者，具有缓存性，只有当依赖变化后，第一次访问 computed 值，才会计算新的值。而 Watch 则是当数据发生变化便会调用执行函数；
3. 从使用场景上来说，`computed` 适用一个数据被多个数据影响，而 `watch` 使用一个数据影响多个数据。

### 31. 简述一下 PWA

pwa 渐进式网页应用，目的是提升 Web App 的性能，改善 Web App 的用户体验。

特点：

1. 可安装：可以像原生 APP 在主屏幕上留有图标；
2. 离线应用：可以离线使用，别后用的技术是 Service Worker
3. service worker 实际上是一段脚本，在后台运行。作为一个独立的线程，运行环境和普通脚本不同，所以不能直接参与 web 交互行为，属于一种客户端代理。
4. service worker 可以创建有效的离线体验，拦截网络请求，并根据网络是否可用判断是否使用缓存数据或者更新缓存数据。
5. 消息推送。

### 32. 介绍下 CacheStorage

CacheStorage 接口表示 `Cache` 对象的存储。它提供了一个 `ServiceWorker`、其他类型 woker 或者 `window` 范围内可以访问到的所有命名 `cache` 的主目录（它并不是一定要和 `service workers` 一起使用，即使它是在 service workers 规范中定义的），并维护一份字符串名称到相应 `Cache` 对象的映射。

CacheStorage 和 Cache，是两个与缓存相关的接口，用于管理当前网页/Web App 的缓存；在使用 Service Worker 时基本都会用到。它们与数据库有点类似，我们可以用 mongodb 来打个比喻：

- CacheStorage 管理者所有的 Cache，是整个缓存 api 的入口，类似于 mongo；
- Cache 是单个缓存库，通常一个 app 会有一个，类似 mongo 里的每个 db；

无论在 ServiceWorker 域或 window 域下，你都可以用 caches 来访问全局的 CacheStorage。

### 33. vue 双向数据绑定原理

vue 通过双向数据绑定，来实现了 view 和 model 的同步更新。vue 的双向数据绑定是通过数据劫持和发布订阅者模式来实现的。

首先我们通过 Object.defineProperty()方法来对 Model 数据各个属性添加访问器属性，以此来实现数据的劫持，因此当 Model 中的数据发生变化的时候，我们可以通过配置的 setter 和 getter 方法来实现对 view 层数据更新的通知。

对于文本节点的更新，我们使用了发布订阅者模式，属性作为一个主题，我们为这个节点设置一个订阅者对象，将这个订阅者对象加入这个属性主题的订阅者列表中。当 Model 层数据发生改变的时候，Model 作为发布者向主题发出通知，主题收到通知再向它的所有订阅者推送，订阅者收到通知后更改自己的数据。

### 34. 页面的可用性时间的计算

Performance 接口可以获取到当前页面中与性能相关的信息。

- Performance.timing:`Performance.timing` 帝乡包含延迟相关的性能信息。

### 35. 简述一下 WebAssembly

WebAssembly 是一种新的编码方式，可以在现代的网络浏览器中运行 - 它是一种低级的类汇编语言，具有紧凑的二进制格式。可以接近原生的性能运行，并为诸如 C/C++等语言提供一个编译目标，以便它们可以在 Web 上运行。它也被设计为可以与 JavaScript 共存，运行两者一起工作。

WebAssembly 提供了一条途径，以使得以各种语言编写的代码都可以接近原生的的速度在 Web 中运行。

### 36. 移动端点击

**移动端 300 ms 点击（click 事件）延迟**
由于移动端会有双击缩放的这个操作，因此浏览器在 click 之后要等 300ms，判断这次操作是不是双击。
解决方案：

1. 禁用缩放：user-scalable=no
2. 更改默认的视口宽度
3. CSS touch-action

**点击穿透问题**
因为 click 事件的 300ms 延迟问题，所以有可能会在某些情况下触发多次事件。
解决方案：

1. 只用 touch
2. 只用 click

### 37. Get-Rebase

1. 可以合并多次提交记录，减少无用的提交信息；
2. 合并分支并减少 commit 记录；

### 38. 懒加载

懒加载也叫延迟加载，指的是在长网页中延迟加载图像，是一种很好优化网页性能的方式。

优点：

1. 提升用户体验，加快首屏渲染速度；
2. 减少无效资源的加载；
3. 防止并发加载的资源过多会堵塞 js 的加载；

原理：
首先将页面上的图片的`src`属性设为空字符串，而图片的真实路径则设置在`data-original`属性中，当页面滚动的时候需要去监听`scroll`事件，在`scroll`事件的回调中，判断我们的懒加载的图片是否既然怒可视区域，如果图片在可视区内则将图片的`src`属性设置为`data-original`的值，这样就可以实现延迟加载。

### 39. webpack 中 loader 和 plugin 的区别是什么？

loader: loader 是一个转换器，将 A 文件进行编译成 B 文件，属于单纯的文件转换过程；

plugin：plugin 是一个扩展器，它丰富了 Webpack 本身，针对是 loader 结束后，webpack 打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听 webpack 打包过程中的某些节点，执行广泛的任务。

### 40. 有三个 Promise，如何等待三个 Promise 都“成功”或“失败”后执行某种操作？

TC39 第 4 阶段草案
Promise.allSettled()

```js
function genPromise(promise1) {
  return new Promise(async (resolve) => {
    promise1
      .then((res) => {
        resolve(res);
      })
      .catch((err) => {
        resolve(err);
      });
  });
}

Promise.myAll = function (...values) {
  return Promise.all(values.map((item) => genPromise(item)));
};
```

### 41. 对原型的理解！！！

ECMA-262 把原型定义为 ECMAScript 的主要继承方式。其基本思想

## 函数执行结果

### 1. this 指针

```js
function Foo() {
  Foo.a = function () {
    console.log(1);
  };
  this.a = function () {
    console.log(2);
  };
}
Foo.prototype.a = function () {
  console.log(3);
};
Foo.a = function () {
  console.log(4);
};
Foo.a();
let obj = new Foo();
obj.a();
Foo.a();
```

打印结果：4 2 1

### 2. 对象应用

```js
function changeObjProperty(o) {
  o.siteUrl = "http://www.baidu.com";
  o = new Object();
  o.siteUrl = "http://www.google.com";
}
let webSite = new Object();
changeObjProperty(webSite);
console.log(webSite.siteUrl);
```

输出为：http://www.baidu.com

### 3. 事件循环/异步

```js
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}
async function async2() {
  console.log("async2");
}
console.log("script start");
setTimeout(function () {
  console.log("setTimeout");
}, 0);
async1();
new Promise(function (resolve) {
  console.log("promise1");
  resolve();
}).then(function () {
  console.log("promise2");
});
console.log("script end");
```

运行结果：
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout

### 4. React 的使用

```js
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      val: 0,
    };
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 1 次 log

    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 2 次 log

    setTimeout(() => {
      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 3 次 log

      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 4 次 log
    }, 0);
  }

  render() {
    return null;
  }
}
```

输出结果：0 0 2 3

1. 第一次和第二次都是在 react 自身声明周期内，触发时`isBatchingUpdates`为`true`,所以并不会直接执行更新 state，而是加入了`dirtyComponents`，所以打印时获取的都是更新前的状态；
2. 两次 `setState`，获取到 `this.state.val` 都是 0，所以执行时都是将 0 设置成 1，在 `react` 内部会被合并掉，只执行一次，设置完成后 `state.val` 值为 1.
3. `setTimeout` 中的代码，触发时 `isBatchingUpdate` 为 `false`，所以能够直接进行更新，所以连着输出 `2、3`

### 5. 作用域

```js
var b = 10;
(function b() {
  b = 20;
  console.log(b);
})();
```

```
ƒ b(){
    b = 20;
    console.log(b);
}
```

原因：
作用域：执行上下文包含作用域链；
特性：声明提前：一个声明在函数体内都是可见的，函数声明优先于变量声明；
在非匿名自执行函数中，函数变量为只读状态无法修改；

### 6. 作用域

```js
var a = 10;
(function () {
  console.log(a);
  a = 5;
  console.log(window.a);
  var a = 20;
  console.log(a);
})();
```

输出：undefined 10 20

### 7. 数组

```js
var obj = {
  2: 3,
  3: 4,
  length: 2,
  splice: Array.prototype.splice,
  push: Array.prototype.push,
};
obj.push(1);
obj.push(2);
console.log(obj);
```

输出：[,,1,2] length 为 4
解释：`Array.prototype.push` 将根据`length` 将元素填充到对应位置并修改 `length`属性 + 1。

### 8. 赋值表达式

```js
var a = { n: 1 };
var b = a;
a.x = a = { n: 2 };

console.log(a.x);
console.log(b.x);
```

输出结果：
undefined
{n: 2}

### 9. 赋值表达式

```js
// example 1
var a={}, b='123', c=123;
a[b]='b';
a[c]='c';
console.log(a[b]);

---------------------
// example 2
var a={}, b=Symbol('123'), c=Symbol('123');
a[b]='b';
a[c]='c';
console.log(a[b]);

---------------------
// example 3
var a={}, b={key:'123'}, c={key:'456'};
a[b]='b';
a[c]='c';
console.log(a[b]);
```

c b c

## 源码相关

### 1. 手写 bind、call、apply

```js
Function.prototype.MyCall = function (context) {
  const args = [...arguments].slice(1);

  context.fn = this;

  const result = context.fn(...args);
  delete context.fn;

  return result;
};

Function.prototype.MyApply = function (context) {
  const args = arguments[1] || [];

  context.fn = this;
  const result = context.fn(...args);
  delete context.fn;

  return result;
};

Function.prototype.MyBind = function (context) {
  let self = this;

  return function () {
    self.MyApply(context, [...arguments]);
  };
};
```

## 网络相关

### 1. HTTP1.0 和 HTTP1.1 有什么区别？

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页和网络请求上。而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求总，同时 HTTP1.0 也是当前使用最为广泛的 HTTP 协议。主要区别体现在：

1. 缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since Expires 来作为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag 、 If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。

2. 带宽优化及网络连接的使用：HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，而且不支持断点续传功能，HTTP1.1 则在请求头中引入了`range`头域，它允许只请求资源的某个部分，即返回码是 206 （Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3. 错误通知的管理：在 HTTP1.1 中新增了 24 个错误状态响应码，如 `409（Conflict）` 表示请求的资源与资源的当前状态发生冲突；`410（Gone）`表示服务器的某个资源被永久性的删除；

4. Host 头处理：在 HTTP1.0 中认为每台服务器都绑定唯一的 IP 地址，因此去哪个求信息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且他们可以共享一个 IP 地址。HTTP1.1 的请求信息和响应信息都应该支持 Host 头域，且请求信息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

5. 长连接：HTTP1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection: Keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。

### 2. http2 的多路复用

在 HTTP/1 中，每次请求都会建立一次 HTTP 连接，也就是我们常说的 3 次握手和 4 次挥手，这个过程在一次请求过程中占用了相当长的时间，即使开启了 `Keep-Alive`，解决了多次连接的问题，但是依然有两个效率上的问题，一是串行的文件传输，二是连接数过多导致的性能问题。

HTTP/2 的多路复用就是为了解决上述的两个性能问题。

在 HTTP/2 中，有两个非常重要的概念，分别是帧（frame）和流（stream）。帧代表着最小的数据单位，每个帧会标识出该帧属于哪个流，流也就是多个帧组成的数据流。

多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。

### 3. HTTPS 握手过程

1. 客户端使用 `https` 的 `url` 访问 web 服务器，要求与服务器建立 `ssl` 连接；
2. web 服务器收到客户端请求后，会将网站的证书（包含公钥）传送一份给客户端；
3. 客户端收到网站证书后会检查证书的颁发机构以及过期时间，如果没有问题就随机产生一个秘钥；
4. 客户端利用公钥将会话秘钥加密，并传送给服务端，服务端利用自己的私钥解密出会话秘钥；
5. 之后服务器与客户端使用秘钥加密传输；

### 4. HTTPS 握手过程中，客户端如何验证证书的合法性

1. 首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内；
2. 浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发；
3. 如果找不到，浏览器就会报错，说明浏览器发来的证书是不可信任的；
4. 如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥（多数浏览器开发商发布版本时，会实现在内部植入常用认证机关的公开密钥），然后对服务器发来的证书里面的签名进行解密；
5. 浏览器使用相同的 `hash` 算法计算出服务器发来的证书的 `hash` 值，将这个计算的 `hash` 值与证书中签名做对比；
6. 对比结果一致，则证明服务器发来的证书合法，没有被冒充；

### 5. 如何实现 token 加密

JWT 加密：

1. 需要一个 secret（随机数）；
2. 后端利用 secret 和加密算法（如：HMAC-SHA256）对 payload（如账号密码）生成一个字符串（token），返回前端；
3. 前端每次 request 在 header 中带上 token；
4. 后端用同样的算法解密；

### 6. HTTPS 中间人攻击

https 协议由 http + ssl 协议构成。

中间人攻击过程如下：

1. 服务器向客户端发送公钥；
2. 攻击者截获公钥，保留在自己手上；
3. 然后攻击者自己生成一个【伪造的】公钥，发给客户端；
4. 客户端收到伪造的公钥后，生成加密 hash（秘钥） 值发给服务器；
5. 攻击者获得加密 hash 值，用自己的私钥解密获得真秘钥；
6. 同时生成假的加密 hash 值，发给服务器；
7. 服务器用私钥解密获得假秘钥；
8. 服务器用假秘钥加密传输信息；

防范方法：

1. 服务器在发送浏览器的公钥中加入 CA 证书，浏览器可以验证 CA 证书的有效性；（现有 HTTPS 很难被劫持，除非信任了劫持者的 CA 证书）。

### 7. HTTP 状态码及其功能

100~199：信息提示
200~299：成功
300~399：重定向
400~499：客户端错误
500~599：服务端错误

- 200 成功
- 204 无内容
- 301 永久移动（回应 GET 响应时会自动将请求者转到新位置）
- 304 未修改（协商缓存）
- 400 Bad Request
- 401 未授权
- 403 服务器拒绝请求
- 404 未找到
- 409 请求发生冲突
- 500 服务器内部错误
- 502 错误网关
- 503 服务不可用

### 8. 从输入 url 到页面加载的全过程

1. 浏览器获取用户输入，等待 url 输入完毕，触发 enter 事件；
2. 解析 url，分析协议头，在分析主机名是域名还是 IP 地址；
3. 如果主机名是域名的话，则发送一个 DNS 查询请求到 DNS 服务器，获得主机 IP 地址；
4. 使用 DNS 获取到主机 ip 地址后，向目的地地址发送一个（http/https/protocol）请求，并且在网络套接字上自动添加端口信息（http 80 https 443）
5. 等待服务器响应结果；
6. 将响应结果（HTML）经浏览器引擎解析后得到`Render Tree`，浏览器将`Render tree`进行渲染后显示在显示器中，用户此时可以看到页面被渲染。

### 9. HTTP2.0 与 HTTP1.0 相较于之前版本的改进

**HTTP2.0**

1. HTTP2.0 基本单位为二进制，以往是采用文本形式，健壮性不是很好，现在采用二进制格式，更方便更健壮。
2. HTTP2.0 的多路复用，把多个请求当做流，请求响应数据分成多个帧，不同流中的帧交错发送，解决了 TCP 连接数量多，TCP 连接慢，所以对于同域个域名只用创建一个连接就可以了。
3. HTTP2.0 压缩消息头，避免了重复请求头的传输，又较少了传输的大小。
4. HTTP2.0 服务端推送，浏览器发送请求后，服务端会主动发送与这个请求相关的资源，之后浏览器就不用再次发送后续的请求了。
5. HTTP2.0 可以设置请求优先级，可以按照优先级解决堵塞问题；

**HTTP1.1**

1. 缓存处理新增 E-Tag、If-None-Match 之类的缓存来控制缓存；
2. 长连接，可以在一个 TCP 连接上发送多个请求和响应。

### 10. ssl 连接断开后如何恢复？

**Session ID**
每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。

**Session Ticket**
session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器可能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。

### 11. 什么是 CDN 服务？

CDN 是一个内容分发网络，通过对源网站资源的缓存，利用本身多台位于不同地域、不同运营商的服务器，向用户提供资源就近访问的功能。也就是说，用户的请求并不是直接发送给源网站，而是发送给 CDN 服务器，由 CDN 服务器将请求定位到最近的含有该资源的服务器上去请求。这样有利于提高网站的访问速度，同时通过这种方式也减轻了源服务器的访问压力。

**CDN 访问过程**

1. 用户输入访问的域名,操作系统向 LocalDns 查询域名的 ip 地址.
2. LocalDns 向 ROOT DNS 查询域名的授权服务器(这里假设 LocalDns 缓存过期)
3. ROOT DNS 将域名授权 dns 记录回应给 LocalDns
4. LocalDns 得到域名的授权 dns 记录后,继续向域名授权 dns 查询域名的 ip 地址
5. 域名授权 dns 查询域名记录后(一般是 CNAME )，回应给 LocalDns
6. LocalDns 得到域名记录后,向智能调度 DNS 查询域名的 ip 地址
7. 智能调度 DNS 根据一定的算法和策略(比如静态拓扑，容量等),将最适合的 CDN 节点 ip 地址回应给 LocalDns
8. LocalDns 将得到的域名 ip 地址，回应给 用户端
9. 用户得到域名 ip 地址后，访问站点服务器
10. CDN 节点服务器应答请求，将内容返回给客户端.(缓存服务器一方面在本地进行保存，以备以后使用，二方面把获取的数据返回给客户端，完成数据服务过程)

## 设计模式

### 1. 什么是设计模式？设计模式如何解决复杂问题？

设计模式描述了一个我们周围不断发生的问题，以及解决该问题方案的的核心。有了设计模式，我们就可以一次又一次的使用该方案而不用重复劳动。

设计模式主要通过两个方面来解决复杂问题。

1. 分解：将复杂的问题分解成多个简单问题。
2. 抽象：忽略问题的本质细节，去处理泛化和理想化了的对象模型。

### 2. 什么是白箱复用和黑箱复用？

白箱复用就是 B 类继承 A 类的功能，同时需要了解 A 类的内部细节，从而达到复用的效果，耦合性较强。
在黑盒复用中，B 类只需要关注 A 类所暴露的一些外部方法即可达到复用的效果，达到了解耦的效果。

### 3. 介绍下观察者模式和订阅-发布模式的区别，各自适用什么场景？

观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知。

一对多时使用观察者模式，多对多时使用订阅-发布模式

### 4. 面向对象的设计原则

1. 依赖倒置原则

- 高层模块（稳定）不应该依赖低层模块（变化），两则都应该依赖于抽象（稳定）；
- 抽象（稳定）不应该依赖于实现细节（变化），实现细节（变化）应该依赖于抽象（稳定）；

2. 开放封闭原则

- 对扩展开放，对更改封闭；
- 类模块应该是可扩展的，但是不可修改；

3. 单一职责原则

- 一个类应该只有一个引起它变化的原因；
- 变化的方向隐含了类的责任；

4. Liskov 替换原则
   子类必须能够替换他们的基类；
   继承表达类型抽象

5. 接口隔离原则
   不应该强迫客户端使用他们不用的方法；
   接口应该小而完备

6. 优先使用对象组合，而不是类继承

   - 类继承通常为“白箱复用”，对象组合通常为“黑箱复用”；
   - 继承在某种程度上破坏了封装性，子类父类耦合度高；
   - 而对象组合则只要求被组合的对象具有良好定义的接口，耦合度低；

7. 封装变化点

   - 使用封装来创建对象之间的分界层，让设计者可以在分界层的一侧进行修改，而不会对另一侧产生不良的影响，从而实现层次间的松耦合；

8. 正对接口编程，而不是针对实现编程
   - 不将变量类型声明为具体的某个类，而是声明为某个接口；
   - 客户程序无须获取对象的具体类型，只需要知道对象所具有的接口；
   - 减少系统中的各部分依赖关系，从而实现“高内聚、低耦合”的类型设计方案；

### 4. 了解的设计模式及应用场景

**组件协作**

1.Template Method 模式：

- 模式定义：定义一个操作的算法的骨架（稳定），将一些步骤（变化）延迟到子类中；
- 应用场景：React 生命周期；

2. Observer 模式：

- 模式定义：定义对象间的一种一对多（变化）的依赖关系，以便当一个对象（Subject）的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。
- 应用场景：Redux 实现。

3. Strategy 模式；
   定义：定义一系列算法，把它们一个个封装起来，并且使它们可相互替换（变化）。该模式使得算法可独立于使用它的客户程序（稳定）而变化（扩展、子类化）。
   应用：国际化、多种输入一种输出

**单一职责**

1. 装饰者模式
   定义：动态（组合）地给一个对象增加一些额外的职责，就增加功能而言，装饰者模式比生成子类（继承）更加灵活；
   应用：React 高阶组件、中间件。

2. Bridge 模式：
   定义：将抽象业务（业务功能）与实现部分（平台实现）分离，使它们都可以独立地变化。
   场景：组件组合功能。

**对象创建**

1. 工厂方法模式
   定义：定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method 是的一个类的实例化延迟（目的：解耦，手串：抽象）到子类。
2. 抽象工厂
   定义：提供一个接口，让该接口负责创建一系列“相关或者项目依赖的对象”，无需指定它们具体的类。

**对象性能**

1. Singleton 模式：
   - 模式定义：保证一个类只有一个实例，并提供一个该实例的全局访问点。
   - 应用场景：游戏中的主角类实例。
2. FlyWeight（享元模式）：
   - 模式定义：运行共享技术有效地支持大量细粒度的对象。
   - 应用场景：对象池优化。

**接口隔离**

1. Facade 模式：
   - 模式定义：为子系统中的一组接口提供一致（稳定）的界面，Facade 模式定义了一个高层接口，这个接口使得这个子系统更加容易使用（复用）。
   - 应用场景：各种硬件驱动。
2. Proxy 模式：
   - 模式定义：为其他对象提供一种代理以控制（隔离、使用接口）对这种对象的访问。
   - 应用场景：使用闭包导出方法（代理操作对象）。
3. Adapter 模式：
   - 模式定义：将一个类的接口转换为客户希望的另一个接口。Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
   - 应用场景：Go 中的 `http.ListenAndServe` 所接受的结构体只需要实现 `ServeHTTP` 方法即可满足 `http` 的接口条件。
4. Composite 模式：
   - 模式定义：将对象组合成树形结构以表示“部分-整体”的层次结构。Composite 使得用户对单个对象和组合对象的使用具有一致性（稳定）。
   - 应用场景：在树形结构中，`Parent Node` 和 `Child Node` 都继承于同一抽象类 `Node`，都使用 `process` 方法来执行自身的方法。

## Nodejs 篇

### 1. Node 里的模块是什么？

Node 中的每个文件都是一个对象，它的定义如下：

```js
function Module(id, parent) {
  this.id = id;
  this.exports = {};
  this.filename = null;
  this.loaded = false;
  this.children = [];
}

module.exports = Module;

var module = new Module(filename, parent);
```

### 2. require 的模块加载机制

1. 计算模块绝对路径；
2. 如果缓存中有该模块，则从缓存中取出该模块；
3. 按优先级一次寻找并编译执行模块，将模块推入缓存（require.cache）中；
4. 输出模块的 `exports` 属性；

### 3. node 中的内存泄漏和解决方案

原因：

1. 全局变量：全局变量挂在 root 对象上，不会被清除掉；
2. 闭包：如果闭包未释放，就会导致内存泄漏；
3. 事件监听：对同一事件重复监听，忘记移除（removeListener），将造成内存泄露。

解决方案：
格外小心事件监听；
如果出现了内存泄露问题，需要检测内存使用情况，对内存泄露的位置进行定位，然后对对应的内存泄露代码进行修复。

### 4. 在 Node 中两个模块相互引用会发生什么？

假设 A 和 B 模块相互引用，此时运行 A 模块的话，先运行的 A 模块将会被缓存，但是此时缓存的是一个为执行完毕的 A 模块，而 A 模块中引入的模块将会被完整加载并且正常使用，而 B 模块中调用的 A 模块将会是默认的空对象（module.exports 的默认值），不具备 A 模块的任何功能。

### 5. 如何实现热更新？

Node 中有一个 api 是`require.cache`，如果这个对象中的引用被清除后，下载再调用就会重新加载，这个机制可以用来热加载更新的模块。

```js
function clearCache(modulePath) {
  const path = require.cache(modulePath);
  if (require.cache[path]) {
    require.cache[path] = null;
  }
}
```

然后使用`fs.watchFile`监听文件的更改，文件更改后调用`clearCache`传入对应的模块名即可。

使用`pm2 reload`也可以实现暴力热更新，它会保证在新的实例重启成功后才会把旧的进程杀死，可以保持服务一直能够响应，服务能够一直保证在可响应状态。

### 6. 为什么 Node.js 不给每一个.js 文件以独立的上下文来避免作用域被污染？

Node.js 模块正常情况下对作用域不会造成污染（模块函数内执行），以外创建全局变量是一种例外，可以采用严格模式来避免。

### 7. Node.js 更适合处理 I/O 密集型任务还是 CPU 密集型任务？为什么？

Node 更适合处理 I/O 密集型的任务。因为 Node 的 I/O 密集型任务可以异步调用，利用事件循环的处理能力，资源占用极少，并且事件循环能力避开了多线程的调用，在调用方面是单线程，内部处理其实是多线程的。

并且由于 JavaScript 是单线程的原因，Node 不适合处理 CPU 密集型的任务，CPU 密集型的任务会导致 CPU 时间片不能释放，使得后续 I/O 无法发起，从而造成阻塞。但是可以利用多进程的特点完成对一些 CPU 密集型任务的处理，不过由于 JavaScript 并不支持多线程，所以在这方面的里能力会弱于其他多线程语言。

### 8.Node 的垃圾回收机制

V8 引擎的垃圾回收机制根据对象的存活时间采用了不同的算法，使得垃圾回收变得更高效。
在 V8 中，内存分为新生代与老生代。

对于新生代的内存采取的是将内存区一份为二，将存活的对象从一个区赋值到另一个区，然后对原有的区进行内存释放，反复如此。当一个对象经过多次赋值依然存活时，这个较长生命周期的对象会被移动到老生代中。

对于老生代的垃圾回收采用的是标记清除算法，遍历所有对象并标记仍然存在的对象，然后在清除节点将没有标记的对象进行清除，最后将清除后的空间进行内存释放。

### 9. node 的 异步 I/O

在进程启动时，Node 便会创建一个类似于 while(true)的循环，每执行一次循环体的过程称为 Tick。每个 Tick 的过程就是查看是否有时间待处理，如果有，就取出时间及其相关的回调函数。如果存在关联的回调函数，就执行它们。然后进入下个循环，如果不在有事件处理，就退出进程。（每一次 Tick 都会把观察者中可执行的事件执行完毕后，在进行下一次的 Tick）

事件循环是一个典型的生产者/消费者模型。异步 I/O、网络请求等则是事件的生产者，生产出的时间被传递到对应的观察者，事件循环从观察者取出事件并处理（消费者）。

## Vue 篇

### 1. Vue.nextTick 的原理和用途

Vue 事项响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。

Vue 是异步执行 DOM 更新的。

异步执行的运行机制如下：

1. 所有同步任务都在主线程上执行，行程一个执行栈（execution context stack）。
2. 主线程之外，还存在一个“任务队列”（task queue）。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。
3. 一旦“执行栈”中的所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。
4. 主线程不断重复上面的三步。

简单来说，Vue 在修改数据后，视图不会立即更新，而是等同一事件循环中的所有数据变化完成之后，在同一进行视图更新。

Vue.nextTick：下次 DOM 更新循环结束之后。

**用途**
应用场景：需要在视图更新之后，基于新的视图进行操作。

需要注意的是，在 created 和 mounted 阶段，如果需要操作渲染后的视图，也要使用 nextTick 方法。
官方文档说明：
注意 mounted 不会承诺所有的子组件也都被一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted
