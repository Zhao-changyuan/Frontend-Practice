
# JavaScript语法（预备篇）：到底要不要写分号呢？

## 自动插入分号规则
自动插入分号的规则其实独立于所有的语法产生式定义，规则如下：
    1. 要有换行符，且下一个符号是不符合语法的，那么就尝试插入分号；
    2. 有换行符，且语法中规定此处不能有换行符，那么就自动插入分号；
    3. 源代码结束处，不能形成完整的脚本或者模块结构，那么就自动插入分号；

带换行符的注释也被认为是有换行符；

## no LineTerminator here 规则
no LineTerminator here规则表示它所在的结构中的这一位置不能插入换行符。
自动插入分号规则的第二条：有换行符，且语法中规定此处不能有换行符，那么就自动插入分号。

规则如下：
* 带标签的 continue 语句，不能在 continue 语句后插入换行；
* 带标签的break语句，不能在break后插入换行；
* return后不能插入换行；
* 后自增、后自减运算符前不能插入换行；
* throw和Exception之间不能插入换行；
* 凡是async关键字，后面都不能插入换行；
* 箭头函数的箭头前，也不能插入换行；
* yield之后，不能插入换行；

## 不写分号需要注意的情况

* 以括号开头的语句
* 以数组开头的语句
* 以正则表达式开头的语句
* 以Template开头的语句

# 第12讲： JavaScript语法（一）：在script标签写export为什么会抛错？

## 脚本和模块
脚本是可以由浏览器或者node缓解引入执行的，而某块只能由JavaScript代码用import引入执行。

从概念上，我们可以任务脚本具有主动性的JavaScript代码段，是控制宿主王成一定任务的代码；而模块是被动性的JavaScript代码段，是等待被调用的库。

### import 声明
直接import一个模块，只能保证了这个模块代码被执行，引用它的模块是无法获得它的任何信息的。

带from的import意思是引入模块中的一部分信息，可以把它们变成本地的变量。

导入与一般的赋值不同，导入后的变量只是改变了名字，它仍然与原来的变量是同一个。

### export 声明
export声明承担的是导出的任务。

## 函数体
宏任务中可能会执行的代码包括“脚本（script）” “模块（module）”和“函数体（function body）”。

函数体其实也是语句的列表。跟脚本和模块比起来，函数体中的语句列表中多了return语句可以用。

## 预处理
预处理过程会提前处理var、函数声明、class、const和let这些语句，以确定其中变量的意义。

### var声明
var声明永远作用域脚本、模块和函数体这个级别，在预处理阶段，不关心赋值的部分，只管在当前作用域声明这个变量。

var的作用域能够穿透一切语法结构，它只认脚本、模块和函数体三种语法结构。

### function 声明
在全局（脚本、模块和函数体），function声明表现跟var相似，不同之处在于，function声明不但在作用域中加入变量，还会给它赋值。

function声明出现在if等语句中的情况有点复杂，他仍然作用于脚本、模块和函数体级别，在预处理阶段，仍然会产生变量，它不再被提前赋值。

### class 声明
在class声明之前使用class名，会报错。
出现在后面的class声明影响了前面语句的结果。

class声明也是会被预处理的，它会在作用域中创建变量，并且要求访问它时抛出错误。
class的声明作用不会穿透if等语句结果，所以只有在全局环境才会有声明作用。

按照现代语言设计的评价标准，及早抛错是好事，它能够帮助我们尽早在开发阶段就发现代码的可能问题。

## 指令序言机制
“use strict”是JavaScript标准中规定的唯一一种指令序言，但是设计指令序言的目的是，留给JavaScript的引擎和实现者一些统一的表达方式，在静态扫描时指定JavaScript代码的一些特性。

# 第13讲：JavaScript语法（二）：你知道哪些JavaSrcipt语句？

## 语句块
语句块的意义和好处在于：让我们可以把多行语句视为同一行语句，语句块会产生作用域。

## 空语句
一个独立的分号。

## if语句

## switch语句
建议：switch已经完全没有必要使用了，应该用if else结构代替。

## 循环语句
### while循环和do while循环

### 普通for循环

### for in循环
for in循环枚举对象的属性，这里体现了属性的enumerable特征。

### for of 循环和 for await of 循环
实际上，它背后的机制是interator机制。

## return

## break 语句和 continue 语句
带标签的break和continue可以控制自己被外层的哪个语句结构消费，这可以跳出复杂的语句结构。

## with 语句
一般认为它属于糟粕。

## try 语句和throw 语句

## debugger 语句
在没有调试器挂载时，它不产生任何效果。

## var
在现在，在绝大多数情况下，let和const都是更好的选择。

如果依然想要使用var，建议把它当做一种“保障变量是局部”的逻辑，遵循以下三条规则：
* 声明时必定初始化；
* 尽可能在离使用的位置近处声明；
* 不要在意重复声明

## let 和 const
let和const的作用范围是if、for等结构型语句。


