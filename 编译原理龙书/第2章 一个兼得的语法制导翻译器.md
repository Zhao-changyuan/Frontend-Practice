
## 2.1 引言
将表达式翻译为后缀形式的过程可以充分演示语法分析技术。

词法分析器是的翻译器可以处理由多个字符组成的构造，比如标识符。标识符由多个字符组成，但是在语法分析阶段被当做一个单元进行处理。这样的单元称为词法单元（token）。

## 2.2 语法定义

“上下文无关文法”
文法自然地描述了大多数程序设计语言构造的层次化语法结构。

在一个产生式中，像关键字if和括号这样的词法元素称为终结符号（terminal）。像expr和stmt这样的变量表示终结符号的序列，它们称为非终结符（nonterminal）。

### 2.2.1 文法定义

一个上下文无关文法（context-free grammar）有四个元素组成：
1. 一个终结符号集合，他们有时也称为“词法单元”。终结符号是该文法所定义的语言的基本符号的集合。
2. 一个非终结符号集合，它们有时也称为“语法变量”。每个非终结符号表示一个终结符号传的集合。
3. 一个产生式集合，其中每个产生式包括一个称为产生式头或左部的非终结符号，一个箭头，和一个称为产生式体或右部的由终结符号及非终结符号组成的序列。产生式主要用来表示某个构造的某种书写形式。如果产生式头非终结符号代表一个构造，那么该产生式体就代表了该构造的一种书写方式。
4. 指定一个非终结符号为开始符号。

在描述文法的时候，我们会列出该文法的产生式，并且首先列出开始符号对应的产生式。
为表示方便，以同一个非终结符号为头部的多个产生式的体可以放在一起表示，不同体之间用符号|（读作“或”）分隔。

### 2.2.2 推导
根据文法对到符号串时，我们首先从符号触发，不断地将某个非终结符号替换为该非终结符号的某个产生式的体。可以从开始符号推导得到的所有终结符号串的集合称为该文法定义的语言（language）。

语法分析（parsing）的任务是：接受一个终结符号串作为输入，找出从文法的开始符号推导出这个串的方法。

一般情况下，一个源程序中会包含由多个字符组成的词素，这些词素由词法分析器组成词法单元，而词法单元的第一个分量就是被语法分析器处理的的终结符号。

### 2.2.3 语法分析树
一个文法的语言的另一个定义是指任何能够由某棵语法分析树生成的符号串的集合。

### 2.2.4 二义性

### 2.2.5 运算符的结合性
我们说运算符“+”是左结合（associate）的，因为当一个运算分量左右两侧都有“+”号时，它属于左边的运算符。

### 2.2.6 运算符的优先级
+和*的结合性规则只能作用于同一运算符的多次出现，因此他们无法解决这个二义性。当多种运算符出现时，我们需要给出一个规则来定义运算符之间的相对优先级。

我们可以将因子（factor）理解成不能被任何运算符分开的表达式。“不能分开”的意思是说当我们在任意因子的任意一边放置一个运算符，都不会导致这个因子的任何部分分离出来，成为这个运算符的运算分量。当然，因子本身作为一个整体可以成为该运算符的一个运算分量。如果这个因子是一个由括号括起来的表达式，那么括号将起到保护其不被分开的作用。如果因子就是一个运算分量，那么它当然不能被分开。

通常这个非终结符号的产生式体只能是单个运算分量或括号括起来的表达式。然后，对于每个优先级都有一个非终结符，表示能被该优先级或更高优先级的运算符分开的表达式。通常，这个非终结符的产生式有一些产生体表示了该优先级的运算符的应用；另有一个产生体只包含了代表更高一层优先级的非终结符。

请注意，任何由括号括起来的表达式都是一个因子。

## 2.3 语法制导翻译
语法制导翻译是通过向一个文法的产生式附加一些规则或程序片段而得到的。

两个语法制导翻译相关的概念：
* 属性（attribute）：属性表示与某个程序构造相关的任意的量。属性可以是多种多样的，比如表达式的数据类型、生成的代码中的指令数目或为某个构造生成的代码中第一条执行的位置等等都是属性的例子。
* （语法制导的）翻译方案（translation scheme）：翻译方案是一种将程序片段附加到一个文法的各个产生式上的表示法。当在文法分析过程中使用一个产生式时，相应的程序片段就会执行。这些程序片段的执行效果按照语法分析过程的顺序组合起来，得到的结果就是这次分析/综合过程处理源程序得到的翻译结果。

### 2.3.1 后缀表示
一个表达式E的后缀表示（postfix notation）可以按照下面的方式进行归纳定义：
1. 如果E是一个变量或常量，则E的后缀表示E本身；
2. 如果E是一个形如E1 op E2的表达式，其中op是一个二目运算符，那么E的后缀表示是A1 A2 op，这里A1和A2分别是E1和E2的后缀表示。
3. 如果E是一个形如（E1）的被括号括起来的表达式，则E 的后缀表示就是E1的的后缀表示。

运算符的位置和它的运算分量个数（arity）使得后缀表达式只有一种解码方式，所以在后缀表示中不需要括号。处理后缀表达式的技巧就是从左边开始不断扫描后缀传，直到发现一个运算符为止。然后向左找出适当数目的运算分量，并将这个运算符和它的运算分量组合在一起。计算出这个运算符作用于这些运算分量上后得到的结果，并用这个结果替换原来的运算分量和运算符。然后继续这个 过程，向右搜寻另一个运算符。

### 2.3.2 综合属性
语法制导定义（syntax-directed definition）把1每个文法符号和一个属性集合相关联，并且把2每个产生式和一组语义规则相关联，这些规则用于计算与该产生式中符号相关联的属性值。

### 2.3.3 简单语法制导定义
要得到代表产生式头部的非终结符号的翻译结果的字符串，只需要将产生式体中各非终结符号的翻译结果按照他们在非终结符号中的出现顺序连接起来，并在其中穿插一些附加的串即可。具有这个形式的语法制导定义称为简单（simple）语法制导定义。

### 2.3.4 树的遍历
一次深度优先（depth-first）遍历从根结点开始，递归地按照任意顺序访问各个结点的子节点，并不一定要按照从左向右的顺序遍历。

### 2.3.5 翻译方案
我们经常遍历一棵树，并在各个结点上执行某些特定的动作。如果动作在我们第一次访问一个节点时被执行，那么我们将这种遍历称为前序遍历（preorder traversal）。类似地，如果动作在我们最后离开一个节点前被执行，则称这种遍历为后序遍历（postorder traversal）。

语法制导翻译方案是一种在文法产生式中附加一些程序片段来描述翻译结果的标识方法。

实现一个翻译方案时，必须保证各个语义动作按照它们在语法分析树中的后续遍历中的顺序执行。

## 2.4 语法分析
语法分析时决定如何使用一个文法生成一个终结符号串的过程。

线性时间复杂度的算法足以分析实践中出现的各种程序设计语言。

### 2.4.1 自顶向下分析方法

### 2.4.2 预测分析法

### 2.4.3 如何使用“空”产生式

### 2.4.4 设计一个预测分析器










