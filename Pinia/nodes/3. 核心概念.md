## 1 定义一个 Store

```ts
export const useStore = defineStore('app', {
	// other options
})
```

### 1.1 使用Store 

一旦store被示例化，你可以访问store定义的任何`state`、`getters`以及`actions`

请注意`store`是一个用`reactive`包裹的对象。

为了保持从store中提取的属性的响应性，您需要使用`storeToRefs()`。它将为任何响应性属性创建refs。这适合你仅仅使用state但是不调用任何action。

## 2. State

state被定义为一个函数，返回内部的state。

### 2.1 访问`state`

默认情况下，你可以通过`store`实例来访问状态来直接读写state。

### 2.2 重置 state

`store.$reset()`

### 2.3 改变 state

除了直接使用像`store.counter++`改变store之外，你还可以调用该`$patch`方法。它运行你对`state`中的一部分应用多个更改。该`$patch`方法还接受一个函数来对这种难以应用补丁对象的突变进行分组。

### 2.4 替换 `state`

您可以通过将store的`$state`属性设置为新对象来替换store的整个状态。

### 2.5 订阅 `state`

您可以通过store.$subscribe()来侦听state的修改。他和Vuex的subscribe方法相似。

和一个普通的watch相比，使用`$subscribe()`的优点是订阅只会在打补丁后触发一次。（例如上面的patch函数版本）

默认，订阅是和组件绑定的，换句话说，组件被卸载时，订阅将被自动移除。你可以向$subsribe()方法传第二个参数`true`，这个订阅将在组件卸载后保留。

[^提示]: 你可以使用watch侦听store实例的整个state。



## 3. Getters

Getters完全等同于state的计算值。

大多数时候，getter只会依赖state，但是它们可能需要其他getter。正因如此，我们可以通过定义一个常规函数来访问整个store实例，但是需要当以返回类型值类型（在TypeScript中）。

### 3.1 访问其他getters

可以使用普通方法内使用`this`

即使您不适用TypeScript，你也可以使用JSDoc提示您的IDE类型。

### 3.2 向 getter 传参

Getter只是幕后的计算属性，因此无法向他们传递任何参数。但是，您可以从getter返回一个函数来接受任何参数。

请注意，执行此操作时，不会再缓存getter，它们只是您调用的函数。但是，你可以在getter本身内部缓存一些结果，这并不常见，但应该性能更高。

### 3.3 使用其他store的getter

要使用另一个store的getter，您可以直接在getter内部使用它。

### 3.4 在`setup()`中使用

你可以访问任何一个getter作为一个属性，就像state中的属性一样

## 4. Actions

actions相当于组件中的方法。

通过在`defineStore()`中定义`actions`属性，对定义业务逻辑来说，它们是完美的。

像 getters，actions能够通过this访问整个store实例。`actions`可以是异步的。你可以使用`await`在内部调用任何api或其他actions，

您也可以完全自由地设置你想要的任何参数并返回任何内容。调用actions时，一切都会自动推断。

### 4.1 访问其他store的actions

和getters一样，你可以直接在actions内部使用它。

### 4.2 订阅 actions

通过`store.$onAction()`订阅。

回调会在action之前执行，`after` handle promises允许你修改action的放回置。`onError`允许您阻止错误传播。这些对于在运行时跟踪错误很有用。

默认情况下，它们也是和组件自动绑定和解绑的。如果您希望在组件卸载后订阅依然可用，可以给`$onAction()`第二个参数传`true`。

## 5. 插件

由于低级别API，Pinia stores能够被完全继承。下面是一个你能够做的事情的列表：

- 给stores添加新属性
- 添加新的参数当定义stores时
- 给stores添加新方法
- 包装已存在的方法
- 更改甚至取消actions
- 实现像local storage的副作用
- 仅应用于特定stores

通过pinia实例的`pinia.use()`方法添加插件

最简单的例子是给所有的stores添加一个静态属性通过返回一个对象。

## 6. 在组件外部使用store

Pinia stores依赖`pinia`实例去分享相同的store实例在所有的调用中。

在组件内，`useStore()`会自动注入你传给`app` 的`pinia`实例。这意味这如果`pinia`实例如果不能够注入，你就不得不手动把它提供给`useStore()`函数。您可以根据您正在编写的应用程序类型以不同的方式解决这个问题。